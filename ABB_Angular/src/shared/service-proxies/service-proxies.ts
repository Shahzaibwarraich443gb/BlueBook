//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    generateRandomNo(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/GenerateRandomNo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateRandomNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateRandomNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGenerateRandomNo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param phoneNumber (optional) 
     * @return Success
     */
    sendOTP(phoneNumber: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendOTP?";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "phoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSendOTP(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AccountTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAccountType(body: CreateOrEditAccountTypeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/CreateOrEditAccountType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAccountType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAccountType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditAccountType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deletAccountTypes(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/DeletAccountTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletAccountTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletAccountTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAccountTypes(id: number | undefined): Observable<AccountTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/GetAccountTypes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTypeDto>;
        }));
    }

    protected processGetAccountTypes(response: HttpResponseBase): Observable<AccountTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AddressServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAddressDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Address/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Address/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/services/app/Address/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<AddressDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Address/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AttachmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    upload(): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachment/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customerAttachmentsGet(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachment/CustomerAttachmentsGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomerAttachmentsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomerAttachmentsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCustomerAttachmentsGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getFile(fileName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachment/GetFile/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    deleteFile(fileName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachment/DeleteFile/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BalanceSheetServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param _StartDate (optional) 
     * @param _EndDate (optional) 
     * @return Success
     */
    getList(_StartDate: moment.Moment | undefined, _EndDate: moment.Moment | undefined): Observable<BalanceSheetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BalanceSheetService/GetList?";
        if (_StartDate === null)
            throw new Error("The parameter '_StartDate' cannot be null.");
        else if (_StartDate !== undefined)
            url_ += "_StartDate=" + encodeURIComponent(_StartDate ? "" + _StartDate.toISOString() : "") + "&";
        if (_EndDate === null)
            throw new Error("The parameter '_EndDate' cannot be null.");
        else if (_EndDate !== undefined)
            url_ += "_EndDate=" + encodeURIComponent(_EndDate ? "" + _EndDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceSheetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceSheetDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<BalanceSheetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BalanceSheetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BankServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBankDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Bank/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<BankDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<BankDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Bank/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BankDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BankDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CalenderServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    addInvoiceReminder(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CalenderService/AddInvoiceReminder?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddInvoiceReminder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddInvoiceReminder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddInvoiceReminder(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChartOfAccountsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditChartOfAccount(body: CreateOrEditChartOfAccountInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/CreateOrEditChartOfAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditChartOfAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditChartOfAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditChartOfAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deletChartOfAccounts(body: EntityDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/DeletChartOfAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletChartOfAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletChartOfAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeletChartOfAccounts(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getChartOfAccounts(id: number | undefined): Observable<ChartOfAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetChartOfAccounts?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChartOfAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartOfAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto>;
        }));
    }

    protected processGetChartOfAccounts(response: HttpResponseBase): Observable<ChartOfAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartOfAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param type (optional) 
     * @param bankCoaId (optional) 
     * @param previousAmount (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeCoaBalance(type: string | undefined, bankCoaId: number | undefined, previousAmount: number | undefined, body: InvoiceDetailDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/ChangeCoaBalance?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (bankCoaId === null)
            throw new Error("The parameter 'bankCoaId' cannot be null.");
        else if (bankCoaId !== undefined)
            url_ += "bankCoaId=" + encodeURIComponent("" + bankCoaId) + "&";
        if (previousAmount === null)
            throw new Error("The parameter 'previousAmount' cannot be null.");
        else if (previousAmount !== undefined)
            url_ += "previousAmount=" + encodeURIComponent("" + previousAmount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeCoaBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeCoaBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeCoaBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getChartOfAccountList(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetChartOfAccountList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChartOfAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartOfAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetChartOfAccountList(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getChartOfAccountsForRP(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetChartOfAccountsForRP";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChartOfAccountsForRP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartOfAccountsForRP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetChartOfAccountsForRP(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getChartOfAccountsForJV(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetChartOfAccountsForJV";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChartOfAccountsForJV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartOfAccountsForJV(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetChartOfAccountsForJV(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getControlAccounts(id: number | undefined): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetControlAccounts?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetControlAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetControlAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetControlAccounts(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllChartOfAccountPagedList(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ChartOfAccountListViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetAllChartOfAccountPagedList?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChartOfAccountPagedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartOfAccountPagedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountListViewDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountListViewDtoPagedResultDto>;
        }));
    }

    protected processGetAllChartOfAccountPagedList(response: HttpResponseBase): Observable<ChartOfAccountListViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartOfAccountListViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountTypeId (optional) 
     * @return Success
     */
    gatAllMainHeadByAccountType(accountTypeId: number | undefined): Observable<MainHeadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GatAllMainHeadByAccountType?";
        if (accountTypeId === null)
            throw new Error("The parameter 'accountTypeId' cannot be null.");
        else if (accountTypeId !== undefined)
            url_ += "accountTypeId=" + encodeURIComponent("" + accountTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatAllMainHeadByAccountType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatAllMainHeadByAccountType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainHeadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainHeadDto[]>;
        }));
    }

    protected processGatAllMainHeadByAccountType(response: HttpResponseBase): Observable<MainHeadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MainHeadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllMainHead(): Observable<MainHeadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetAllMainHead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMainHead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMainHead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainHeadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainHeadDto[]>;
        }));
    }

    protected processGetAllMainHead(response: HttpResponseBase): Observable<MainHeadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MainHeadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountNatureId (optional) 
     * @return Success
     */
    getAllAccountTypeByAccountNature(accountNatureId: number | undefined): Observable<AccountTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetAllAccountTypeByAccountNature?";
        if (accountNatureId === null)
            throw new Error("The parameter 'accountNatureId' cannot be null.");
        else if (accountNatureId !== undefined)
            url_ += "accountNatureId=" + encodeURIComponent("" + accountNatureId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountTypeByAccountNature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountTypeByAccountNature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTypeDto[]>;
        }));
    }

    protected processGetAllAccountTypeByAccountNature(response: HttpResponseBase): Observable<AccountTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountNature (optional) 
     * @return Success
     */
    getLastAccountTypeCodeByNature(accountNature: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetLastAccountTypeCodeByNature?";
        if (accountNature === null)
            throw new Error("The parameter 'accountNature' cannot be null.");
        else if (accountNature !== undefined)
            url_ += "accountNature=" + encodeURIComponent("" + accountNature) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastAccountTypeCodeByNature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastAccountTypeCodeByNature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLastAccountTypeCodeByNature(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountTypeId (optional) 
     * @return Success
     */
    getLastMainHeadByAccountType(accountTypeId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetLastMainHeadByAccountType?";
        if (accountTypeId === null)
            throw new Error("The parameter 'accountTypeId' cannot be null.");
        else if (accountTypeId !== undefined)
            url_ += "accountTypeId=" + encodeURIComponent("" + accountTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastMainHeadByAccountType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastMainHeadByAccountType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLastMainHeadByAccountType(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllLiabilitiesAccount(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetAllLiabilitiesAccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLiabilitiesAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLiabilitiesAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetAllLiabilitiesAccount(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAdvanceSaleTaxAccount(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccounts/GetAllAdvanceSaleTaxAccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdvanceSaleTaxAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdvanceSaleTaxAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetAllAdvanceSaleTaxAccount(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CheckServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param showDeleted (optional) 
     * @param bankId (optional) 
     * @return Success
     */
    getCheck(showDeleted: boolean | undefined, bankId: number | undefined): Observable<CheckDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetCheck?";
        if (showDeleted === null)
            throw new Error("The parameter 'showDeleted' cannot be null.");
        else if (showDeleted !== undefined)
            url_ += "showDeleted=" + encodeURIComponent("" + showDeleted) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "bankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckDto[]>;
        }));
    }

    protected processGetCheck(response: HttpResponseBase): Observable<CheckDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCheck(body: CheckDto | undefined): Observable<Check> {
        let url_ = this.baseUrl + "/api/services/app/Check/AddCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Check>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Check>;
        }));
    }

    protected processAddCheck(response: HttpResponseBase): Observable<Check> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Check.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCheckById(body: CheckDto | undefined): Observable<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetCheckById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckDto>;
        }));
    }

    protected processGetCheckById(response: HttpResponseBase): Observable<CheckDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteCheck(body: CheckDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Check/DeleteCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCheck(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCheckFooter(): Observable<{ [key: string]: any; }[]> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetCheckFooter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckFooter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckFooter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: any; }[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: any; }[]>;
        }));
    }

    protected processGetCheckFooter(response: HttpResponseBase): Observable<{ [key: string]: any; }[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCheckSetup(): Observable<CheckSetupDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetCheckSetup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckSetupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckSetupDto>;
        }));
    }

    protected processGetCheckSetup(response: HttpResponseBase): Observable<CheckSetupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckSetupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCheckSetup(body: CheckSetupDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Check/SaveCheckSetup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCheckSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCheckSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCheckSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPayee(): Observable<PayeeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetPayee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayeeDto[]>;
        }));
    }

    protected processGetPayee(response: HttpResponseBase): Observable<PayeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PayeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customersLookups(body: CustomerLookupDto | undefined): Observable<Int32StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/CustomersLookups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomersLookups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomersLookups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32StringKeyValuePair[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32StringKeyValuePair[]>;
        }));
    }

    protected processCustomersLookups(response: HttpResponseBase): Observable<Int32StringKeyValuePair[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Int32StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCompanyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<CompanyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CompanyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompanyDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMerchant(): Observable<GeneralMerchantDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDetails/GetMerchant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto>;
        }));
    }

    protected processGetMerchant(response: HttpResponseBase): Observable<GeneralMerchantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralMerchantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMerchantOnId(id: number | undefined): Observable<GeneralMerchantDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDetails/GetMerchantOnId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchantOnId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchantOnId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto>;
        }));
    }

    protected processGetMerchantOnId(response: HttpResponseBase): Observable<GeneralMerchantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralMerchantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getMerchants(): Observable<GeneralMerchantDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDetails/GetMerchants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto[]>;
        }));
    }

    protected processGetMerchants(response: HttpResponseBase): Observable<GeneralMerchantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralMerchantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    updateSelectedMerchant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDetails/updateSelectedMerchant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSelectedMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSelectedMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSelectedMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompanySettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMerchant(): Observable<GeneralMerchantDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanySettings/GetMerchant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto>;
        }));
    }

    protected processGetMerchant(response: HttpResponseBase): Observable<GeneralMerchantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralMerchantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMerchantOnId(id: number | undefined): Observable<GeneralMerchantDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanySettings/GetMerchantOnId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchantOnId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchantOnId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto>;
        }));
    }

    protected processGetMerchantOnId(response: HttpResponseBase): Observable<GeneralMerchantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralMerchantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getMerchants(): Observable<GeneralMerchantDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CompanySettings/GetMerchants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto[]>;
        }));
    }

    protected processGetMerchants(response: HttpResponseBase): Observable<GeneralMerchantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralMerchantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    updateSelectedMerchant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanySettings/updateSelectedMerchant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSelectedMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSelectedMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSelectedMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContactDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditContactDetalsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    get(): Observable<GeneralContactDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactDetails/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralContactDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralContactDetailsDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GeneralContactDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralContactDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAlluser(): Observable<User> {
        let url_ = this.baseUrl + "/api/services/app/ContactDetails/GetAlluser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlluser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlluser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetAlluser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAdminUser(): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactDetails/GetAdminUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGetAdminUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactDetails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContactPersonTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditContactPersonTypeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactPersonType/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactPersonType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ContactPersonTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactPersonType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactPersonTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactPersonTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContactPersonTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactPersonTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ContactPersonTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ContactPersonType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactPersonTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactPersonTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContactPersonTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContactPersonTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CorporateTaxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCorporateTax(body: CorporateTaxDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CorporateTax/SaveCorporateTax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCorporateTax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCorporateTax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCorporateTax(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    corporateTaxGet(body: CorporateTaxDto | undefined): Observable<CorporateTaxDto> {
        let url_ = this.baseUrl + "/api/services/app/CorporateTax/CorporateTaxGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCorporateTaxGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCorporateTaxGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateTaxDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateTaxDto>;
        }));
    }

    protected processCorporateTaxGet(response: HttpResponseBase): Observable<CorporateTaxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateTaxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CreditNoteServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCreditNote(body: SaveCreditNoteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CreditNoteService/SaveCreditNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCreditNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCreditNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCreditNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCustomerDto | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSpouse(body: SpouseDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Customer/SaveSpouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSpouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSpouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveSpouse(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveDependent(customerId: number | undefined, body: Dependent[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Customer/SaveDependent?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDependent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDependent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveDependent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomer(id: number | undefined): Observable<CustomerInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomer?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerInfoDto>;
        }));
    }

    protected processGetCustomer(response: HttpResponseBase): Observable<CustomerInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSpouse(id: number | undefined): Observable<SpouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetSpouse?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpouseDto>;
        }));
    }

    protected processGetSpouse(response: HttpResponseBase): Observable<SpouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    dependentGet(id: number | undefined): Observable<Dependent> {
        let url_ = this.baseUrl + "/api/services/app/Customer/DependentGet?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependentGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependentGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Dependent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Dependent>;
        }));
    }

    protected processDependentGet(response: HttpResponseBase): Observable<Dependent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dependent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param custId (optional) 
     * @return Success
     */
    dependentGetListByCustomerId(custId: number | undefined): Observable<Dependent[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/DependentGetListByCustomerId?";
        if (custId === null)
            throw new Error("The parameter 'custId' cannot be null.");
        else if (custId !== undefined)
            url_ += "custId=" + encodeURIComponent("" + custId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDependentGetListByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDependentGetListByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Dependent[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Dependent[]>;
        }));
    }

    protected processDependentGetListByCustomerId(response: HttpResponseBase): Observable<Dependent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Dependent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCustomerDetail(body: CreateOrEditCustomerDto | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UpdateCustomerDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomerDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomerDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processUpdateCustomerDetail(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCustomerUser(body: CreateOrEditCustomerDto | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UpdateCustomerUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processUpdateCustomerUser(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCustomerAddress(body: CreateOrEditCustomerDto | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UpdateCustomerAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomerAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomerAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processUpdateCustomerAddress(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCustomerContactInfo(body: CreateOrEditCustomerDto | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UpdateCustomerContactInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomerContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomerContactInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processUpdateCustomerContactInfo(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCustomerTaxSelection(body: CustomerTaxSelection | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/SaveCustomerTaxSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCustomerTaxSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCustomerTaxSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCustomerTaxSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customerTaxSelectionGet(body: EntityDto | undefined): Observable<CustomerTaxSelection[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/CustomerTaxSelectionGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomerTaxSelectionGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomerTaxSelectionGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTaxSelection[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTaxSelection[]>;
        }));
    }

    protected processCustomerTaxSelectionGet(response: HttpResponseBase): Observable<CustomerTaxSelection[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerTaxSelection.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerForEdit(id: number | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processGetCustomerForEdit(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerLicenseData(customerId: number | undefined): Observable<Customer> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerLicenseData?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerLicenseData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerLicenseData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processGetCustomerLicenseData(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerComment(customerId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerComment?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCustomerComment(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param comment (optional) 
     * @return Success
     */
    saveCustomerComment(customerId: number | undefined, comment: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Customer/SaveCustomerComment?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        if (comment === null)
            throw new Error("The parameter 'comment' cannot be null.");
        else if (comment !== undefined)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCustomerComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCustomerComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveCustomerComment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCRMData(customerId: number | undefined): Observable<Customer> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCRMData?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCRMData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCRMData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processGetCRMData(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerTodoListData(customerId: number | undefined): Observable<Customer> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerTodoListData?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTodoListData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTodoListData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processGetCustomerTodoListData(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCustomerPassword(body: CustomerPassword | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Customer/SaveCustomerPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCustomerPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCustomerPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveCustomerPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCustomerPassword(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Customer/DeleteCustomerPassword?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomerPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomerPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteCustomerPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param comment (optional) 
     * @param customerId (optional) 
     * @return Success
     */
    addPasswordComment(comment: string | undefined, customerId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Customer/AddPasswordComment?";
        if (comment === null)
            throw new Error("The parameter 'comment' cannot be null.");
        else if (comment !== undefined)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPasswordComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPasswordComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddPasswordComment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    passwordCommentGet(customerId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Customer/PasswordCommentGet?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordCommentGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordCommentGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPasswordCommentGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    customerPasswordGet(customerId: number | undefined): Observable<CustomerPassword[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/CustomerPasswordGet?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomerPasswordGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomerPasswordGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerPassword[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerPassword[]>;
        }));
    }

    protected processCustomerPasswordGet(response: HttpResponseBase): Observable<CustomerPassword[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerPassword.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param filterType (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, filterType: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CustomerDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (filterType === null)
            throw new Error("The parameter 'filterType' cannot be null.");
        else if (filterType !== undefined)
            url_ += "filterType=" + encodeURIComponent("" + filterType) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CustomerDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerInfo(id: number | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processGetCustomerInfo(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerDetails(customerId: number | undefined): Observable<CreateOrEditCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerDetails?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditCustomerDto>;
        }));
    }

    protected processGetCustomerDetails(response: HttpResponseBase): Observable<CreateOrEditCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCustomersByTenantId(): Observable<Customer[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomersByTenantId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer[]>;
        }));
    }

    protected processGetCustomersByTenantId(response: HttpResponseBase): Observable<Customer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Customer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerContact(customerId: number | undefined): Observable<ContactInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerContact?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto[]>;
        }));
    }

    protected processGetCustomerContact(response: HttpResponseBase): Observable<ContactInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContactInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerAddress(customerId: number | undefined): Observable<CustomerAddressDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerAddress?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerAddressDto[]>;
        }));
    }

    protected processGetCustomerAddress(response: HttpResponseBase): Observable<CustomerAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerUsers(customerId: number | undefined): Observable<UserNamePasswordDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerUsers?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserNamePasswordDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserNamePasswordDto[]>;
        }));
    }

    protected processGetCustomerUsers(response: HttpResponseBase): Observable<UserNamePasswordDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserNamePasswordDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param subject (optional) 
     * @param emailBody (optional) 
     * @param fileName (optional) 
     * @param customerId (optional) 
     * @return Success
     */
    sendEmailToCustomer(subject: string | undefined, emailBody: string | undefined, fileName: string | undefined, customerId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/SendEmailToCustomer?";
        if (subject === null)
            throw new Error("The parameter 'subject' cannot be null.");
        else if (subject !== undefined)
            url_ += "Subject=" + encodeURIComponent("" + subject) + "&";
        if (emailBody === null)
            throw new Error("The parameter 'emailBody' cannot be null.");
        else if (emailBody !== undefined)
            url_ += "EmailBody=" + encodeURIComponent("" + emailBody) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailToCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailToCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CustomerDiaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCustomerDiary(body: CustomerDiary | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerDiary/SaveCustomerDiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCustomerDiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCustomerDiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCustomerDiary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCustomerDiary(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerDiary/DeleteCustomerDiary?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomerDiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomerDiary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCustomerDiary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customerDiaryGet(body: EntityDto | undefined): Observable<CustomerDiary[]> {
        let url_ = this.baseUrl + "/api/services/app/CustomerDiary/CustomerDiaryGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomerDiaryGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomerDiaryGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDiary[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDiary[]>;
        }));
    }

    protected processCustomerDiaryGet(response: HttpResponseBase): Observable<CustomerDiary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerDiary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CustomerLedgerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getLedgerForTable(body: GetGeneralLedgerInputDto | undefined): Observable<GeneralLedgerOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CustomerLedger/GetLedgerForTable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLedgerForTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLedgerForTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralLedgerOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralLedgerOutputDto[]>;
        }));
    }

    protected processGetLedgerForTable(response: HttpResponseBase): Observable<GeneralLedgerOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralLedgerOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CustomerTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCustomerTypeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CustomerTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<CustomerTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CustomerTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DailyReceiptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param _StartDate (optional) 
     * @param _EndDate (optional) 
     * @param _PaymentMethodId (optional) 
     * @param _AccountId (optional) 
     * @return Success
     */
    getList(_StartDate: moment.Moment | undefined, _EndDate: moment.Moment | undefined, _PaymentMethodId: number | undefined, _AccountId: number | undefined): Observable<DailyReceiptDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DailyReceipt/GetList?";
        if (_StartDate === null)
            throw new Error("The parameter '_StartDate' cannot be null.");
        else if (_StartDate !== undefined)
            url_ += "_StartDate=" + encodeURIComponent(_StartDate ? "" + _StartDate.toISOString() : "") + "&";
        if (_EndDate === null)
            throw new Error("The parameter '_EndDate' cannot be null.");
        else if (_EndDate !== undefined)
            url_ += "_EndDate=" + encodeURIComponent(_EndDate ? "" + _EndDate.toISOString() : "") + "&";
        if (_PaymentMethodId === null)
            throw new Error("The parameter '_PaymentMethodId' cannot be null.");
        else if (_PaymentMethodId !== undefined)
            url_ += "_PaymentMethodId=" + encodeURIComponent("" + _PaymentMethodId) + "&";
        if (_AccountId === null)
            throw new Error("The parameter '_AccountId' cannot be null.");
        else if (_AccountId !== undefined)
            url_ += "_AccountId=" + encodeURIComponent("" + _AccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DailyReceiptDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DailyReceiptDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<DailyReceiptDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DailyReceiptDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DLStatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDLState(): Observable<DLState[]> {
        let url_ = this.baseUrl + "/api/services/app/DLStates/GetDLState";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDLState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDLState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DLState[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DLState[]>;
        }));
    }

    protected processGetDLState(response: HttpResponseBase): Observable<DLState[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DLState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    sendEmail(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Email/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMail(body: EmailsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Email/SendMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEmailInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Email/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Email/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<EmailDto> {
        let url_ = this.baseUrl + "/api/services/app/Email/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EmailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<EmailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Email/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EmailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EmailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmployeActivitiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param _StartDate (optional) 
     * @param _EndDate (optional) 
     * @param methodName (optional) 
     * @return Success
     */
    getList(_StartDate: moment.Moment | undefined, _EndDate: moment.Moment | undefined, methodName: string | undefined): Observable<AuditLogsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EmployeActivities/GetList?";
        if (_StartDate === null)
            throw new Error("The parameter '_StartDate' cannot be null.");
        else if (_StartDate !== undefined)
            url_ += "_StartDate=" + encodeURIComponent(_StartDate ? "" + _StartDate.toISOString() : "") + "&";
        if (_EndDate === null)
            throw new Error("The parameter '_EndDate' cannot be null.");
        else if (_EndDate !== undefined)
            url_ += "_EndDate=" + encodeURIComponent(_EndDate ? "" + _EndDate.toISOString() : "") + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuditLogsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuditLogsDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<AuditLogsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AuditLogsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EstimateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/SaveInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPaymentTermTermLists(): Observable<PaymentTermList[]> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/GetPaymentTermTermLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentTermTermLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentTermTermLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTermList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTermList[]>;
        }));
    }

    protected processGetPaymentTermTermLists(response: HttpResponseBase): Observable<PaymentTermList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentTermList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getActiveProductList(): Observable<ProductService[]> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/GetActiveProductList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveProductList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveProductList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductService[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductService[]>;
        }));
    }

    protected processGetActiveProductList(response: HttpResponseBase): Observable<ProductService[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductService.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param to (optional) 
     * @param emails (optional) 
     * @param body (optional) 
     * @return Success
     */
    emailEstimate(to: string | undefined, emails: string | undefined, body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/EmailEstimate?";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (emails === null)
            throw new Error("The parameter 'emails' cannot be null.");
        else if (emails !== undefined)
            url_ += "Emails=" + encodeURIComponent("" + emails) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmailEstimate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmailEstimate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEmailEstimate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceBalance(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/GetInvoiceBalance?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetInvoiceBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productServicesLookUp(body: StringCommonLookupInput | undefined): Observable<Int32StringKeyValuePairListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/ProductServicesLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductServicesLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductServicesLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32StringKeyValuePairListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32StringKeyValuePairListResultDto>;
        }));
    }

    protected processProductServicesLookUp(response: HttpResponseBase): Observable<Int32StringKeyValuePairListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32StringKeyValuePairListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customersLookUp(body: StringCommonLookupInput | undefined): Observable<CustomerLookupOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/CustomersLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomersLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomersLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLookupOutputListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLookupOutputListResultDto>;
        }));
    }

    protected processCustomersLookUp(response: HttpResponseBase): Observable<CustomerLookupOutputListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLookupOutputListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCompanyName(customerId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Estimate/GetCompanyName?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCompanyName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EthnicitiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEthnicityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ethnicities/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ethnicities/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<EthnicityDto> {
        let url_ = this.baseUrl + "/api/services/app/Ethnicities/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EthnicityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EthnicityDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EthnicityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EthnicityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<EthnicityDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Ethnicities/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EthnicityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EthnicityDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EthnicityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EthnicityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GeneralEntityTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditGeneralEntityTypeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralEntityType/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralEntityType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<GeneralEntityTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralEntityType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralEntityTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralEntityTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GeneralEntityTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralEntityTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<GeneralEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/GeneralEntityType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralEntityTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GeneralEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GeneralLedgerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addLedger(body: AddGeneralLedgarInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedger/AddLedger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLedger(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddLedger(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    coaData(body: ChartOfAccount[] | undefined): Observable<GeneralLedgerChartOfAccountData[]> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedger/CoaData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoaData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoaData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralLedgerChartOfAccountData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralLedgerChartOfAccountData[]>;
        }));
    }

    protected processCoaData(response: HttpResponseBase): Observable<GeneralLedgerChartOfAccountData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralLedgerChartOfAccountData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getLedgerForTable(body: GetGeneralLedgerInputDto | undefined): Observable<GeneralLedgerOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedger/GetLedgerForTable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLedgerForTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLedgerForTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralLedgerOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralLedgerOutputDto[]>;
        }));
    }

    protected processGetLedgerForTable(response: HttpResponseBase): Observable<GeneralLedgerOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralLedgerOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param headers (optional) 
     * @param customerId (optional) 
     * @param type (optional) 
     * @return Success
     */
    saveHeaders(headers: string | undefined, customerId: number | undefined, type: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedger/SaveHeaders?";
        if (headers === null)
            throw new Error("The parameter 'headers' cannot be null.");
        else if (headers !== undefined)
            url_ += "Headers=" + encodeURIComponent("" + headers) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveHeaders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveHeaders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param type (optional) 
     * @return Success
     */
    getHeaders(customerId: number | undefined, type: string | undefined): Observable<LedgerHeaders> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedger/GetHeaders?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHeaders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LedgerHeaders>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LedgerHeaders>;
        }));
    }

    protected processGetHeaders(response: HttpResponseBase): Observable<LedgerHeaders> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LedgerHeaders.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvoice(body: CreateInvoiceDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SaveInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveInvoice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoices(body: Invoice | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateInvoices(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param toEmail (optional) 
     * @param body (optional) 
     * @return Success
     */
    senNewEmailIN(toEmail: string | undefined, body: PrintDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SenNewEmailIN?";
        if (toEmail === null)
            throw new Error("The parameter 'toEmail' cannot be null.");
        else if (toEmail !== undefined)
            url_ += "toEmail=" + encodeURIComponent("" + toEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSenNewEmailIN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSenNewEmailIN(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSenNewEmailIN(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPRInvoice(body: Invoice | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreatePRInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePRInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePRInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePRInvoice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSRInvoice(body: Invoice | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateSRInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSRInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSRInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateSRInvoice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: Invoice | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvoiceDetails(body: Invoice | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/UpdateInvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateInvoiceDetails(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addNewVouchers(invoiceId: number | undefined, body: Voucher | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/AddNewVouchers?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewVouchers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewVouchers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddNewVouchers(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addNewVouchersSaleReceipt(invoiceId: number | undefined, body: Voucher[] | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/AddNewVouchersSaleReceipt?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewVouchersSaleReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewVouchersSaleReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddNewVouchersSaleReceipt(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoiceByIdGet(body: Int64EntityDto | undefined): Observable<Invoice> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/InvoiceByIdGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceByIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice>;
        }));
    }

    protected processInvoiceByIdGet(response: HttpResponseBase): Observable<Invoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param _Code (optional) 
     * @param voucherNo (optional) 
     * @return Success
     */
    generateVoucherNumber(_Code: string | undefined, voucherNo: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/generateVoucherNumber?";
        if (_Code === null)
            throw new Error("The parameter '_Code' cannot be null.");
        else if (_Code !== undefined)
            url_ += "_Code=" + encodeURIComponent("" + _Code) + "&";
        if (voucherNo === null)
            throw new Error("The parameter 'voucherNo' cannot be null.");
        else if (voucherNo !== undefined)
            url_ += "VoucherNo=" + encodeURIComponent("" + voucherNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateVoucherNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateVoucherNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateVoucherNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param _Code (optional) 
     * @return Success
     */
    getVoucherDescription(_Code: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetVoucherDescription?";
        if (_Code === null)
            throw new Error("The parameter '_Code' cannot be null.");
        else if (_Code !== undefined)
            url_ += "_Code=" + encodeURIComponent("" + _Code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVoucherDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVoucherDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetVoucherDescription(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param voucherTypeCode (optional) 
     * @return Success
     */
    getVoucherNumber(voucherTypeCode: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetVoucherNumber?";
        if (voucherTypeCode === null)
            throw new Error("The parameter 'voucherTypeCode' cannot be null.");
        else if (voucherTypeCode !== undefined)
            url_ += "voucherTypeCode=" + encodeURIComponent("" + voucherTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVoucherNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVoucherNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetVoucherNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoice(id: number | undefined): Observable<Invoice> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice>;
        }));
    }

    protected processGetInvoice(response: HttpResponseBase): Observable<Invoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceType (optional) 
     * @return Success
     */
    getInvoiceNumber(invoiceType: InvoiceType | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceNumber?";
        if (invoiceType === null)
            throw new Error("The parameter 'invoiceType' cannot be null.");
        else if (invoiceType !== undefined)
            url_ += "invoiceType=" + encodeURIComponent("" + invoiceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetInvoiceNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    getPurchaseInvoiceBalance(invoiceId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetPurchaseInvoiceBalance?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseInvoiceBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseInvoiceBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetPurchaseInvoiceBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerBalance(customerId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetCustomerBalance?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCustomerBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceBalance(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceBalance?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetInvoiceBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerTransaction(customerId: number | undefined): Observable<CustomerTransactionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetCustomerTransaction?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTransactionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTransactionDto[]>;
        }));
    }

    protected processGetCustomerTransaction(response: HttpResponseBase): Observable<CustomerTransactionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerTransactionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllTransactions(): Observable<CustomerTransactionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetAllTransactions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTransactionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTransactionDto[]>;
        }));
    }

    protected processGetAllTransactions(response: HttpResponseBase): Observable<CustomerTransactionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerTransactionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTransactionDetail(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/DeleteTransactionDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransactionDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransactionDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteTransactionDetail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReceivedPaymentList(id: number | undefined): Observable<ReceviedPayment[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetReceivedPaymentList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceivedPaymentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceivedPaymentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceviedPayment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceviedPayment[]>;
        }));
    }

    protected processGetReceivedPaymentList(response: HttpResponseBase): Observable<ReceviedPayment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReceviedPayment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPurchasePaymentList(id: number | undefined): Observable<ReceviedPayment[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetPurchasePaymentList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchasePaymentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchasePaymentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceviedPayment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceviedPayment[]>;
        }));
    }

    protected processGetPurchasePaymentList(response: HttpResponseBase): Observable<ReceviedPayment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReceviedPayment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceDetails(id: number | undefined): Observable<InvoiceDetails[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDetails[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDetails[]>;
        }));
    }

    protected processGetInvoiceDetails(response: HttpResponseBase): Observable<InvoiceDetails[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReceivedPaymentDetails(id: number | undefined): Observable<ReceviedPayment[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetReceivedPaymentDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceivedPaymentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceivedPaymentDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceviedPayment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceviedPayment[]>;
        }));
    }

    protected processGetReceivedPaymentDetails(response: HttpResponseBase): Observable<ReceviedPayment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReceviedPayment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    getPrintDetails(invoiceId: number | undefined): Observable<PrintDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetPrintDetails?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrintDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrintDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintDto>;
        }));
    }

    protected processGetPrintDetails(response: HttpResponseBase): Observable<PrintDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllVouchers(): Observable<VoucherList[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetAllVouchers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVouchers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVouchers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoucherList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoucherList[]>;
        }));
    }

    protected processGetAllVouchers(response: HttpResponseBase): Observable<VoucherList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VoucherList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param companyId (optional) 
     * @return Success
     */
    getLinkedAccountId(id: number | undefined, companyId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetLinkedAccountId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedAccountId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedAccountId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLinkedAccountId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productServicesLookUp(body: StringCommonLookupInput | undefined): Observable<Int32StringKeyValuePairListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/ProductServicesLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductServicesLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductServicesLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32StringKeyValuePairListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32StringKeyValuePairListResultDto>;
        }));
    }

    protected processProductServicesLookUp(response: HttpResponseBase): Observable<Int32StringKeyValuePairListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32StringKeyValuePairListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customersLookUp(body: StringCommonLookupInput | undefined): Observable<CustomerLookupOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CustomersLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomersLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomersLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLookupOutputListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLookupOutputListResultDto>;
        }));
    }

    protected processCustomersLookUp(response: HttpResponseBase): Observable<CustomerLookupOutputListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLookupOutputListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobTitleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditJobTitleInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<JobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobTitleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<JobTitleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobTitleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobTitleDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobTitleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(JobTitleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JournalVoucherServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveJournalVoucher(body: SaveJournalVouchers | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/JournalVoucherService/SaveJournalVoucher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveJournalVoucher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveJournalVoucher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSaveJournalVoucher(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteVoucherDetail(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/JournalVoucherService/DeleteVoucherDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVoucherDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVoucherDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteVoucherDetail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditLanguageInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<LanguageDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LanguageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<LanguageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LanguageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LanguageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LegalStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLegalStatus(): Observable<LegalStatus[]> {
        let url_ = this.baseUrl + "/api/services/app/LegalStatus/GetAllLegalStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLegalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLegalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalStatus[]>;
        }));
    }

    protected processGetAllLegalStatus(response: HttpResponseBase): Observable<LegalStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LegalStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MainHeadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditMainHead(body: CreateOrEditMainHeadingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MainHead/CreateOrEditMainHead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditMainHead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditMainHead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditMainHead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deletMainHeads(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MainHead/DeletMainHeads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletMainHeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletMainHeads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletMainHeads(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMainHeads(id: number | undefined): Observable<MainHeadDto> {
        let url_ = this.baseUrl + "/api/services/app/MainHead/GetMainHeads?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainHeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainHeads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainHeadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainHeadDto>;
        }));
    }

    protected processGetMainHeads(response: HttpResponseBase): Observable<MainHeadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainHeadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MerchantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMerchantInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Merchant/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<GeneralMerchantDto> {
        let url_ = this.baseUrl + "/api/services/app/Merchant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GeneralMerchantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralMerchantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param merchantName (optional) 
     * @return Success
     */
    checkMerchantExistOrNot(merchantName: string | undefined): Observable<GeneralMerchantDto> {
        let url_ = this.baseUrl + "/api/services/app/Merchant/CheckMerchantExistOrNot?";
        if (merchantName === null)
            throw new Error("The parameter 'merchantName' cannot be null.");
        else if (merchantName !== undefined)
            url_ += "merchantName=" + encodeURIComponent("" + merchantName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckMerchantExistOrNot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckMerchantExistOrNot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto>;
        }));
    }

    protected processCheckMerchantExistOrNot(response: HttpResponseBase): Observable<GeneralMerchantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralMerchantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<GeneralMerchantDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Merchant/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralMerchantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralMerchantDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GeneralMerchantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralMerchantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Merchant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditGeneralPaymentMethodInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<GeneralPaymentMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralPaymentMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralPaymentMethodDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GeneralPaymentMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralPaymentMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<GeneralPaymentMethodDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralPaymentMethodDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralPaymentMethodDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GeneralPaymentMethodDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralPaymentMethodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PersonalInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditPersonalInformationInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PersonalInformation/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    get(): Observable<GeneralPersonalInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/PersonalInformation/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralPersonalInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralPersonalInformationDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GeneralPersonalInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralPersonalInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PersonalInformation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PersonalTaxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePersonalTax(body: PersonalTaxDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PersonalTax/SavePersonalTax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePersonalTax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePersonalTax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePersonalTax(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    personalTaxGet(body: PersonalTaxDto | undefined): Observable<PersonalTaxDto> {
        let url_ = this.baseUrl + "/api/services/app/PersonalTax/PersonalTaxGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonalTaxGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonalTaxGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonalTaxDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonalTaxDto>;
        }));
    }

    protected processPersonalTaxGet(response: HttpResponseBase): Observable<PersonalTaxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalTaxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PhoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditPhoneDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Phone/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Phone/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PhoneDto> {
        let url_ = this.baseUrl + "/api/services/app/Phone/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhoneDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PhoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PhoneDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<PhoneDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Phone/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhoneDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhoneDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PhoneDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PhoneDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ProductCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductServiceInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ProductServiceDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductServiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductServiceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductServiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductServiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ProductServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductServiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductServiceDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductServiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductServiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllIncome(): Observable<ProductServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/GetAllIncome";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncome(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductServiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductServiceDto[]>;
        }));
    }

    protected processGetAllIncome(response: HttpResponseBase): Observable<ProductServiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductServiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllExpense(): Observable<ProductServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/GetAllExpense";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductServiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductServiceDto[]>;
        }));
    }

    protected processGetAllExpense(response: HttpResponseBase): Observable<ProductServiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductServiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllChartAccountIncome(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/GetAllChartAccountIncome";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChartAccountIncome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartAccountIncome(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetAllChartAccountIncome(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllChartAccountExpense(): Observable<ChartOfAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductService/GetAllChartAccountExpense";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChartAccountExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartAccountExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDto[]>;
        }));
    }

    protected processGetAllChartAccountExpense(response: HttpResponseBase): Observable<ChartOfAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChartOfAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PurchaseInvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePurchaseInvoice(body: SavePurchaseInvoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoice/SavePurchaseInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePurchaseInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePurchaseInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePurchaseInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    calculateSaletax(body: InvoiceDetail[] | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoice/CalculateSaletax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateSaletax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateSaletax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCalculateSaletax(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PurchaseInvoiceServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePurchaseInvoice(body: SavePurchaseInvoice | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoiceService/SavePurchaseInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePurchaseInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePurchaseInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSavePurchaseInvoice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatepurchaseInvoice(body: Invoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoiceService/UpdatepurchaseInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatepurchaseInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatepurchaseInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatepurchaseInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    savePurchasePayment(tenantId: number | undefined, body: SaveReceivedPayment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoiceService/SavePurchasePayment?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePurchasePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePurchasePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSavePurchasePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoiceDetails(body: SaveReceivedPayment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoiceService/InvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processInvoiceDetails(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvoiceDetails(body: Invoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoiceService/UpdateInvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateInvoiceDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    calculateSaletax(body: InvoiceDetail[] | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseInvoiceService/CalculateSaletax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateSaletax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateSaletax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCalculateSaletax(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PurchaseReceiptServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePurchaseReceipt(body: SavePurchaseReceiptDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseReceiptService/SavePurchaseReceipt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePurchaseReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePurchaseReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePurchaseReceipt(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoiceDetails(body: SavePurchaseReceiptDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseReceiptService/InvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoiceDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvoiceDetails(body: Invoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseReceiptService/UpdateInvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateInvoiceDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountDescription (optional) 
     * @param companyId (optional) 
     * @return Success
     */
    getCOA_Id(accountDescription: string | undefined, companyId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseReceiptService/GetCOA_Id?";
        if (accountDescription === null)
            throw new Error("The parameter 'accountDescription' cannot be null.");
        else if (accountDescription !== undefined)
            url_ += "accountDescription=" + encodeURIComponent("" + accountDescription) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCOA_Id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCOA_Id(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCOA_Id(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReceivedPaymentServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveReceivedPayment(tenantId: number | undefined, body: SaveReceivedPayment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ReceivedPaymentService/SaveReceivedPayment?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveReceivedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveReceivedPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveReceivedPayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoiceDetails(body: SaveReceivedPayment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ReceivedPaymentService/InvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processInvoiceDetails(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    updateRPAmount(invoiceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReceivedPaymentService/UpdateRPAmount?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRPAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRPAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateRPAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvoiceDetails(body: Invoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReceivedPaymentService/UpdateInvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateInvoiceDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveChargeCard(body: ChargeCardDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ReceivedPaymentService/SaveChargeCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveChargeCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveChargeCard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveChargeCard(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param toEmail (optional) 
     * @param body (optional) 
     * @return Success
     */
    emailReceivePayment(toEmail: string | undefined, body: CustomerTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReceivedPaymentService/EmailReceivePayment?";
        if (toEmail === null)
            throw new Error("The parameter 'toEmail' cannot be null.");
        else if (toEmail !== undefined)
            url_ += "toEmail=" + encodeURIComponent("" + toEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmailReceivePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmailReceivePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEmailReceivePayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    myAction(body: CustomerTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReceivedPaymentService/MyAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMyAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RecurringInvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCCInfo(body: CompanyCardDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/SaveCCInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCCInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCCInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCCInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getAllCards(customerId: number | undefined): Observable<CompanyCardDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetAllCards?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyCardDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyCardDto[]>;
        }));
    }

    protected processGetAllCards(response: HttpResponseBase): Observable<CompanyCardDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CompanyCardDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCompanyCardByCustomerIdAndCardId(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/DeleteCompanyCardByCustomerIdAndCardId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompanyCardByCustomerIdAndCardId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompanyCardByCustomerIdAndCardId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCompanyCardByCustomerIdAndCardId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveRecurringData(body: RecurringInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/SaveRecurringData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRecurringData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRecurringData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveRecurringData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRecurringInvoice(body: RecurringInvoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/AddRecurringInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRecurringInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRecurringInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddRecurringInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    recurringInvoiceJob(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/RecurringInvoiceJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecurringInvoiceJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecurringInvoiceJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRecurringInvoiceJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    calculateIssueDueDate(body: Invoice | undefined): Observable<Invoice> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/CalculateIssueDueDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateIssueDueDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateIssueDueDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice>;
        }));
    }

    protected processCalculateIssueDueDate(response: HttpResponseBase): Observable<Invoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getcustomerbyid(id: number | undefined): Observable<Customer> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/Getcustomerbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcustomerbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcustomerbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processGetcustomerbyid(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autoChargeInvoice(body: Invoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/AutoChargeInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoChargeInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoChargeInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAutoChargeInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveRecurringPaymentOfRecurringInvoice(body: Invoice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/SaveRecurringPaymentOfRecurringInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRecurringPaymentOfRecurringInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRecurringPaymentOfRecurringInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveRecurringPaymentOfRecurringInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getMonthlyFrequency(): Observable<Int64StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetMonthlyFrequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonthlyFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonthlyFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64StringKeyValuePair[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64StringKeyValuePair[]>;
        }));
    }

    protected processGetMonthlyFrequency(response: HttpResponseBase): Observable<Int64StringKeyValuePair[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Int64StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getWeeklyFrequency(): Observable<Int64StringKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetWeeklyFrequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeeklyFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeeklyFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64StringKeyValuePair[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64StringKeyValuePair[]>;
        }));
    }

    protected processGetWeeklyFrequency(response: HttpResponseBase): Observable<Int64StringKeyValuePair[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Int64StringKeyValuePair.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param _Code (optional) 
     * @return Success
     */
    getVoucherDescription(_Code: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetVoucherDescription?";
        if (_Code === null)
            throw new Error("The parameter '_Code' cannot be null.");
        else if (_Code !== undefined)
            url_ += "_Code=" + encodeURIComponent("" + _Code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVoucherDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVoucherDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetVoucherDescription(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param voucherTypeCode (optional) 
     * @return Success
     */
    getVoucherNumber(voucherTypeCode: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetVoucherNumber?";
        if (voucherTypeCode === null)
            throw new Error("The parameter 'voucherTypeCode' cannot be null.");
        else if (voucherTypeCode !== undefined)
            url_ += "voucherTypeCode=" + encodeURIComponent("" + voucherTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVoucherNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVoucherNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetVoucherNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoice(id: number | undefined): Observable<Invoice> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetInvoice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice>;
        }));
    }

    protected processGetInvoice(response: HttpResponseBase): Observable<Invoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceType (optional) 
     * @return Success
     */
    getInvoiceNumber(invoiceType: InvoiceType | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetInvoiceNumber?";
        if (invoiceType === null)
            throw new Error("The parameter 'invoiceType' cannot be null.");
        else if (invoiceType !== undefined)
            url_ += "invoiceType=" + encodeURIComponent("" + invoiceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetInvoiceNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    getPurchaseInvoiceBalance(invoiceId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetPurchaseInvoiceBalance?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseInvoiceBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseInvoiceBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetPurchaseInvoiceBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerBalance(customerId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetCustomerBalance?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCustomerBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceBalance(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetInvoiceBalance?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetInvoiceBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerTransaction(customerId: number | undefined): Observable<CustomerTransactionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetCustomerTransaction?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTransactionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTransactionDto[]>;
        }));
    }

    protected processGetCustomerTransaction(response: HttpResponseBase): Observable<CustomerTransactionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerTransactionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReceivedPaymentList(id: number | undefined): Observable<ReceviedPayment[]> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/GetReceivedPaymentList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceivedPaymentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceivedPaymentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceviedPayment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceviedPayment[]>;
        }));
    }

    protected processGetReceivedPaymentList(response: HttpResponseBase): Observable<ReceviedPayment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReceviedPayment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productServicesLookUp(body: StringCommonLookupInput | undefined): Observable<Int32StringKeyValuePairListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/ProductServicesLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductServicesLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductServicesLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32StringKeyValuePairListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32StringKeyValuePairListResultDto>;
        }));
    }

    protected processProductServicesLookUp(response: HttpResponseBase): Observable<Int32StringKeyValuePairListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32StringKeyValuePairListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customersLookUp(body: StringCommonLookupInput | undefined): Observable<CustomerLookupOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RecurringInvoice/CustomersLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomersLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomersLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLookupOutputListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLookupOutputListResultDto>;
        }));
    }

    protected processCustomersLookUp(response: HttpResponseBase): Observable<CustomerLookupOutputListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLookupOutputListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNew(body: RoleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateNew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNew(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateNew(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNew(body: RoleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/UpdateNew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNew(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNew(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissionsWithLevel(): Observable<FlatPermissionWithLevelDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissionsWithLevel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionsWithLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionsWithLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlatPermissionWithLevelDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlatPermissionWithLevelDtoListResultDto>;
        }));
    }

    protected processGetAllPermissionsWithLevel(response: HttpResponseBase): Observable<FlatPermissionWithLevelDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FlatPermissionWithLevelDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SalesPersonTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSalesPersonTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalesPersonType/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalesPersonType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CreateOrEditSalesPersonTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SalesPersonType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditSalesPersonTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditSalesPersonTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CreateOrEditSalesPersonTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditSalesPersonTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<SalesPersonTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SalesPersonType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesPersonTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesPersonTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SalesPersonTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SalesPersonTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SalesReceiptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/SalesReceipt/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvoice(body: CreateSalesReceiptDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalesReceipt/SaveInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productServicesLookUp(body: StringCommonLookupInput | undefined): Observable<Int32StringKeyValuePairListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SalesReceipt/ProductServicesLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductServicesLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductServicesLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32StringKeyValuePairListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32StringKeyValuePairListResultDto>;
        }));
    }

    protected processProductServicesLookUp(response: HttpResponseBase): Observable<Int32StringKeyValuePairListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32StringKeyValuePairListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customersLookUp(body: StringCommonLookupInput | undefined): Observable<CustomerLookupOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SalesReceipt/CustomersLookUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomersLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomersLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLookupOutputListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLookupOutputListResultDto>;
        }));
    }

    protected processCustomersLookUp(response: HttpResponseBase): Observable<CustomerLookupOutputListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLookupOutputListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SalesTaxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesTaxGet(body: SalesTaxDto | undefined): Observable<SalesTaxDto> {
        let url_ = this.baseUrl + "/api/services/app/SalesTax/SalesTaxGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesTaxGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesTaxGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesTaxDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesTaxDto>;
        }));
    }

    protected processSalesTaxGet(response: HttpResponseBase): Observable<SalesTaxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesTaxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSalesTax(body: SalesTaxDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalesTax/SaveSalesTax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSalesTax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSalesTax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSalesTax(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SourceReferalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param _StartDate (optional) 
     * @param _EndDate (optional) 
     * @param soureceReferalId (optional) 
     * @return Success
     */
    getList(_StartDate: moment.Moment | undefined, _EndDate: moment.Moment | undefined, soureceReferalId: number | undefined): Observable<SourceReferalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SourceReferal/GetList?";
        if (_StartDate === null)
            throw new Error("The parameter '_StartDate' cannot be null.");
        else if (_StartDate !== undefined)
            url_ += "_StartDate=" + encodeURIComponent(_StartDate ? "" + _StartDate.toISOString() : "") + "&";
        if (_EndDate === null)
            throw new Error("The parameter '_EndDate' cannot be null.");
        else if (_EndDate !== undefined)
            url_ += "_EndDate=" + encodeURIComponent(_EndDate ? "" + _EndDate.toISOString() : "") + "&";
        if (soureceReferalId === null)
            throw new Error("The parameter 'soureceReferalId' cannot be null.");
        else if (soureceReferalId !== undefined)
            url_ += "SoureceReferalId=" + encodeURIComponent("" + soureceReferalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SourceReferalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SourceReferalDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SourceReferalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SourceReferalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSourceReferralNames(): Observable<SourceReferalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SourceReferal/GetSourceReferralNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSourceReferralNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSourceReferralNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SourceReferalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SourceReferalDto[]>;
        }));
    }

    protected processGetSourceReferralNames(response: HttpResponseBase): Observable<SourceReferalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SourceReferalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SourceReferralTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSourceReferralTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SourceReferralType/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SourceReferralType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SourceReferralTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SourceReferralType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SourceReferralTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SourceReferralTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SourceReferralTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SourceReferralTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<SourceReferralTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SourceReferralType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SourceReferralTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SourceReferralTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SourceReferralTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SourceReferralTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SpouseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSpouseDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SpouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpouseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SpouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<SpouseDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpouseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpouseDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SpouseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SpouseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TaxServiceMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaxFillingStatus(): Observable<TaxFillingStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TaxServiceMaster/GetTaxFillingStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxFillingStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxFillingStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxFillingStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxFillingStatusDto[]>;
        }));
    }

    protected processGetTaxFillingStatus(response: HttpResponseBase): Observable<TaxFillingStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TaxFillingStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTenure(): Observable<TenureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TaxServiceMaster/GetTenure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenureDto[]>;
        }));
    }

    protected processGetTenure(response: HttpResponseBase): Observable<TenureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TenureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getFormList(): Observable<FormEnum[]> {
        let url_ = this.baseUrl + "/api/services/app/TaxServiceMaster/GetFormList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormEnum[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormEnum[]>;
        }));
    }

    protected processGetFormList(response: HttpResponseBase): Observable<FormEnum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getIncomeDescriptions(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TaxServiceMaster/GetIncomeDescriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeDescriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeDescriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetIncomeDescriptions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantRegistationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInputDto | undefined): Observable<RegisterTenantoutputDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistation/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterTenantoutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterTenantoutputDto>;
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantoutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantoutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllTenureForms(): Observable<TenureForm[]> {
        let url_ = this.baseUrl + "/api/services/app/Tenure/GetAllTenureForms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenureForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenureForms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenureForm[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenureForm[]>;
        }));
    }

    protected processGetAllTenureForms(response: HttpResponseBase): Observable<TenureForm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TenureForm.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TrialBalanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getTrialBalance(body: TrialBalanceInputDto | undefined): Observable<TrialBalanceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TrialBalance/GetTrialBalance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrialBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrialBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrialBalanceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrialBalanceDto[]>;
        }));
    }

    protected processGetTrialBalance(response: HttpResponseBase): Observable<TrialBalanceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TrialBalanceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<CreateOrEditUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditUserDto>;
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<CreateOrEditUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrEditUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: CreateOrEditUserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getRoles(filter: string | undefined): Observable<Int64StringKeyValuePairListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64StringKeyValuePairListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64StringKeyValuePairListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<Int64StringKeyValuePairListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64StringKeyValuePairListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditGeneralUserGroupInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<GeneralUsersGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralUsersGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralUsersGroupDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GeneralUsersGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralUsersGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<GeneralUsersGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralUsersGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralUsersGroupDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GeneralUsersGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GeneralUsersGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VenderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditVenderDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Vender/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vender/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendor(id: number | undefined): Observable<CreateOrEditVenderDto> {
        let url_ = this.baseUrl + "/api/services/app/Vender/GetVendor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditVenderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditVenderDto>;
        }));
    }

    protected processGetVendor(response: HttpResponseBase): Observable<CreateOrEditVenderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditVenderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<VendorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Vender/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VendorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param subject (optional) 
     * @param emailBody (optional) 
     * @param fileName (optional) 
     * @param vendorId (optional) 
     * @return Success
     */
    sendEmailToVendor(subject: string | undefined, emailBody: string | undefined, fileName: string | undefined, vendorId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vender/SendEmailToVendor?";
        if (subject === null)
            throw new Error("The parameter 'subject' cannot be null.");
        else if (subject !== undefined)
            url_ += "Subject=" + encodeURIComponent("" + subject) + "&";
        if (emailBody === null)
            throw new Error("The parameter 'emailBody' cannot be null.");
        else if (emailBody !== undefined)
            url_ += "EmailBody=" + encodeURIComponent("" + emailBody) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailToVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailToVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailToVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VenderTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditVenderTypeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VenderType/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VenderType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<VenderTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/VenderType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VenderTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VenderTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VenderTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VenderTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<VenderTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/VenderType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VenderTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VenderTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VenderTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VenderTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VendorAttachmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    upload(): Observable<void> {
        let url_ = this.baseUrl + "/api/VendorAttachment/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    vendorAttachmentsGet(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/VendorAttachment/VendorAttachmentsGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorAttachmentsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorAttachmentsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVendorAttachmentsGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getFile(fileName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/VendorAttachment/GetFile/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    deleteFile(fileName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/VendorAttachment/DeleteFile/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VendorContactInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditVendorContactInfoDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<VendorContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorContactInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VendorContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<VendorContactInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorContactInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorContactInfoDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VendorContactInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorContactInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAddress(body: CreateOrEditVendorAddressDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/CreateOrEditAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEditAddress(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAddress(body: CreateOrEditVendorAddressDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/CreateAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateAddress(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAddress(body: CreateOrEditVendorAddressDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/UpdateAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateAddress(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAddress(id: number | undefined): Observable<CreateOrEditVendorAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/GetAddress?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditVendorAddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditVendorAddressDto>;
        }));
    }

    protected processGetAddress(response: HttpResponseBase): Observable<CreateOrEditVendorAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditVendorAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAddress(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorContactInfo/DeleteAddress?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export enum AccountNature {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class AccountType implements IAccountType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: number;
    description: string | undefined;
    accountNature: AccountNature;

    constructor(data?: IAccountType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.accountNature = _data["accountNature"];
        }
    }

    static fromJS(data: any): AccountType {
        data = typeof data === 'object' ? data : {};
        let result = new AccountType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["accountNature"] = this.accountNature;
        return data;
    }

    clone(): AccountType {
        const json = this.toJSON();
        let result = new AccountType();
        result.init(json);
        return result;
    }
}

export interface IAccountType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: number;
    description: string | undefined;
    accountNature: AccountNature;
}

export class AccountTypeDto implements IAccountTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    accountNature: AccountNature;

    constructor(data?: IAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.accountNature = _data["accountNature"];
        }
    }

    static fromJS(data: any): AccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["accountNature"] = this.accountNature;
        return data;
    }

    clone(): AccountTypeDto {
        const json = this.toJSON();
        let result = new AccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAccountTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    accountNature: AccountNature;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data;
    }

    clone(): ActivateEmailInput {
        const json = this.toJSON();
        let result = new ActivateEmailInput();
        result.init(json);
        return result;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class AddGeneralLedgarInputDto implements IAddGeneralLedgarInputDto {
    invoiceId: number;
    processType: string | undefined;

    constructor(data?: IAddGeneralLedgarInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.processType = _data["processType"];
        }
    }

    static fromJS(data: any): AddGeneralLedgarInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddGeneralLedgarInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["processType"] = this.processType;
        return data;
    }

    clone(): AddGeneralLedgarInputDto {
        const json = this.toJSON();
        let result = new AddGeneralLedgarInputDto();
        result.init(json);
        return result;
    }
}

export interface IAddGeneralLedgarInputDto {
    invoiceId: number;
    processType: string | undefined;
}

export class Address implements IAddress {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;
    customerId: number | undefined;
    customer: Customer;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.completeAddress = _data["completeAddress"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.fax = _data["fax"];
            this.type = _data["type"];
            this.isPrimary = _data["isPrimary"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["completeAddress"] = this.completeAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["fax"] = this.fax;
        data["type"] = this.type;
        data["isPrimary"] = this.isPrimary;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export interface IAddress {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;
    customerId: number | undefined;
    customer: Customer;
}

export class AddressDto implements IAddressDto {
    id: number;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.completeAddress = _data["completeAddress"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.fax = _data["fax"];
            this.type = _data["type"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["completeAddress"] = this.completeAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["fax"] = this.fax;
        data["type"] = this.type;
        data["isPrimary"] = this.isPrimary;
        return data;
    }

    clone(): AddressDto {
        const json = this.toJSON();
        let result = new AddressDto();
        result.init(json);
        return result;
    }
}

export interface IAddressDto {
    id: number;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;
}

export enum AddressType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class AuditLogsDto implements IAuditLogsDto {
    id: number;
    appLog: string | undefined;
    logDate: moment.Moment | undefined;
    operation: string | undefined;
    employeeName: string | undefined;
    customerName: string | undefined;
    company: string | undefined;
    customerNo: number | undefined;
    companyName: string | undefined;
    userName: string | undefined;
    userId: number;

    constructor(data?: IAuditLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appLog = _data["appLog"];
            this.logDate = _data["logDate"] ? moment(_data["logDate"].toString()) : <any>undefined;
            this.operation = _data["operation"];
            this.employeeName = _data["employeeName"];
            this.customerName = _data["customerName"];
            this.company = _data["company"];
            this.customerNo = _data["customerNo"];
            this.companyName = _data["companyName"];
            this.userName = _data["userName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuditLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appLog"] = this.appLog;
        data["logDate"] = this.logDate ? this.logDate.toISOString() : <any>undefined;
        data["operation"] = this.operation;
        data["employeeName"] = this.employeeName;
        data["customerName"] = this.customerName;
        data["company"] = this.company;
        data["customerNo"] = this.customerNo;
        data["companyName"] = this.companyName;
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuditLogsDto {
        const json = this.toJSON();
        let result = new AuditLogsDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogsDto {
    id: number;
    appLog: string | undefined;
    logDate: moment.Moment | undefined;
    operation: string | undefined;
    employeeName: string | undefined;
    customerName: string | undefined;
    company: string | undefined;
    customerNo: number | undefined;
    companyName: string | undefined;
    userName: string | undefined;
    userId: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class BalanceSheetDto implements IBalanceSheetDto {
    id: number;
    accountTypeName: string | undefined;
    accountDescription: string | undefined;
    accountBalance: number | undefined;
    accountTypeID: number | undefined;

    constructor(data?: IBalanceSheetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountTypeName = _data["accountTypeName"];
            this.accountDescription = _data["accountDescription"];
            this.accountBalance = _data["accountBalance"];
            this.accountTypeID = _data["accountTypeID"];
        }
    }

    static fromJS(data: any): BalanceSheetDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceSheetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountTypeName"] = this.accountTypeName;
        data["accountDescription"] = this.accountDescription;
        data["accountBalance"] = this.accountBalance;
        data["accountTypeID"] = this.accountTypeID;
        return data;
    }

    clone(): BalanceSheetDto {
        const json = this.toJSON();
        let result = new BalanceSheetDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceSheetDto {
    id: number;
    accountTypeName: string | undefined;
    accountDescription: string | undefined;
    accountBalance: number | undefined;
    accountTypeID: number | undefined;
}

export class Bank implements IBank {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    titleofAccount: string | undefined;
    bankName: string | undefined;
    accountNumber: number;
    routing: number;
    openBalance: number;
    startingCheque: number;
    swiftCode: number;
    isActive: boolean;
    bankAddressId: number | undefined;
    coaMainHeadId: number;
    bankAddress: BankAddress;

    constructor(data?: IBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.titleofAccount = _data["titleofAccount"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.routing = _data["routing"];
            this.openBalance = _data["openBalance"];
            this.startingCheque = _data["startingCheque"];
            this.swiftCode = _data["swiftCode"];
            this.isActive = _data["isActive"];
            this.bankAddressId = _data["bankAddressId"];
            this.coaMainHeadId = _data["coaMainHeadId"];
            this.bankAddress = _data["bankAddress"] ? BankAddress.fromJS(_data["bankAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Bank {
        data = typeof data === 'object' ? data : {};
        let result = new Bank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["titleofAccount"] = this.titleofAccount;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["routing"] = this.routing;
        data["openBalance"] = this.openBalance;
        data["startingCheque"] = this.startingCheque;
        data["swiftCode"] = this.swiftCode;
        data["isActive"] = this.isActive;
        data["bankAddressId"] = this.bankAddressId;
        data["coaMainHeadId"] = this.coaMainHeadId;
        data["bankAddress"] = this.bankAddress ? this.bankAddress.toJSON() : <any>undefined;
        return data;
    }

    clone(): Bank {
        const json = this.toJSON();
        let result = new Bank();
        result.init(json);
        return result;
    }
}

export interface IBank {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    titleofAccount: string | undefined;
    bankName: string | undefined;
    accountNumber: number;
    routing: number;
    openBalance: number;
    startingCheque: number;
    swiftCode: number;
    isActive: boolean;
    bankAddressId: number | undefined;
    coaMainHeadId: number;
    bankAddress: BankAddress;
}

export class BankAddress implements IBankAddress {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;

    constructor(data?: IBankAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
        }
    }

    static fromJS(data: any): BankAddress {
        data = typeof data === 'object' ? data : {};
        let result = new BankAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        return data;
    }

    clone(): BankAddress {
        const json = this.toJSON();
        let result = new BankAddress();
        result.init(json);
        return result;
    }
}

export interface IBankAddress {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
}

export class BankDto implements IBankDto {
    id: number;
    titleofAccount: string | undefined;
    bankName: string | undefined;
    accountNumber: number;
    routing: number;
    openBalance: number;
    startingCheque: number;
    swiftCode: number;
    isActive: boolean;
    bankAddressId: number | undefined;
    coaMainHeadId: number;
    address: CreateOrEditBankAddressDto;

    constructor(data?: IBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.titleofAccount = _data["titleofAccount"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.routing = _data["routing"];
            this.openBalance = _data["openBalance"];
            this.startingCheque = _data["startingCheque"];
            this.swiftCode = _data["swiftCode"];
            this.isActive = _data["isActive"];
            this.bankAddressId = _data["bankAddressId"];
            this.coaMainHeadId = _data["coaMainHeadId"];
            this.address = _data["address"] ? CreateOrEditBankAddressDto.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BankDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleofAccount"] = this.titleofAccount;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["routing"] = this.routing;
        data["openBalance"] = this.openBalance;
        data["startingCheque"] = this.startingCheque;
        data["swiftCode"] = this.swiftCode;
        data["isActive"] = this.isActive;
        data["bankAddressId"] = this.bankAddressId;
        data["coaMainHeadId"] = this.coaMainHeadId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): BankDto {
        const json = this.toJSON();
        let result = new BankDto();
        result.init(json);
        return result;
    }
}

export interface IBankDto {
    id: number;
    titleofAccount: string | undefined;
    bankName: string | undefined;
    accountNumber: number;
    routing: number;
    openBalance: number;
    startingCheque: number;
    swiftCode: number;
    isActive: boolean;
    bankAddressId: number | undefined;
    coaMainHeadId: number;
    address: CreateOrEditBankAddressDto;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChargeCardDto implements IChargeCardDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    duration: number | undefined;
    amount: number | undefined;
    cardType: string | undefined;
    cardHolderName: string | undefined;
    cardNumber: string | undefined;
    expDate: string | undefined;
    ccvNo: string | undefined;
    customerEmail: string | undefined;
    tenantId: number | undefined;

    constructor(data?: IChargeCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.amount = _data["amount"];
            this.cardType = _data["cardType"];
            this.cardHolderName = _data["cardHolderName"];
            this.cardNumber = _data["cardNumber"];
            this.expDate = _data["expDate"];
            this.ccvNo = _data["ccvNo"];
            this.customerEmail = _data["customerEmail"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ChargeCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["amount"] = this.amount;
        data["cardType"] = this.cardType;
        data["cardHolderName"] = this.cardHolderName;
        data["cardNumber"] = this.cardNumber;
        data["expDate"] = this.expDate;
        data["ccvNo"] = this.ccvNo;
        data["customerEmail"] = this.customerEmail;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): ChargeCardDto {
        const json = this.toJSON();
        let result = new ChargeCardDto();
        result.init(json);
        return result;
    }
}

export interface IChargeCardDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    duration: number | undefined;
    amount: number | undefined;
    cardType: string | undefined;
    cardHolderName: string | undefined;
    cardNumber: string | undefined;
    expDate: string | undefined;
    ccvNo: string | undefined;
    customerEmail: string | undefined;
    tenantId: number | undefined;
}

export class ChartOfAccount implements IChartOfAccount {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    chartOfAccountId: number;
    accountNature: AccountNature;
    accountDescription: string | undefined;
    accountCode: number;
    accountStatus: boolean;
    detail: string | undefined;
    allowDepreciation: boolean;
    creditLimitAmount: number;
    isCashFlow: boolean;
    isActive: boolean;
    isDefaultAccount: boolean;
    companyId: number;
    company: Company;
    accountTypeId: number | undefined;
    accountType: AccountType;
    mainHeadId: number | undefined;
    mainHead: MainHead;
    balance: number;

    constructor(data?: IChartOfAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.chartOfAccountId = _data["chartOfAccountId"];
            this.accountNature = _data["accountNature"];
            this.accountDescription = _data["accountDescription"];
            this.accountCode = _data["accountCode"];
            this.accountStatus = _data["accountStatus"];
            this.detail = _data["detail"];
            this.allowDepreciation = _data["allowDepreciation"];
            this.creditLimitAmount = _data["creditLimitAmount"];
            this.isCashFlow = _data["isCashFlow"];
            this.isActive = _data["isActive"];
            this.isDefaultAccount = _data["isDefaultAccount"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.accountTypeId = _data["accountTypeId"];
            this.accountType = _data["accountType"] ? AccountType.fromJS(_data["accountType"]) : <any>undefined;
            this.mainHeadId = _data["mainHeadId"];
            this.mainHead = _data["mainHead"] ? MainHead.fromJS(_data["mainHead"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): ChartOfAccount {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["chartOfAccountId"] = this.chartOfAccountId;
        data["accountNature"] = this.accountNature;
        data["accountDescription"] = this.accountDescription;
        data["accountCode"] = this.accountCode;
        data["accountStatus"] = this.accountStatus;
        data["detail"] = this.detail;
        data["allowDepreciation"] = this.allowDepreciation;
        data["creditLimitAmount"] = this.creditLimitAmount;
        data["isCashFlow"] = this.isCashFlow;
        data["isActive"] = this.isActive;
        data["isDefaultAccount"] = this.isDefaultAccount;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["accountTypeId"] = this.accountTypeId;
        data["accountType"] = this.accountType ? this.accountType.toJSON() : <any>undefined;
        data["mainHeadId"] = this.mainHeadId;
        data["mainHead"] = this.mainHead ? this.mainHead.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): ChartOfAccount {
        const json = this.toJSON();
        let result = new ChartOfAccount();
        result.init(json);
        return result;
    }
}

export interface IChartOfAccount {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    chartOfAccountId: number;
    accountNature: AccountNature;
    accountDescription: string | undefined;
    accountCode: number;
    accountStatus: boolean;
    detail: string | undefined;
    allowDepreciation: boolean;
    creditLimitAmount: number;
    isCashFlow: boolean;
    isActive: boolean;
    isDefaultAccount: boolean;
    companyId: number;
    company: Company;
    accountTypeId: number | undefined;
    accountType: AccountType;
    mainHeadId: number | undefined;
    mainHead: MainHead;
    balance: number;
}

export class ChartOfAccountDto implements IChartOfAccountDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    chartOfAccountId: number;
    accountNature: string | undefined;
    accountNatureId: number | undefined;
    accountTypeCode: number | undefined;
    accountTypeId: number | undefined;
    accountType: string | undefined;
    mainHeadId: number | undefined;
    balance: number | undefined;
    mainHead: string | undefined;
    mainHeadCode: number | undefined;
    accountDescription: string | undefined;
    accountCode: number | undefined;
    isActive: boolean | undefined;

    constructor(data?: IChartOfAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.chartOfAccountId = _data["chartOfAccountId"];
            this.accountNature = _data["accountNature"];
            this.accountNatureId = _data["accountNatureId"];
            this.accountTypeCode = _data["accountTypeCode"];
            this.accountTypeId = _data["accountTypeId"];
            this.accountType = _data["accountType"];
            this.mainHeadId = _data["mainHeadId"];
            this.balance = _data["balance"];
            this.mainHead = _data["mainHead"];
            this.mainHeadCode = _data["mainHeadCode"];
            this.accountDescription = _data["accountDescription"];
            this.accountCode = _data["accountCode"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ChartOfAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["chartOfAccountId"] = this.chartOfAccountId;
        data["accountNature"] = this.accountNature;
        data["accountNatureId"] = this.accountNatureId;
        data["accountTypeCode"] = this.accountTypeCode;
        data["accountTypeId"] = this.accountTypeId;
        data["accountType"] = this.accountType;
        data["mainHeadId"] = this.mainHeadId;
        data["balance"] = this.balance;
        data["mainHead"] = this.mainHead;
        data["mainHeadCode"] = this.mainHeadCode;
        data["accountDescription"] = this.accountDescription;
        data["accountCode"] = this.accountCode;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ChartOfAccountDto {
        const json = this.toJSON();
        let result = new ChartOfAccountDto();
        result.init(json);
        return result;
    }
}

export interface IChartOfAccountDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    chartOfAccountId: number;
    accountNature: string | undefined;
    accountNatureId: number | undefined;
    accountTypeCode: number | undefined;
    accountTypeId: number | undefined;
    accountType: string | undefined;
    mainHeadId: number | undefined;
    balance: number | undefined;
    mainHead: string | undefined;
    mainHeadCode: number | undefined;
    accountDescription: string | undefined;
    accountCode: number | undefined;
    isActive: boolean | undefined;
}

export class ChartOfAccountListViewDto implements IChartOfAccountListViewDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    accountNature: string | undefined;
    accountNatureId: number | undefined;
    accountTypeId: number | undefined;
    accountType: string | undefined;
    mainHeadId: number | undefined;
    mainHead: string | undefined;
    accountDescription: string | undefined;
    isActive: boolean | undefined;
    relevantAccounts: ChartOfAccountListViewDto[] | undefined;

    constructor(data?: IChartOfAccountListViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.accountNature = _data["accountNature"];
            this.accountNatureId = _data["accountNatureId"];
            this.accountTypeId = _data["accountTypeId"];
            this.accountType = _data["accountType"];
            this.mainHeadId = _data["mainHeadId"];
            this.mainHead = _data["mainHead"];
            this.accountDescription = _data["accountDescription"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["relevantAccounts"])) {
                this.relevantAccounts = [] as any;
                for (let item of _data["relevantAccounts"])
                    this.relevantAccounts.push(ChartOfAccountListViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartOfAccountListViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccountListViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["accountNature"] = this.accountNature;
        data["accountNatureId"] = this.accountNatureId;
        data["accountTypeId"] = this.accountTypeId;
        data["accountType"] = this.accountType;
        data["mainHeadId"] = this.mainHeadId;
        data["mainHead"] = this.mainHead;
        data["accountDescription"] = this.accountDescription;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.relevantAccounts)) {
            data["relevantAccounts"] = [];
            for (let item of this.relevantAccounts)
                data["relevantAccounts"].push(item.toJSON());
        }
        return data;
    }

    clone(): ChartOfAccountListViewDto {
        const json = this.toJSON();
        let result = new ChartOfAccountListViewDto();
        result.init(json);
        return result;
    }
}

export interface IChartOfAccountListViewDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    accountNature: string | undefined;
    accountNatureId: number | undefined;
    accountTypeId: number | undefined;
    accountType: string | undefined;
    mainHeadId: number | undefined;
    mainHead: string | undefined;
    accountDescription: string | undefined;
    isActive: boolean | undefined;
    relevantAccounts: ChartOfAccountListViewDto[] | undefined;
}

export class ChartOfAccountListViewDtoPagedResultDto implements IChartOfAccountListViewDtoPagedResultDto {
    items: ChartOfAccountListViewDto[] | undefined;
    totalCount: number;

    constructor(data?: IChartOfAccountListViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ChartOfAccountListViewDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ChartOfAccountListViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccountListViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ChartOfAccountListViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ChartOfAccountListViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IChartOfAccountListViewDtoPagedResultDto {
    items: ChartOfAccountListViewDto[] | undefined;
    totalCount: number;
}

export class Check implements ICheck {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    checkCode: string | undefined;
    payeeId: string | undefined;
    totalAmount: number;
    bankId: number;
    notes: string | undefined;
    companyId: number;
    isDeleted: boolean;
    checkProductDetails: CheckProductDetail[] | undefined;
    checkAccountDetails: CheckAccountDetail[] | undefined;

    constructor(data?: ICheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.checkCode = _data["checkCode"];
            this.payeeId = _data["payeeId"];
            this.totalAmount = _data["totalAmount"];
            this.bankId = _data["bankId"];
            this.notes = _data["notes"];
            this.companyId = _data["companyId"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["checkProductDetails"])) {
                this.checkProductDetails = [] as any;
                for (let item of _data["checkProductDetails"])
                    this.checkProductDetails.push(CheckProductDetail.fromJS(item));
            }
            if (Array.isArray(_data["checkAccountDetails"])) {
                this.checkAccountDetails = [] as any;
                for (let item of _data["checkAccountDetails"])
                    this.checkAccountDetails.push(CheckAccountDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Check {
        data = typeof data === 'object' ? data : {};
        let result = new Check();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["checkCode"] = this.checkCode;
        data["payeeId"] = this.payeeId;
        data["totalAmount"] = this.totalAmount;
        data["bankId"] = this.bankId;
        data["notes"] = this.notes;
        data["companyId"] = this.companyId;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.checkProductDetails)) {
            data["checkProductDetails"] = [];
            for (let item of this.checkProductDetails)
                data["checkProductDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.checkAccountDetails)) {
            data["checkAccountDetails"] = [];
            for (let item of this.checkAccountDetails)
                data["checkAccountDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): Check {
        const json = this.toJSON();
        let result = new Check();
        result.init(json);
        return result;
    }
}

export interface ICheck {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    checkCode: string | undefined;
    payeeId: string | undefined;
    totalAmount: number;
    bankId: number;
    notes: string | undefined;
    companyId: number;
    isDeleted: boolean;
    checkProductDetails: CheckProductDetail[] | undefined;
    checkAccountDetails: CheckAccountDetail[] | undefined;
}

export class CheckAccountDetail implements ICheckAccountDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    accountId: number;
    description: string | undefined;
    amount: number;
    customerId: number;
    checkId: number;

    constructor(data?: ICheckAccountDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.customerId = _data["customerId"];
            this.checkId = _data["checkId"];
        }
    }

    static fromJS(data: any): CheckAccountDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CheckAccountDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["customerId"] = this.customerId;
        data["checkId"] = this.checkId;
        return data;
    }

    clone(): CheckAccountDetail {
        const json = this.toJSON();
        let result = new CheckAccountDetail();
        result.init(json);
        return result;
    }
}

export interface ICheckAccountDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    accountId: number;
    description: string | undefined;
    amount: number;
    customerId: number;
    checkId: number;
}

export class CheckDto implements ICheckDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    checkCode: string | undefined;
    payeeId: string | undefined;
    payee: Customer;
    totalAmount: number;
    bankId: number;
    bank: Bank;
    notes: string | undefined;
    companyId: number;
    checkProductDetails: CheckProductDetail[] | undefined;
    checkAccountDetails: CheckAccountDetail[] | undefined;

    constructor(data?: ICheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.checkCode = _data["checkCode"];
            this.payeeId = _data["payeeId"];
            this.payee = _data["payee"] ? Customer.fromJS(_data["payee"]) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.bankId = _data["bankId"];
            this.bank = _data["bank"] ? Bank.fromJS(_data["bank"]) : <any>undefined;
            this.notes = _data["notes"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["checkProductDetails"])) {
                this.checkProductDetails = [] as any;
                for (let item of _data["checkProductDetails"])
                    this.checkProductDetails.push(CheckProductDetail.fromJS(item));
            }
            if (Array.isArray(_data["checkAccountDetails"])) {
                this.checkAccountDetails = [] as any;
                for (let item of _data["checkAccountDetails"])
                    this.checkAccountDetails.push(CheckAccountDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["checkCode"] = this.checkCode;
        data["payeeId"] = this.payeeId;
        data["payee"] = this.payee ? this.payee.toJSON() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["bankId"] = this.bankId;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.checkProductDetails)) {
            data["checkProductDetails"] = [];
            for (let item of this.checkProductDetails)
                data["checkProductDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.checkAccountDetails)) {
            data["checkAccountDetails"] = [];
            for (let item of this.checkAccountDetails)
                data["checkAccountDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): CheckDto {
        const json = this.toJSON();
        let result = new CheckDto();
        result.init(json);
        return result;
    }
}

export interface ICheckDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    checkCode: string | undefined;
    payeeId: string | undefined;
    payee: Customer;
    totalAmount: number;
    bankId: number;
    bank: Bank;
    notes: string | undefined;
    companyId: number;
    checkProductDetails: CheckProductDetail[] | undefined;
    checkAccountDetails: CheckAccountDetail[] | undefined;
}

export class CheckProductDetail implements ICheckProductDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    productId: number;
    description: string | undefined;
    quantity: number;
    rate: number;
    saleTax: number;
    amount: number;
    customerId: number;
    checkId: number;

    constructor(data?: ICheckProductDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.saleTax = _data["saleTax"];
            this.amount = _data["amount"];
            this.customerId = _data["customerId"];
            this.checkId = _data["checkId"];
        }
    }

    static fromJS(data: any): CheckProductDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CheckProductDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["saleTax"] = this.saleTax;
        data["amount"] = this.amount;
        data["customerId"] = this.customerId;
        data["checkId"] = this.checkId;
        return data;
    }

    clone(): CheckProductDetail {
        const json = this.toJSON();
        let result = new CheckProductDetail();
        result.init(json);
        return result;
    }
}

export interface ICheckProductDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    productId: number;
    description: string | undefined;
    quantity: number;
    rate: number;
    saleTax: number;
    amount: number;
    customerId: number;
    checkId: number;
}

export class CheckSetupDto implements ICheckSetupDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    checkStyle: string | undefined;
    companyId: number;
    companyName: string | undefined;
    bankId: number;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    firstFooter: number;
    secondFooter: number;
    thirdFooter: number;

    constructor(data?: ICheckSetupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.checkStyle = _data["checkStyle"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.bankId = _data["bankId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.firstFooter = _data["firstFooter"];
            this.secondFooter = _data["secondFooter"];
            this.thirdFooter = _data["thirdFooter"];
        }
    }

    static fromJS(data: any): CheckSetupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckSetupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["checkStyle"] = this.checkStyle;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["bankId"] = this.bankId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["firstFooter"] = this.firstFooter;
        data["secondFooter"] = this.secondFooter;
        data["thirdFooter"] = this.thirdFooter;
        return data;
    }

    clone(): CheckSetupDto {
        const json = this.toJSON();
        let result = new CheckSetupDto();
        result.init(json);
        return result;
    }
}

export interface ICheckSetupDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    checkStyle: string | undefined;
    companyId: number;
    companyName: string | undefined;
    bankId: number;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    firstFooter: number;
    secondFooter: number;
    thirdFooter: number;
}

export class Company implements ICompany {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    companyAddress: string | undefined;
    isActive: boolean;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    zipCode: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    facebook: string | undefined;
    linkedIn: string | undefined;
    twitter: string | undefined;
    youtube: string | undefined;
    googlePlus: string | undefined;
    currencyId: number | undefined;
    currency: Currency;
    logo: string | undefined;
    ak: string | undefined;
    aps: string | undefined;
    tk: string | undefined;
    checkStyle: number;
    unsubscribe: boolean;
    fiscalYearStart: moment.Moment;
    fiscalYearEnd: moment.Moment;
    tenantId: number | undefined;
    emailId: number | undefined;
    email: Email;
    phoneId: number | undefined;
    phone: Phone;
    addressId: number | undefined;
    address: Address;
    packageDetailId: number | undefined;
    packageDetailFk: PackageDetail;
    merchantId: number | undefined;
    merchantFk: Merchant;
    packageTypeId: number | undefined;
    packageType: PackageType;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.companyAddress = _data["companyAddress"];
            this.isActive = _data["isActive"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.facebook = _data["facebook"];
            this.linkedIn = _data["linkedIn"];
            this.twitter = _data["twitter"];
            this.youtube = _data["youtube"];
            this.googlePlus = _data["googlePlus"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.logo = _data["logo"];
            this.ak = _data["ak"];
            this.aps = _data["aps"];
            this.tk = _data["tk"];
            this.checkStyle = _data["checkStyle"];
            this.unsubscribe = _data["unsubscribe"];
            this.fiscalYearStart = _data["fiscalYearStart"] ? moment(_data["fiscalYearStart"].toString()) : <any>undefined;
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? moment(_data["fiscalYearEnd"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.emailId = _data["emailId"];
            this.email = _data["email"] ? Email.fromJS(_data["email"]) : <any>undefined;
            this.phoneId = _data["phoneId"];
            this.phone = _data["phone"] ? Phone.fromJS(_data["phone"]) : <any>undefined;
            this.addressId = _data["addressId"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.packageDetailId = _data["packageDetailId"];
            this.packageDetailFk = _data["packageDetailFk"] ? PackageDetail.fromJS(_data["packageDetailFk"]) : <any>undefined;
            this.merchantId = _data["merchantId"];
            this.merchantFk = _data["merchantFk"] ? Merchant.fromJS(_data["merchantFk"]) : <any>undefined;
            this.packageTypeId = _data["packageTypeId"];
            this.packageType = _data["packageType"] ? PackageType.fromJS(_data["packageType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["companyAddress"] = this.companyAddress;
        data["isActive"] = this.isActive;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["facebook"] = this.facebook;
        data["linkedIn"] = this.linkedIn;
        data["twitter"] = this.twitter;
        data["youtube"] = this.youtube;
        data["googlePlus"] = this.googlePlus;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["logo"] = this.logo;
        data["ak"] = this.ak;
        data["aps"] = this.aps;
        data["tk"] = this.tk;
        data["checkStyle"] = this.checkStyle;
        data["unsubscribe"] = this.unsubscribe;
        data["fiscalYearStart"] = this.fiscalYearStart ? this.fiscalYearStart.toISOString() : <any>undefined;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["emailId"] = this.emailId;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["phoneId"] = this.phoneId;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["packageDetailId"] = this.packageDetailId;
        data["packageDetailFk"] = this.packageDetailFk ? this.packageDetailFk.toJSON() : <any>undefined;
        data["merchantId"] = this.merchantId;
        data["merchantFk"] = this.merchantFk ? this.merchantFk.toJSON() : <any>undefined;
        data["packageTypeId"] = this.packageTypeId;
        data["packageType"] = this.packageType ? this.packageType.toJSON() : <any>undefined;
        return data;
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    companyAddress: string | undefined;
    isActive: boolean;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    zipCode: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    facebook: string | undefined;
    linkedIn: string | undefined;
    twitter: string | undefined;
    youtube: string | undefined;
    googlePlus: string | undefined;
    currencyId: number | undefined;
    currency: Currency;
    logo: string | undefined;
    ak: string | undefined;
    aps: string | undefined;
    tk: string | undefined;
    checkStyle: number;
    unsubscribe: boolean;
    fiscalYearStart: moment.Moment;
    fiscalYearEnd: moment.Moment;
    tenantId: number | undefined;
    emailId: number | undefined;
    email: Email;
    phoneId: number | undefined;
    phone: Phone;
    addressId: number | undefined;
    address: Address;
    packageDetailId: number | undefined;
    packageDetailFk: PackageDetail;
    merchantId: number | undefined;
    merchantFk: Merchant;
    packageTypeId: number | undefined;
    packageType: PackageType;
}

export class CompanyCardDto implements ICompanyCardDto {
    id: number;
    cardID: number;
    card_Type: string | undefined;
    card_Holder_Name: string | undefined;
    card_Number: string | undefined;
    exp_Date: string | undefined;
    ccV_No: string | undefined;
    ref_CustomerId: number;
    addedByID: number;
    addedDate: moment.Moment;
    modifiedBy: number;
    modifiedDate: moment.Moment;
    isCustomer: boolean;

    constructor(data?: ICompanyCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cardID = _data["cardID"];
            this.card_Type = _data["card_Type"];
            this.card_Holder_Name = _data["card_Holder_Name"];
            this.card_Number = _data["card_Number"];
            this.exp_Date = _data["exp_Date"];
            this.ccV_No = _data["ccV_No"];
            this.ref_CustomerId = _data["ref_CustomerId"];
            this.addedByID = _data["addedByID"];
            this.addedDate = _data["addedDate"] ? moment(_data["addedDate"].toString()) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? moment(_data["modifiedDate"].toString()) : <any>undefined;
            this.isCustomer = _data["isCustomer"];
        }
    }

    static fromJS(data: any): CompanyCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cardID"] = this.cardID;
        data["card_Type"] = this.card_Type;
        data["card_Holder_Name"] = this.card_Holder_Name;
        data["card_Number"] = this.card_Number;
        data["exp_Date"] = this.exp_Date;
        data["ccV_No"] = this.ccV_No;
        data["ref_CustomerId"] = this.ref_CustomerId;
        data["addedByID"] = this.addedByID;
        data["addedDate"] = this.addedDate ? this.addedDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["isCustomer"] = this.isCustomer;
        return data;
    }

    clone(): CompanyCardDto {
        const json = this.toJSON();
        let result = new CompanyCardDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyCardDto {
    id: number;
    cardID: number;
    card_Type: string | undefined;
    card_Holder_Name: string | undefined;
    card_Number: string | undefined;
    exp_Date: string | undefined;
    ccV_No: string | undefined;
    ref_CustomerId: number;
    addedByID: number;
    addedDate: moment.Moment;
    modifiedBy: number;
    modifiedDate: moment.Moment;
    isCustomer: boolean;
}

export class CompanyDto implements ICompanyDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CompanyDto {
        const json = this.toJSON();
        let result = new CompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class ContactInfo implements IContactInfo {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    contactInfoType: string | undefined;
    name: string | undefined;
    numberType: string | undefined;
    number: string | undefined;
    emailType: string | undefined;
    email: string | undefined;
    isPrimary: boolean;
    fax: string | undefined;
    eFax: string | undefined;
    website: string | undefined;
    customerId: number | undefined;
    customer: Customer;

    constructor(data?: IContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.contactInfoType = _data["contactInfoType"];
            this.name = _data["name"];
            this.numberType = _data["numberType"];
            this.number = _data["number"];
            this.emailType = _data["emailType"];
            this.email = _data["email"];
            this.isPrimary = _data["isPrimary"];
            this.fax = _data["fax"];
            this.eFax = _data["eFax"];
            this.website = _data["website"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["contactInfoType"] = this.contactInfoType;
        data["name"] = this.name;
        data["numberType"] = this.numberType;
        data["number"] = this.number;
        data["emailType"] = this.emailType;
        data["email"] = this.email;
        data["isPrimary"] = this.isPrimary;
        data["fax"] = this.fax;
        data["eFax"] = this.eFax;
        data["website"] = this.website;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }

    clone(): ContactInfo {
        const json = this.toJSON();
        let result = new ContactInfo();
        result.init(json);
        return result;
    }
}

export interface IContactInfo {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    contactInfoType: string | undefined;
    name: string | undefined;
    numberType: string | undefined;
    number: string | undefined;
    emailType: string | undefined;
    email: string | undefined;
    isPrimary: boolean;
    fax: string | undefined;
    eFax: string | undefined;
    website: string | undefined;
    customerId: number | undefined;
    customer: Customer;
}

export class ContactInfoDto implements IContactInfoDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    contactType: string | undefined;
    name: string | undefined;
    numberType: string | undefined;
    number: string | undefined;
    emailType: string | undefined;
    email: string | undefined;
    isPrimary: boolean;
    fax: string | undefined;
    eFax: string | undefined;
    website: string | undefined;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.contactType = _data["contactType"];
            this.name = _data["name"];
            this.numberType = _data["numberType"];
            this.number = _data["number"];
            this.emailType = _data["emailType"];
            this.email = _data["email"];
            this.isPrimary = _data["isPrimary"];
            this.fax = _data["fax"];
            this.eFax = _data["eFax"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["contactType"] = this.contactType;
        data["name"] = this.name;
        data["numberType"] = this.numberType;
        data["number"] = this.number;
        data["emailType"] = this.emailType;
        data["email"] = this.email;
        data["isPrimary"] = this.isPrimary;
        data["fax"] = this.fax;
        data["eFax"] = this.eFax;
        data["website"] = this.website;
        return data;
    }

    clone(): ContactInfoDto {
        const json = this.toJSON();
        let result = new ContactInfoDto();
        result.init(json);
        return result;
    }
}

export interface IContactInfoDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    contactType: string | undefined;
    name: string | undefined;
    numberType: string | undefined;
    number: string | undefined;
    emailType: string | undefined;
    email: string | undefined;
    isPrimary: boolean;
    fax: string | undefined;
    eFax: string | undefined;
    website: string | undefined;
}

export class ContactPersonType implements IContactPersonType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;
    companyId: number | undefined;
    company: Company;

    constructor(data?: IContactPersonType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactPersonType {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPersonType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): ContactPersonType {
        const json = this.toJSON();
        let result = new ContactPersonType();
        result.init(json);
        return result;
    }
}

export interface IContactPersonType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;
    companyId: number | undefined;
    company: Company;
}

export class ContactPersonTypeDto implements IContactPersonTypeDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
    companyId: number | undefined;
    companyName: string | undefined;

    constructor(data?: IContactPersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): ContactPersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        return data;
    }

    clone(): ContactPersonTypeDto {
        const json = this.toJSON();
        let result = new ContactPersonTypeDto();
        result.init(json);
        return result;
    }
}

export interface IContactPersonTypeDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
    companyId: number | undefined;
    companyName: string | undefined;
}

export enum ContactTypeEnum {
    _1 = 1,
    _2 = 2,
}

export class CorporateTaxDto implements ICorporateTaxDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    customerId: number;
    financialYear: number;
    monthlyData: string | undefined;
    tenure: number;
    otherIncome: string | undefined;
    costOfSale: string | undefined;
    otherExpense: string | undefined;
    legalStatus: number | undefined;
    customer: Customer;

    constructor(data?: ICorporateTaxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.customerId = _data["customerId"];
            this.financialYear = _data["financialYear"];
            this.monthlyData = _data["monthlyData"];
            this.tenure = _data["tenure"];
            this.otherIncome = _data["otherIncome"];
            this.costOfSale = _data["costOfSale"];
            this.otherExpense = _data["otherExpense"];
            this.legalStatus = _data["legalStatus"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CorporateTaxDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateTaxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["customerId"] = this.customerId;
        data["financialYear"] = this.financialYear;
        data["monthlyData"] = this.monthlyData;
        data["tenure"] = this.tenure;
        data["otherIncome"] = this.otherIncome;
        data["costOfSale"] = this.costOfSale;
        data["otherExpense"] = this.otherExpense;
        data["legalStatus"] = this.legalStatus;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }

    clone(): CorporateTaxDto {
        const json = this.toJSON();
        let result = new CorporateTaxDto();
        result.init(json);
        return result;
    }
}

export interface ICorporateTaxDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    customerId: number;
    financialYear: number;
    monthlyData: string | undefined;
    tenure: number;
    otherIncome: string | undefined;
    costOfSale: string | undefined;
    otherExpense: string | undefined;
    legalStatus: number | undefined;
    customer: Customer;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    invoice: InvoiceDto;
    tenantId: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoice = _data["invoice"] ? InvoiceDto.fromJS(_data["invoice"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateInvoiceDto {
        const json = this.toJSON();
        let result = new CreateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceDto {
    invoice: InvoiceDto;
    tenantId: number | undefined;
}

export class CreateOrEditAccountTypeInputDto implements ICreateOrEditAccountTypeInputDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    accountNature: number;

    constructor(data?: ICreateOrEditAccountTypeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.accountNature = _data["accountNature"];
        }
    }

    static fromJS(data: any): CreateOrEditAccountTypeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAccountTypeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["accountNature"] = this.accountNature;
        return data;
    }

    clone(): CreateOrEditAccountTypeInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditAccountTypeInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditAccountTypeInputDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    accountNature: number;
}

export class CreateOrEditAddressDto implements ICreateOrEditAddressDto {
    id: number;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: AddressType;
    isPrimary: boolean;

    constructor(data?: ICreateOrEditAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.completeAddress = _data["completeAddress"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.fax = _data["fax"];
            this.type = _data["type"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): CreateOrEditAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["completeAddress"] = this.completeAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["fax"] = this.fax;
        data["type"] = this.type;
        data["isPrimary"] = this.isPrimary;
        return data;
    }

    clone(): CreateOrEditAddressDto {
        const json = this.toJSON();
        let result = new CreateOrEditAddressDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditAddressDto {
    id: number;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: AddressType;
    isPrimary: boolean;
}

export class CreateOrEditBankAddressDto implements ICreateOrEditBankAddressDto {
    id: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;

    constructor(data?: ICreateOrEditBankAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
        }
    }

    static fromJS(data: any): CreateOrEditBankAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBankAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        return data;
    }

    clone(): CreateOrEditBankAddressDto {
        const json = this.toJSON();
        let result = new CreateOrEditBankAddressDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditBankAddressDto {
    id: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
}

export class CreateOrEditBankDto implements ICreateOrEditBankDto {
    id: number;
    titleofAccount: string | undefined;
    bankName: string | undefined;
    accountNumber: number;
    routing: number;
    openBalance: number;
    startingCheque: number;
    swiftCode: number;
    isActive: boolean;
    coaMainHeadId: number;
    address: CreateOrEditBankAddressDto;

    constructor(data?: ICreateOrEditBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.titleofAccount = _data["titleofAccount"];
            this.bankName = _data["bankName"];
            this.accountNumber = _data["accountNumber"];
            this.routing = _data["routing"];
            this.openBalance = _data["openBalance"];
            this.startingCheque = _data["startingCheque"];
            this.swiftCode = _data["swiftCode"];
            this.isActive = _data["isActive"];
            this.coaMainHeadId = _data["coaMainHeadId"];
            this.address = _data["address"] ? CreateOrEditBankAddressDto.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrEditBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleofAccount"] = this.titleofAccount;
        data["bankName"] = this.bankName;
        data["accountNumber"] = this.accountNumber;
        data["routing"] = this.routing;
        data["openBalance"] = this.openBalance;
        data["startingCheque"] = this.startingCheque;
        data["swiftCode"] = this.swiftCode;
        data["isActive"] = this.isActive;
        data["coaMainHeadId"] = this.coaMainHeadId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateOrEditBankDto {
        const json = this.toJSON();
        let result = new CreateOrEditBankDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditBankDto {
    id: number;
    titleofAccount: string | undefined;
    bankName: string | undefined;
    accountNumber: number;
    routing: number;
    openBalance: number;
    startingCheque: number;
    swiftCode: number;
    isActive: boolean;
    coaMainHeadId: number;
    address: CreateOrEditBankAddressDto;
}

export class CreateOrEditChartOfAccountInputDto implements ICreateOrEditChartOfAccountInputDto {
    id: number;
    accountNature: AccountNature;
    accountTypeId: number | undefined;
    mainHeadId: number | undefined;
    accountCode: number;
    accountDescription: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditChartOfAccountInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountNature = _data["accountNature"];
            this.accountTypeId = _data["accountTypeId"];
            this.mainHeadId = _data["mainHeadId"];
            this.accountCode = _data["accountCode"];
            this.accountDescription = _data["accountDescription"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditChartOfAccountInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditChartOfAccountInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountNature"] = this.accountNature;
        data["accountTypeId"] = this.accountTypeId;
        data["mainHeadId"] = this.mainHeadId;
        data["accountCode"] = this.accountCode;
        data["accountDescription"] = this.accountDescription;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditChartOfAccountInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditChartOfAccountInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditChartOfAccountInputDto {
    id: number;
    accountNature: AccountNature;
    accountTypeId: number | undefined;
    mainHeadId: number | undefined;
    accountCode: number;
    accountDescription: string | undefined;
    isActive: boolean;
}

export class CreateOrEditCompanyDto implements ICreateOrEditCompanyDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditCompanyDto {
        const json = this.toJSON();
        let result = new CreateOrEditCompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditCompanyDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class CreateOrEditContactDetalsInputDto implements ICreateOrEditContactDetalsInputDto {
    id: number;
    email: string | undefined;
    phoneNumber: number;
    mobileNumber: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    tenantId: number;

    constructor(data?: ICreateOrEditContactDetalsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateOrEditContactDetalsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditContactDetalsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateOrEditContactDetalsInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditContactDetalsInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditContactDetalsInputDto {
    id: number;
    email: string | undefined;
    phoneNumber: number;
    mobileNumber: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    tenantId: number;
}

export class CreateOrEditContactPersonTypeInputDto implements ICreateOrEditContactPersonTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
    companyId: number | undefined;

    constructor(data?: ICreateOrEditContactPersonTypeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateOrEditContactPersonTypeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditContactPersonTypeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateOrEditContactPersonTypeInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditContactPersonTypeInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditContactPersonTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
    companyId: number | undefined;
}

export class CreateOrEditCustomerDto implements ICreateOrEditCustomerDto {
    id: number;
    customerInfo: CustomerInfoDto;
    detail: DetailDto;
    contactPersons: ContactInfoDto[] | undefined;
    address: CustomerAddressDto[] | undefined;
    fillingDetail: FillingDetailsDto[] | undefined;
    userPassword: UserNamePasswordDto[] | undefined;
    bussinessName: string | undefined;
    taxId: string | undefined;
    businessDescription: string | undefined;
    eftps: number | undefined;
    nysUserName: string | undefined;
    nysPassword: string | undefined;
    website: string | undefined;
    comment: string | undefined;
    fiscalYearStart: moment.Moment | undefined;
    email: string | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    dateOfBirth: moment.Moment | undefined;
    socialSecurityNumber: string | undefined;
    name: string | undefined;
    jobDescription: string | undefined;
    jobTitleId: number | undefined;
    detailComment: string | undefined;
    stateUserName: string | undefined;
    stateUserPassword: string | undefined;
    spouseId: number | undefined;
    languageId: number | undefined;
    ethnicityId: number | undefined;
    contactPersonTypeId: number | undefined;
    sourceReferralTypeId: number | undefined;
    salesPersonTypeId: number | undefined;
    generalEntityTypeId: number | undefined;
    addresses: CreateOrEditAddressDto[] | undefined;
    phoneNumbers: CreateOrEditPhoneDto[] | undefined;
    emails: CreateOrEditEmailInputDto[] | undefined;
    spouse: Spouse;

    constructor(data?: ICreateOrEditCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerInfo = _data["customerInfo"] ? CustomerInfoDto.fromJS(_data["customerInfo"]) : <any>undefined;
            this.detail = _data["detail"] ? DetailDto.fromJS(_data["detail"]) : <any>undefined;
            if (Array.isArray(_data["contactPersons"])) {
                this.contactPersons = [] as any;
                for (let item of _data["contactPersons"])
                    this.contactPersons.push(ContactInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address.push(CustomerAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["fillingDetail"])) {
                this.fillingDetail = [] as any;
                for (let item of _data["fillingDetail"])
                    this.fillingDetail.push(FillingDetailsDto.fromJS(item));
            }
            if (Array.isArray(_data["userPassword"])) {
                this.userPassword = [] as any;
                for (let item of _data["userPassword"])
                    this.userPassword.push(UserNamePasswordDto.fromJS(item));
            }
            this.bussinessName = _data["bussinessName"];
            this.taxId = _data["taxId"];
            this.businessDescription = _data["businessDescription"];
            this.eftps = _data["eftps"];
            this.nysUserName = _data["nysUserName"];
            this.nysPassword = _data["nysPassword"];
            this.website = _data["website"];
            this.comment = _data["comment"];
            this.fiscalYearStart = _data["fiscalYearStart"] ? moment(_data["fiscalYearStart"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? moment(_data["fiscalYearEnd"].toString()) : <any>undefined;
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.socialSecurityNumber = _data["socialSecurityNumber"];
            this.name = _data["name"];
            this.jobDescription = _data["jobDescription"];
            this.jobTitleId = _data["jobTitleId"];
            this.detailComment = _data["detailComment"];
            this.stateUserName = _data["stateUserName"];
            this.stateUserPassword = _data["stateUserPassword"];
            this.spouseId = _data["spouseId"];
            this.languageId = _data["languageId"];
            this.ethnicityId = _data["ethnicityId"];
            this.contactPersonTypeId = _data["contactPersonTypeId"];
            this.sourceReferralTypeId = _data["sourceReferralTypeId"];
            this.salesPersonTypeId = _data["salesPersonTypeId"];
            this.generalEntityTypeId = _data["generalEntityTypeId"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses.push(CreateOrEditAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers.push(CreateOrEditPhoneDto.fromJS(item));
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails.push(CreateOrEditEmailInputDto.fromJS(item));
            }
            this.spouse = _data["spouse"] ? Spouse.fromJS(_data["spouse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrEditCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerInfo"] = this.customerInfo ? this.customerInfo.toJSON() : <any>undefined;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        if (Array.isArray(this.contactPersons)) {
            data["contactPersons"] = [];
            for (let item of this.contactPersons)
                data["contactPersons"].push(item.toJSON());
        }
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        if (Array.isArray(this.fillingDetail)) {
            data["fillingDetail"] = [];
            for (let item of this.fillingDetail)
                data["fillingDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.userPassword)) {
            data["userPassword"] = [];
            for (let item of this.userPassword)
                data["userPassword"].push(item.toJSON());
        }
        data["bussinessName"] = this.bussinessName;
        data["taxId"] = this.taxId;
        data["businessDescription"] = this.businessDescription;
        data["eftps"] = this.eftps;
        data["nysUserName"] = this.nysUserName;
        data["nysPassword"] = this.nysPassword;
        data["website"] = this.website;
        data["comment"] = this.comment;
        data["fiscalYearStart"] = this.fiscalYearStart ? this.fiscalYearStart.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toISOString() : <any>undefined;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["socialSecurityNumber"] = this.socialSecurityNumber;
        data["name"] = this.name;
        data["jobDescription"] = this.jobDescription;
        data["jobTitleId"] = this.jobTitleId;
        data["detailComment"] = this.detailComment;
        data["stateUserName"] = this.stateUserName;
        data["stateUserPassword"] = this.stateUserPassword;
        data["spouseId"] = this.spouseId;
        data["languageId"] = this.languageId;
        data["ethnicityId"] = this.ethnicityId;
        data["contactPersonTypeId"] = this.contactPersonTypeId;
        data["sourceReferralTypeId"] = this.sourceReferralTypeId;
        data["salesPersonTypeId"] = this.salesPersonTypeId;
        data["generalEntityTypeId"] = this.generalEntityTypeId;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        data["spouse"] = this.spouse ? this.spouse.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateOrEditCustomerDto {
        const json = this.toJSON();
        let result = new CreateOrEditCustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditCustomerDto {
    id: number;
    customerInfo: CustomerInfoDto;
    detail: DetailDto;
    contactPersons: ContactInfoDto[] | undefined;
    address: CustomerAddressDto[] | undefined;
    fillingDetail: FillingDetailsDto[] | undefined;
    userPassword: UserNamePasswordDto[] | undefined;
    bussinessName: string | undefined;
    taxId: string | undefined;
    businessDescription: string | undefined;
    eftps: number | undefined;
    nysUserName: string | undefined;
    nysPassword: string | undefined;
    website: string | undefined;
    comment: string | undefined;
    fiscalYearStart: moment.Moment | undefined;
    email: string | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    dateOfBirth: moment.Moment | undefined;
    socialSecurityNumber: string | undefined;
    name: string | undefined;
    jobDescription: string | undefined;
    jobTitleId: number | undefined;
    detailComment: string | undefined;
    stateUserName: string | undefined;
    stateUserPassword: string | undefined;
    spouseId: number | undefined;
    languageId: number | undefined;
    ethnicityId: number | undefined;
    contactPersonTypeId: number | undefined;
    sourceReferralTypeId: number | undefined;
    salesPersonTypeId: number | undefined;
    generalEntityTypeId: number | undefined;
    addresses: CreateOrEditAddressDto[] | undefined;
    phoneNumbers: CreateOrEditPhoneDto[] | undefined;
    emails: CreateOrEditEmailInputDto[] | undefined;
    spouse: Spouse;
}

export class CreateOrEditCustomerTypeInputDto implements ICreateOrEditCustomerTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditCustomerTypeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerTypeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerTypeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditCustomerTypeInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditCustomerTypeInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditCustomerTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class CreateOrEditEmailInputDto implements ICreateOrEditEmailInputDto {
    id: number;
    typeEmail: EmailType;
    emailAddress: string | undefined;
    isPrimary: boolean;

    constructor(data?: ICreateOrEditEmailInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeEmail = _data["typeEmail"];
            this.emailAddress = _data["emailAddress"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): CreateOrEditEmailInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEmailInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeEmail"] = this.typeEmail;
        data["emailAddress"] = this.emailAddress;
        data["isPrimary"] = this.isPrimary;
        return data;
    }

    clone(): CreateOrEditEmailInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditEmailInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditEmailInputDto {
    id: number;
    typeEmail: EmailType;
    emailAddress: string | undefined;
    isPrimary: boolean;
}

export class CreateOrEditEthnicityDto implements ICreateOrEditEthnicityDto {
    id: number;
    name: string | undefined;
    descripition: string | undefined;
    companyId: number | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditEthnicityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.descripition = _data["descripition"];
            this.companyId = _data["companyId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditEthnicityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEthnicityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["descripition"] = this.descripition;
        data["companyId"] = this.companyId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditEthnicityDto {
        const json = this.toJSON();
        let result = new CreateOrEditEthnicityDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditEthnicityDto {
    id: number;
    name: string | undefined;
    descripition: string | undefined;
    companyId: number | undefined;
    isActive: boolean;
}

export class CreateOrEditGeneralEntityTypeInputDto implements ICreateOrEditGeneralEntityTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditGeneralEntityTypeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditGeneralEntityTypeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGeneralEntityTypeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditGeneralEntityTypeInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditGeneralEntityTypeInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditGeneralEntityTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class CreateOrEditGeneralPaymentMethodInputDto implements ICreateOrEditGeneralPaymentMethodInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditGeneralPaymentMethodInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditGeneralPaymentMethodInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGeneralPaymentMethodInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditGeneralPaymentMethodInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditGeneralPaymentMethodInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditGeneralPaymentMethodInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class CreateOrEditGeneralUserGroupInputDto implements ICreateOrEditGeneralUserGroupInputDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    ipRestrictionUserGroup: boolean;
    ipAddress: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditGeneralUserGroupInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.ipRestrictionUserGroup = _data["ipRestrictionUserGroup"];
            this.ipAddress = _data["ipAddress"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditGeneralUserGroupInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGeneralUserGroupInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["ipRestrictionUserGroup"] = this.ipRestrictionUserGroup;
        data["ipAddress"] = this.ipAddress;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditGeneralUserGroupInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditGeneralUserGroupInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditGeneralUserGroupInputDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    ipRestrictionUserGroup: boolean;
    ipAddress: string | undefined;
    isActive: boolean;
}

export class CreateOrEditJobTitleInputDto implements ICreateOrEditJobTitleInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditJobTitleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditJobTitleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditJobTitleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditJobTitleInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditJobTitleInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditJobTitleInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class CreateOrEditLanguageInputDto implements ICreateOrEditLanguageInputDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;
    companyId: number | undefined;

    constructor(data?: ICreateOrEditLanguageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateOrEditLanguageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLanguageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateOrEditLanguageInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditLanguageInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditLanguageInputDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;
    companyId: number | undefined;
}

export class CreateOrEditMainHeadingInputDto implements ICreateOrEditMainHeadingInputDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    accountTypeId: number | undefined;

    constructor(data?: ICreateOrEditMainHeadingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.accountTypeId = _data["accountTypeId"];
        }
    }

    static fromJS(data: any): CreateOrEditMainHeadingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMainHeadingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["accountTypeId"] = this.accountTypeId;
        return data;
    }

    clone(): CreateOrEditMainHeadingInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditMainHeadingInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMainHeadingInputDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    accountTypeId: number | undefined;
}

export class CreateOrEditMerchantInputDto implements ICreateOrEditMerchantInputDto {
    id: number;
    name: string | undefined;
    apiKey: string | undefined;
    apiSecretKey: string | undefined;
    token: string | undefined;
    ccmid: string | undefined;
    ccun: string | undefined;
    ccpwd: string | undefined;
    active: boolean;

    constructor(data?: ICreateOrEditMerchantInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.apiKey = _data["apiKey"];
            this.apiSecretKey = _data["apiSecretKey"];
            this.token = _data["token"];
            this.ccmid = _data["ccmid"];
            this.ccun = _data["ccun"];
            this.ccpwd = _data["ccpwd"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): CreateOrEditMerchantInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMerchantInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["apiKey"] = this.apiKey;
        data["apiSecretKey"] = this.apiSecretKey;
        data["token"] = this.token;
        data["ccmid"] = this.ccmid;
        data["ccun"] = this.ccun;
        data["ccpwd"] = this.ccpwd;
        data["active"] = this.active;
        return data;
    }

    clone(): CreateOrEditMerchantInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditMerchantInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMerchantInputDto {
    id: number;
    name: string | undefined;
    apiKey: string | undefined;
    apiSecretKey: string | undefined;
    token: string | undefined;
    ccmid: string | undefined;
    ccun: string | undefined;
    ccpwd: string | undefined;
    active: boolean;
}

export class CreateOrEditPersonalInformationInputDto implements ICreateOrEditPersonalInformationInputDto {
    id: number;
    title: Title;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    suffix: string | undefined;
    gender: Gender;
    dateofBirth: moment.Moment | undefined;
    employeeCode: string | undefined;
    hireDate: moment.Moment | undefined;
    defaultSessionTimeout: number;
    tenantId: number;

    constructor(data?: ICreateOrEditPersonalInformationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.suffix = _data["suffix"];
            this.gender = _data["gender"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.employeeCode = _data["employeeCode"];
            this.hireDate = _data["hireDate"] ? moment(_data["hireDate"].toString()) : <any>undefined;
            this.defaultSessionTimeout = _data["defaultSessionTimeout"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateOrEditPersonalInformationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPersonalInformationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["suffix"] = this.suffix;
        data["gender"] = this.gender;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["employeeCode"] = this.employeeCode;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["defaultSessionTimeout"] = this.defaultSessionTimeout;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateOrEditPersonalInformationInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditPersonalInformationInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditPersonalInformationInputDto {
    id: number;
    title: Title;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    suffix: string | undefined;
    gender: Gender;
    dateofBirth: moment.Moment | undefined;
    employeeCode: string | undefined;
    hireDate: moment.Moment | undefined;
    defaultSessionTimeout: number;
    tenantId: number;
}

export class CreateOrEditPhoneDto implements ICreateOrEditPhoneDto {
    id: number;
    type: PhoneType;
    number: string | undefined;
    isPrimary: boolean;

    constructor(data?: ICreateOrEditPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.number = _data["number"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): CreateOrEditPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["number"] = this.number;
        data["isPrimary"] = this.isPrimary;
        return data;
    }

    clone(): CreateOrEditPhoneDto {
        const json = this.toJSON();
        let result = new CreateOrEditPhoneDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditPhoneDto {
    id: number;
    type: PhoneType;
    number: string | undefined;
    isPrimary: boolean;
}

export class CreateOrEditProductCategoryDto implements ICreateOrEditProductCategoryDto {
    id: number;
    name: string | undefined;
    nature: string | undefined;
    productCategoryEnum: ProductCategoryEnum;
    isActive: boolean;
    companyId: number | undefined;

    constructor(data?: ICreateOrEditProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nature = _data["nature"];
            this.productCategoryEnum = _data["productCategoryEnum"];
            this.isActive = _data["isActive"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateOrEditProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nature"] = this.nature;
        data["productCategoryEnum"] = this.productCategoryEnum;
        data["isActive"] = this.isActive;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateOrEditProductCategoryDto {
        const json = this.toJSON();
        let result = new CreateOrEditProductCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditProductCategoryDto {
    id: number;
    name: string | undefined;
    nature: string | undefined;
    productCategoryEnum: ProductCategoryEnum;
    isActive: boolean;
    companyId: number | undefined;
}

export class CreateOrEditProductServiceInputDto implements ICreateOrEditProductServiceInputDto {
    id: number;
    name: string | undefined;
    incomeAccountId: number | undefined;
    fromSalePrice: moment.Moment | undefined;
    toSalePrice: moment.Moment | undefined;
    fromCostPrice: moment.Moment | undefined;
    toCostPrice: moment.Moment | undefined;
    expenseAccountId: number | undefined;
    typeId: number | undefined;
    salePrice: number;
    saleTax: string | undefined;
    expenseSaleTax: string | undefined;
    costPrice: number;
    saleInformation: string | undefined;
    automaticExpense: boolean | undefined;
    sku: string | undefined;
    isActive: boolean;
    vendorId: number | undefined;
    advanceSaleTaxAccountId: number | undefined;
    liabilityAccountId: number | undefined;
    productCategoryId: number | undefined;

    constructor(data?: ICreateOrEditProductServiceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.incomeAccountId = _data["incomeAccountId"];
            this.fromSalePrice = _data["fromSalePrice"] ? moment(_data["fromSalePrice"].toString()) : <any>undefined;
            this.toSalePrice = _data["toSalePrice"] ? moment(_data["toSalePrice"].toString()) : <any>undefined;
            this.fromCostPrice = _data["fromCostPrice"] ? moment(_data["fromCostPrice"].toString()) : <any>undefined;
            this.toCostPrice = _data["toCostPrice"] ? moment(_data["toCostPrice"].toString()) : <any>undefined;
            this.expenseAccountId = _data["expenseAccountId"];
            this.typeId = _data["typeId"];
            this.salePrice = _data["salePrice"];
            this.saleTax = _data["saleTax"];
            this.expenseSaleTax = _data["expenseSaleTax"];
            this.costPrice = _data["costPrice"];
            this.saleInformation = _data["saleInformation"];
            this.automaticExpense = _data["automaticExpense"];
            this.sku = _data["sku"];
            this.isActive = _data["isActive"];
            this.vendorId = _data["vendorId"];
            this.advanceSaleTaxAccountId = _data["advanceSaleTaxAccountId"];
            this.liabilityAccountId = _data["liabilityAccountId"];
            this.productCategoryId = _data["productCategoryId"];
        }
    }

    static fromJS(data: any): CreateOrEditProductServiceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductServiceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["incomeAccountId"] = this.incomeAccountId;
        data["fromSalePrice"] = this.fromSalePrice ? this.fromSalePrice.toISOString() : <any>undefined;
        data["toSalePrice"] = this.toSalePrice ? this.toSalePrice.toISOString() : <any>undefined;
        data["fromCostPrice"] = this.fromCostPrice ? this.fromCostPrice.toISOString() : <any>undefined;
        data["toCostPrice"] = this.toCostPrice ? this.toCostPrice.toISOString() : <any>undefined;
        data["expenseAccountId"] = this.expenseAccountId;
        data["typeId"] = this.typeId;
        data["salePrice"] = this.salePrice;
        data["saleTax"] = this.saleTax;
        data["expenseSaleTax"] = this.expenseSaleTax;
        data["costPrice"] = this.costPrice;
        data["saleInformation"] = this.saleInformation;
        data["automaticExpense"] = this.automaticExpense;
        data["sku"] = this.sku;
        data["isActive"] = this.isActive;
        data["vendorId"] = this.vendorId;
        data["advanceSaleTaxAccountId"] = this.advanceSaleTaxAccountId;
        data["liabilityAccountId"] = this.liabilityAccountId;
        data["productCategoryId"] = this.productCategoryId;
        return data;
    }

    clone(): CreateOrEditProductServiceInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditProductServiceInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditProductServiceInputDto {
    id: number;
    name: string | undefined;
    incomeAccountId: number | undefined;
    fromSalePrice: moment.Moment | undefined;
    toSalePrice: moment.Moment | undefined;
    fromCostPrice: moment.Moment | undefined;
    toCostPrice: moment.Moment | undefined;
    expenseAccountId: number | undefined;
    typeId: number | undefined;
    salePrice: number;
    saleTax: string | undefined;
    expenseSaleTax: string | undefined;
    costPrice: number;
    saleInformation: string | undefined;
    automaticExpense: boolean | undefined;
    sku: string | undefined;
    isActive: boolean;
    vendorId: number | undefined;
    advanceSaleTaxAccountId: number | undefined;
    liabilityAccountId: number | undefined;
    productCategoryId: number | undefined;
}

export class CreateOrEditSalesPersonTypeDto implements ICreateOrEditSalesPersonTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    email: string | undefined;
    isActive: boolean;
    phone: CreateOrEditPhoneDto;
    address: CreateOrEditAddressDto;
    addressId: number;

    constructor(data?: ICreateOrEditSalesPersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.email = _data["email"];
            this.isActive = _data["isActive"];
            this.phone = _data["phone"] ? CreateOrEditPhoneDto.fromJS(_data["phone"]) : <any>undefined;
            this.address = _data["address"] ? CreateOrEditAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.addressId = _data["addressId"];
        }
    }

    static fromJS(data: any): CreateOrEditSalesPersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSalesPersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["addressId"] = this.addressId;
        return data;
    }

    clone(): CreateOrEditSalesPersonTypeDto {
        const json = this.toJSON();
        let result = new CreateOrEditSalesPersonTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSalesPersonTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    email: string | undefined;
    isActive: boolean;
    phone: CreateOrEditPhoneDto;
    address: CreateOrEditAddressDto;
    addressId: number;
}

export class CreateOrEditSourceReferralTypeDto implements ICreateOrEditSourceReferralTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    email: CreateOrEditEmailInputDto;
    phone: CreateOrEditPhoneDto;
    address: CreateOrEditAddressDto;
    companyId: number | undefined;

    constructor(data?: ICreateOrEditSourceReferralTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.email = _data["email"] ? CreateOrEditEmailInputDto.fromJS(_data["email"]) : <any>undefined;
            this.phone = _data["phone"] ? CreateOrEditPhoneDto.fromJS(_data["phone"]) : <any>undefined;
            this.address = _data["address"] ? CreateOrEditAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateOrEditSourceReferralTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSourceReferralTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateOrEditSourceReferralTypeDto {
        const json = this.toJSON();
        let result = new CreateOrEditSourceReferralTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSourceReferralTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    email: CreateOrEditEmailInputDto;
    phone: CreateOrEditPhoneDto;
    address: CreateOrEditAddressDto;
    companyId: number | undefined;
}

export class CreateOrEditSpouseDto implements ICreateOrEditSpouseDto {
    id: number;
    spouseSuffix: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    ssn: string | undefined;
    spouseJobDescription: string | undefined;
    dateOfBirth: moment.Moment;
    languageId: number | undefined;
    jobTitleId: number | undefined;
    ethnicityId: number | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditSpouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.spouseSuffix = _data["spouseSuffix"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.ssn = _data["ssn"];
            this.spouseJobDescription = _data["spouseJobDescription"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.languageId = _data["languageId"];
            this.jobTitleId = _data["jobTitleId"];
            this.ethnicityId = _data["ethnicityId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditSpouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSpouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["spouseSuffix"] = this.spouseSuffix;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["ssn"] = this.ssn;
        data["spouseJobDescription"] = this.spouseJobDescription;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["languageId"] = this.languageId;
        data["jobTitleId"] = this.jobTitleId;
        data["ethnicityId"] = this.ethnicityId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditSpouseDto {
        const json = this.toJSON();
        let result = new CreateOrEditSpouseDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSpouseDto {
    id: number;
    spouseSuffix: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    ssn: string | undefined;
    spouseJobDescription: string | undefined;
    dateOfBirth: moment.Moment;
    languageId: number | undefined;
    jobTitleId: number | undefined;
    ethnicityId: number | undefined;
    isActive: boolean;
}

export class CreateOrEditUserDto implements ICreateOrEditUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateOrEditUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrEditUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateOrEditUserDto {
        const json = this.toJSON();
        let result = new CreateOrEditUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateOrEditVenderDto implements ICreateOrEditVenderDto {
    id: number;
    businessName: string | undefined;
    dateOfBirth: moment.Moment;
    taxId: number;
    isActive: boolean;
    description: string | undefined;
    ssn: string | undefined;
    vendorName: string | undefined;
    venderTypeId: number | undefined;
    companyId: number;

    constructor(data?: ICreateOrEditVenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessName = _data["businessName"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.taxId = _data["taxId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.ssn = _data["ssn"];
            this.vendorName = _data["vendorName"];
            this.venderTypeId = _data["venderTypeId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateOrEditVenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessName"] = this.businessName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["taxId"] = this.taxId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["ssn"] = this.ssn;
        data["vendorName"] = this.vendorName;
        data["venderTypeId"] = this.venderTypeId;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateOrEditVenderDto {
        const json = this.toJSON();
        let result = new CreateOrEditVenderDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditVenderDto {
    id: number;
    businessName: string | undefined;
    dateOfBirth: moment.Moment;
    taxId: number;
    isActive: boolean;
    description: string | undefined;
    ssn: string | undefined;
    vendorName: string | undefined;
    venderTypeId: number | undefined;
    companyId: number;
}

export class CreateOrEditVenderTypeInputDto implements ICreateOrEditVenderTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateOrEditVenderTypeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrEditVenderTypeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVenderTypeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateOrEditVenderTypeInputDto {
        const json = this.toJSON();
        let result = new CreateOrEditVenderTypeInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditVenderTypeInputDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class CreateOrEditVendorAddressDto implements ICreateOrEditVendorAddressDto {
    id: number;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;
    vendorId: number | undefined;
    vendor: Vendor;

    constructor(data?: ICreateOrEditVendorAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.completeAddress = _data["completeAddress"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.fax = _data["fax"];
            this.type = _data["type"];
            this.isPrimary = _data["isPrimary"];
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? Vendor.fromJS(_data["vendor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrEditVendorAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVendorAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["completeAddress"] = this.completeAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["fax"] = this.fax;
        data["type"] = this.type;
        data["isPrimary"] = this.isPrimary;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateOrEditVendorAddressDto {
        const json = this.toJSON();
        let result = new CreateOrEditVendorAddressDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditVendorAddressDto {
    id: number;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;
    vendorId: number | undefined;
    vendor: Vendor;
}

export class CreateOrEditVendorContactInfoDto implements ICreateOrEditVendorContactInfoDto {
    id: number;
    contactPersonName: string | undefined;
    contactTypeName: string | undefined;
    fax: string | undefined;
    emailTypeId: number | undefined;
    eFax: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    webSite: string | undefined;
    primary: boolean;
    contactPersonTypeId: number | undefined;
    contactPersonType: ContactPersonType;
    contactTypeId: number | undefined;
    vendorId: number | undefined;

    constructor(data?: ICreateOrEditVendorContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactPersonName = _data["contactPersonName"];
            this.contactTypeName = _data["contactTypeName"];
            this.fax = _data["fax"];
            this.emailTypeId = _data["emailTypeId"];
            this.eFax = _data["eFax"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.webSite = _data["webSite"];
            this.primary = _data["primary"];
            this.contactPersonTypeId = _data["contactPersonTypeId"];
            this.contactPersonType = _data["contactPersonType"] ? ContactPersonType.fromJS(_data["contactPersonType"]) : <any>undefined;
            this.contactTypeId = _data["contactTypeId"];
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): CreateOrEditVendorContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVendorContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactPersonName"] = this.contactPersonName;
        data["contactTypeName"] = this.contactTypeName;
        data["fax"] = this.fax;
        data["emailTypeId"] = this.emailTypeId;
        data["eFax"] = this.eFax;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["webSite"] = this.webSite;
        data["primary"] = this.primary;
        data["contactPersonTypeId"] = this.contactPersonTypeId;
        data["contactPersonType"] = this.contactPersonType ? this.contactPersonType.toJSON() : <any>undefined;
        data["contactTypeId"] = this.contactTypeId;
        data["vendorId"] = this.vendorId;
        return data;
    }

    clone(): CreateOrEditVendorContactInfoDto {
        const json = this.toJSON();
        let result = new CreateOrEditVendorContactInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditVendorContactInfoDto {
    id: number;
    contactPersonName: string | undefined;
    contactTypeName: string | undefined;
    fax: string | undefined;
    emailTypeId: number | undefined;
    eFax: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    webSite: string | undefined;
    primary: boolean;
    contactPersonTypeId: number | undefined;
    contactPersonType: ContactPersonType;
    contactTypeId: number | undefined;
    vendorId: number | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    ipRestriction: boolean;
    ipAddress: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.ipRestriction = _data["ipRestriction"];
            this.ipAddress = _data["ipAddress"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["ipRestriction"] = this.ipRestriction;
        data["ipAddress"] = this.ipAddress;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    ipRestriction: boolean;
    ipAddress: string | undefined;
    isActive: boolean;
}

export class CreateSalesReceiptDto implements ICreateSalesReceiptDto {
    salesReceipt: SalesReceiptDto;

    constructor(data?: ICreateSalesReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesReceipt = _data["salesReceipt"] ? SalesReceiptDto.fromJS(_data["salesReceipt"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSalesReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSalesReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesReceipt"] = this.salesReceipt ? this.salesReceipt.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateSalesReceiptDto {
        const json = this.toJSON();
        let result = new CreateSalesReceiptDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSalesReceiptDto {
    salesReceipt: SalesReceiptDto;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class Currency implements ICurrency {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    name: string | undefined;
    symbol: string | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        return data;
    }

    clone(): Currency {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

export interface ICurrency {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    name: string | undefined;
    symbol: string | undefined;
}

export class Customer implements ICustomer {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    bussinessName: string;
    texId: string | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    name: string | undefined;
    businessDescription: string | undefined;
    taxId: string | undefined;
    socialSecurityNumber: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    customerTypeId: number | undefined;
    customerType: CustomerType;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    jobDescription: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    detailComment: string | undefined;
    todoListComment: string | undefined;
    crmComment: string | undefined;
    dlState: number | undefined;
    code: number;
    comment: string | undefined;
    spouseId: number | undefined;
    spouse: Spouse;
    dependentIds: string | undefined;
    dependent: Dependent[] | undefined;
    salesPersonTypeId: number | undefined;
    salesPersonType: SalesPersonType;
    licenseComment: string | undefined;
    passwordComment: string | undefined;
    sourceReferralTypeId: number | undefined;
    sourceReferralType: SourceReferralType;
    ethnicityId: number | undefined;
    ethnicity: Ethnicity;
    languageId: number | undefined;
    language: Language;
    contactPersonTypeId: number | undefined;
    contactPersonType: ContactPersonType;
    customerPasswords: CustomerPassword[] | undefined;
    suffix: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    taxRegNo: string | undefined;
    notes: string | undefined;
    password: string | undefined;
    companyFormationDate: moment.Moment | undefined;
    stateUserName: string | undefined;
    stateUserPassword: string | undefined;
    fiscalYearStart: moment.Moment | undefined;
    responsiblePerson: string | undefined;
    eftps: number | undefined;
    nysUsername: string | undefined;
    nysPassword: string | undefined;
    taxFillingStatus: string | undefined;
    legalStatus: number | undefined;
    tenantId: number;
    companyId: number | undefined;
    company: Company;
    jobTitleId: number | undefined;
    jobTitle: JobTitle;
    generalEntityTypeId: number | undefined;
    generalEntityType: GeneralEntityType;
    contactInfo: ContactInfo[] | undefined;
    address: Address[] | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.bussinessName = _data["bussinessName"];
            this.texId = _data["texId"];
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? moment(_data["fiscalYearEnd"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.businessDescription = _data["businessDescription"];
            this.taxId = _data["taxId"];
            this.socialSecurityNumber = _data["socialSecurityNumber"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.customerTypeId = _data["customerTypeId"];
            this.customerType = _data["customerType"] ? CustomerType.fromJS(_data["customerType"]) : <any>undefined;
            this.ssn = _data["ssn"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.jobDescription = _data["jobDescription"];
            this.drivingLicense = _data["drivingLicense"];
            this.dlIssue = _data["dlIssue"] ? moment(_data["dlIssue"].toString()) : <any>undefined;
            this.dlExpiry = _data["dlExpiry"] ? moment(_data["dlExpiry"].toString()) : <any>undefined;
            this.detailComment = _data["detailComment"];
            this.todoListComment = _data["todoListComment"];
            this.crmComment = _data["crmComment"];
            this.dlState = _data["dlState"];
            this.code = _data["code"];
            this.comment = _data["comment"];
            this.spouseId = _data["spouseId"];
            this.spouse = _data["spouse"] ? Spouse.fromJS(_data["spouse"]) : <any>undefined;
            this.dependentIds = _data["dependentIds"];
            if (Array.isArray(_data["dependent"])) {
                this.dependent = [] as any;
                for (let item of _data["dependent"])
                    this.dependent.push(Dependent.fromJS(item));
            }
            this.salesPersonTypeId = _data["salesPersonTypeId"];
            this.salesPersonType = _data["salesPersonType"] ? SalesPersonType.fromJS(_data["salesPersonType"]) : <any>undefined;
            this.licenseComment = _data["licenseComment"];
            this.passwordComment = _data["passwordComment"];
            this.sourceReferralTypeId = _data["sourceReferralTypeId"];
            this.sourceReferralType = _data["sourceReferralType"] ? SourceReferralType.fromJS(_data["sourceReferralType"]) : <any>undefined;
            this.ethnicityId = _data["ethnicityId"];
            this.ethnicity = _data["ethnicity"] ? Ethnicity.fromJS(_data["ethnicity"]) : <any>undefined;
            this.languageId = _data["languageId"];
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>undefined;
            this.contactPersonTypeId = _data["contactPersonTypeId"];
            this.contactPersonType = _data["contactPersonType"] ? ContactPersonType.fromJS(_data["contactPersonType"]) : <any>undefined;
            if (Array.isArray(_data["customerPasswords"])) {
                this.customerPasswords = [] as any;
                for (let item of _data["customerPasswords"])
                    this.customerPasswords.push(CustomerPassword.fromJS(item));
            }
            this.suffix = _data["suffix"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.taxRegNo = _data["taxRegNo"];
            this.notes = _data["notes"];
            this.password = _data["password"];
            this.companyFormationDate = _data["companyFormationDate"] ? moment(_data["companyFormationDate"].toString()) : <any>undefined;
            this.stateUserName = _data["stateUserName"];
            this.stateUserPassword = _data["stateUserPassword"];
            this.fiscalYearStart = _data["fiscalYearStart"] ? moment(_data["fiscalYearStart"].toString()) : <any>undefined;
            this.responsiblePerson = _data["responsiblePerson"];
            this.eftps = _data["eftps"];
            this.nysUsername = _data["nysUsername"];
            this.nysPassword = _data["nysPassword"];
            this.taxFillingStatus = _data["taxFillingStatus"];
            this.legalStatus = _data["legalStatus"];
            this.tenantId = _data["tenantId"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? JobTitle.fromJS(_data["jobTitle"]) : <any>undefined;
            this.generalEntityTypeId = _data["generalEntityTypeId"];
            this.generalEntityType = _data["generalEntityType"] ? GeneralEntityType.fromJS(_data["generalEntityType"]) : <any>undefined;
            if (Array.isArray(_data["contactInfo"])) {
                this.contactInfo = [] as any;
                for (let item of _data["contactInfo"])
                    this.contactInfo.push(ContactInfo.fromJS(item));
            }
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address.push(Address.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["bussinessName"] = this.bussinessName;
        data["texId"] = this.texId;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["businessDescription"] = this.businessDescription;
        data["taxId"] = this.taxId;
        data["socialSecurityNumber"] = this.socialSecurityNumber;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["customerTypeId"] = this.customerTypeId;
        data["customerType"] = this.customerType ? this.customerType.toJSON() : <any>undefined;
        data["ssn"] = this.ssn;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["jobDescription"] = this.jobDescription;
        data["drivingLicense"] = this.drivingLicense;
        data["dlIssue"] = this.dlIssue ? this.dlIssue.toISOString() : <any>undefined;
        data["dlExpiry"] = this.dlExpiry ? this.dlExpiry.toISOString() : <any>undefined;
        data["detailComment"] = this.detailComment;
        data["todoListComment"] = this.todoListComment;
        data["crmComment"] = this.crmComment;
        data["dlState"] = this.dlState;
        data["code"] = this.code;
        data["comment"] = this.comment;
        data["spouseId"] = this.spouseId;
        data["spouse"] = this.spouse ? this.spouse.toJSON() : <any>undefined;
        data["dependentIds"] = this.dependentIds;
        if (Array.isArray(this.dependent)) {
            data["dependent"] = [];
            for (let item of this.dependent)
                data["dependent"].push(item.toJSON());
        }
        data["salesPersonTypeId"] = this.salesPersonTypeId;
        data["salesPersonType"] = this.salesPersonType ? this.salesPersonType.toJSON() : <any>undefined;
        data["licenseComment"] = this.licenseComment;
        data["passwordComment"] = this.passwordComment;
        data["sourceReferralTypeId"] = this.sourceReferralTypeId;
        data["sourceReferralType"] = this.sourceReferralType ? this.sourceReferralType.toJSON() : <any>undefined;
        data["ethnicityId"] = this.ethnicityId;
        data["ethnicity"] = this.ethnicity ? this.ethnicity.toJSON() : <any>undefined;
        data["languageId"] = this.languageId;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["contactPersonTypeId"] = this.contactPersonTypeId;
        data["contactPersonType"] = this.contactPersonType ? this.contactPersonType.toJSON() : <any>undefined;
        if (Array.isArray(this.customerPasswords)) {
            data["customerPasswords"] = [];
            for (let item of this.customerPasswords)
                data["customerPasswords"].push(item.toJSON());
        }
        data["suffix"] = this.suffix;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["taxRegNo"] = this.taxRegNo;
        data["notes"] = this.notes;
        data["password"] = this.password;
        data["companyFormationDate"] = this.companyFormationDate ? this.companyFormationDate.toISOString() : <any>undefined;
        data["stateUserName"] = this.stateUserName;
        data["stateUserPassword"] = this.stateUserPassword;
        data["fiscalYearStart"] = this.fiscalYearStart ? this.fiscalYearStart.toISOString() : <any>undefined;
        data["responsiblePerson"] = this.responsiblePerson;
        data["eftps"] = this.eftps;
        data["nysUsername"] = this.nysUsername;
        data["nysPassword"] = this.nysPassword;
        data["taxFillingStatus"] = this.taxFillingStatus;
        data["legalStatus"] = this.legalStatus;
        data["tenantId"] = this.tenantId;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["generalEntityTypeId"] = this.generalEntityTypeId;
        data["generalEntityType"] = this.generalEntityType ? this.generalEntityType.toJSON() : <any>undefined;
        if (Array.isArray(this.contactInfo)) {
            data["contactInfo"] = [];
            for (let item of this.contactInfo)
                data["contactInfo"].push(item.toJSON());
        }
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        return data;
    }

    clone(): Customer {
        const json = this.toJSON();
        let result = new Customer();
        result.init(json);
        return result;
    }
}

export interface ICustomer {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    bussinessName: string;
    texId: string | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    name: string | undefined;
    businessDescription: string | undefined;
    taxId: string | undefined;
    socialSecurityNumber: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    customerTypeId: number | undefined;
    customerType: CustomerType;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    jobDescription: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    detailComment: string | undefined;
    todoListComment: string | undefined;
    crmComment: string | undefined;
    dlState: number | undefined;
    code: number;
    comment: string | undefined;
    spouseId: number | undefined;
    spouse: Spouse;
    dependentIds: string | undefined;
    dependent: Dependent[] | undefined;
    salesPersonTypeId: number | undefined;
    salesPersonType: SalesPersonType;
    licenseComment: string | undefined;
    passwordComment: string | undefined;
    sourceReferralTypeId: number | undefined;
    sourceReferralType: SourceReferralType;
    ethnicityId: number | undefined;
    ethnicity: Ethnicity;
    languageId: number | undefined;
    language: Language;
    contactPersonTypeId: number | undefined;
    contactPersonType: ContactPersonType;
    customerPasswords: CustomerPassword[] | undefined;
    suffix: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    taxRegNo: string | undefined;
    notes: string | undefined;
    password: string | undefined;
    companyFormationDate: moment.Moment | undefined;
    stateUserName: string | undefined;
    stateUserPassword: string | undefined;
    fiscalYearStart: moment.Moment | undefined;
    responsiblePerson: string | undefined;
    eftps: number | undefined;
    nysUsername: string | undefined;
    nysPassword: string | undefined;
    taxFillingStatus: string | undefined;
    legalStatus: number | undefined;
    tenantId: number;
    companyId: number | undefined;
    company: Company;
    jobTitleId: number | undefined;
    jobTitle: JobTitle;
    generalEntityTypeId: number | undefined;
    generalEntityType: GeneralEntityType;
    contactInfo: ContactInfo[] | undefined;
    address: Address[] | undefined;
}

export class CustomerAddressDto implements ICustomerAddressDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    type: string | undefined;
    address: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    state: string | undefined;
    isPrimary: string | undefined;
    country: string | undefined;

    constructor(data?: ICustomerAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.type = _data["type"];
            this.address = _data["address"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.isPrimary = _data["isPrimary"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): CustomerAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["type"] = this.type;
        data["address"] = this.address;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["state"] = this.state;
        data["isPrimary"] = this.isPrimary;
        data["country"] = this.country;
        return data;
    }

    clone(): CustomerAddressDto {
        const json = this.toJSON();
        let result = new CustomerAddressDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerAddressDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    type: string | undefined;
    address: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    state: string | undefined;
    isPrimary: string | undefined;
    country: string | undefined;
}

export class CustomerDiary implements ICustomerDiary {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    addedOn: moment.Moment;
    customerId: number;
    customer: Customer;

    constructor(data?: ICustomerDiary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.addedOn = _data["addedOn"] ? moment(_data["addedOn"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerDiary {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDiary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["addedOn"] = this.addedOn ? this.addedOn.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerDiary {
        const json = this.toJSON();
        let result = new CustomerDiary();
        result.init(json);
        return result;
    }
}

export interface ICustomerDiary {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    addedOn: moment.Moment;
    customerId: number;
    customer: Customer;
}

export class CustomerDto implements ICustomerDto {
    id: number;
    bussinessName: string | undefined;
    taxId: string | undefined;
    businessDescription: string | undefined;
    eftps: string | undefined;
    website: string | undefined;
    fiscalYearStart: moment.Moment | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    dateOfBirth: moment.Moment | undefined;
    socialSecurityNumber: string | undefined;
    name: string | undefined;
    jobDescription: string | undefined;
    stateUserName: string | undefined;
    stateUserPassword: string | undefined;
    spouseId: number | undefined;
    refCopmayId: number | undefined;
    spouse: Spouse;
    languageId: number | undefined;
    companyName: string | undefined;
    language: Language;
    ethnicity: Ethnicity;
    contactPersonType: ContactPersonTypeDto;
    customerType: CustomerTypeDto;
    sourceReferralType: SourceReferralTypeDto;
    salesPersonType: SalesPersonTypeDto;
    entityType: GeneralEntityTypeDto;
    address: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    stateName: string | undefined;
    stateCode: number;
    dependentNames: string | undefined;
    dependentRelations: string | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bussinessName = _data["bussinessName"];
            this.taxId = _data["taxId"];
            this.businessDescription = _data["businessDescription"];
            this.eftps = _data["eftps"];
            this.website = _data["website"];
            this.fiscalYearStart = _data["fiscalYearStart"] ? moment(_data["fiscalYearStart"].toString()) : <any>undefined;
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? moment(_data["fiscalYearEnd"].toString()) : <any>undefined;
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.socialSecurityNumber = _data["socialSecurityNumber"];
            this.name = _data["name"];
            this.jobDescription = _data["jobDescription"];
            this.stateUserName = _data["stateUserName"];
            this.stateUserPassword = _data["stateUserPassword"];
            this.spouseId = _data["spouseId"];
            this.refCopmayId = _data["refCopmayId"];
            this.spouse = _data["spouse"] ? Spouse.fromJS(_data["spouse"]) : <any>undefined;
            this.languageId = _data["languageId"];
            this.companyName = _data["companyName"];
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>undefined;
            this.ethnicity = _data["ethnicity"] ? Ethnicity.fromJS(_data["ethnicity"]) : <any>undefined;
            this.contactPersonType = _data["contactPersonType"] ? ContactPersonTypeDto.fromJS(_data["contactPersonType"]) : <any>undefined;
            this.customerType = _data["customerType"] ? CustomerTypeDto.fromJS(_data["customerType"]) : <any>undefined;
            this.sourceReferralType = _data["sourceReferralType"] ? SourceReferralTypeDto.fromJS(_data["sourceReferralType"]) : <any>undefined;
            this.salesPersonType = _data["salesPersonType"] ? SalesPersonTypeDto.fromJS(_data["salesPersonType"]) : <any>undefined;
            this.entityType = _data["entityType"] ? GeneralEntityTypeDto.fromJS(_data["entityType"]) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.stateName = _data["stateName"];
            this.stateCode = _data["stateCode"];
            this.dependentNames = _data["dependentNames"];
            this.dependentRelations = _data["dependentRelations"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bussinessName"] = this.bussinessName;
        data["taxId"] = this.taxId;
        data["businessDescription"] = this.businessDescription;
        data["eftps"] = this.eftps;
        data["website"] = this.website;
        data["fiscalYearStart"] = this.fiscalYearStart ? this.fiscalYearStart.toISOString() : <any>undefined;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toISOString() : <any>undefined;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["socialSecurityNumber"] = this.socialSecurityNumber;
        data["name"] = this.name;
        data["jobDescription"] = this.jobDescription;
        data["stateUserName"] = this.stateUserName;
        data["stateUserPassword"] = this.stateUserPassword;
        data["spouseId"] = this.spouseId;
        data["refCopmayId"] = this.refCopmayId;
        data["spouse"] = this.spouse ? this.spouse.toJSON() : <any>undefined;
        data["languageId"] = this.languageId;
        data["companyName"] = this.companyName;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["ethnicity"] = this.ethnicity ? this.ethnicity.toJSON() : <any>undefined;
        data["contactPersonType"] = this.contactPersonType ? this.contactPersonType.toJSON() : <any>undefined;
        data["customerType"] = this.customerType ? this.customerType.toJSON() : <any>undefined;
        data["sourceReferralType"] = this.sourceReferralType ? this.sourceReferralType.toJSON() : <any>undefined;
        data["salesPersonType"] = this.salesPersonType ? this.salesPersonType.toJSON() : <any>undefined;
        data["entityType"] = this.entityType ? this.entityType.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["stateName"] = this.stateName;
        data["stateCode"] = this.stateCode;
        data["dependentNames"] = this.dependentNames;
        data["dependentRelations"] = this.dependentRelations;
        return data;
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    id: number;
    bussinessName: string | undefined;
    taxId: string | undefined;
    businessDescription: string | undefined;
    eftps: string | undefined;
    website: string | undefined;
    fiscalYearStart: moment.Moment | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    dateOfBirth: moment.Moment | undefined;
    socialSecurityNumber: string | undefined;
    name: string | undefined;
    jobDescription: string | undefined;
    stateUserName: string | undefined;
    stateUserPassword: string | undefined;
    spouseId: number | undefined;
    refCopmayId: number | undefined;
    spouse: Spouse;
    languageId: number | undefined;
    companyName: string | undefined;
    language: Language;
    ethnicity: Ethnicity;
    contactPersonType: ContactPersonTypeDto;
    customerType: CustomerTypeDto;
    sourceReferralType: SourceReferralTypeDto;
    salesPersonType: SalesPersonTypeDto;
    entityType: GeneralEntityTypeDto;
    address: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    stateName: string | undefined;
    stateCode: number;
    dependentNames: string | undefined;
    dependentRelations: string | undefined;
}

export class CustomerDtoPagedResultDto implements ICustomerDtoPagedResultDto {
    items: CustomerDto[] | undefined;
    totalCount: number;

    constructor(data?: ICustomerDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CustomerDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CustomerDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CustomerDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoPagedResultDto {
    items: CustomerDto[] | undefined;
    totalCount: number;
}

export class CustomerInfoDto implements ICustomerInfoDto {
    id: number | undefined;
    bussinessName: string;
    texId: string | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    name: string | undefined;
    businessDescription: string | undefined;
    taxId: string | undefined;
    socialSecurityNumber: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    customerType: CustomerTypeDto;
    customerTypeId: number | undefined;
    dependentId: number[] | undefined;
    comment: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    jobDescription: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    dlState: number | undefined;
    code: number;
    spouse: SpouseDto;
    dependent: DependentDto[] | undefined;
    sourceReferralType: SourceReferralTypeDto;

    constructor(data?: ICustomerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bussinessName = _data["bussinessName"];
            this.texId = _data["texId"];
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? moment(_data["fiscalYearEnd"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.businessDescription = _data["businessDescription"];
            this.taxId = _data["taxId"];
            this.socialSecurityNumber = _data["socialSecurityNumber"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.customerType = _data["customerType"] ? CustomerTypeDto.fromJS(_data["customerType"]) : <any>undefined;
            this.customerTypeId = _data["customerTypeId"];
            if (Array.isArray(_data["dependentId"])) {
                this.dependentId = [] as any;
                for (let item of _data["dependentId"])
                    this.dependentId.push(item);
            }
            this.comment = _data["comment"];
            this.ssn = _data["ssn"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.jobDescription = _data["jobDescription"];
            this.drivingLicense = _data["drivingLicense"];
            this.dlIssue = _data["dlIssue"] ? moment(_data["dlIssue"].toString()) : <any>undefined;
            this.dlExpiry = _data["dlExpiry"] ? moment(_data["dlExpiry"].toString()) : <any>undefined;
            this.dlState = _data["dlState"];
            this.code = _data["code"];
            this.spouse = _data["spouse"] ? SpouseDto.fromJS(_data["spouse"]) : <any>undefined;
            if (Array.isArray(_data["dependent"])) {
                this.dependent = [] as any;
                for (let item of _data["dependent"])
                    this.dependent.push(DependentDto.fromJS(item));
            }
            this.sourceReferralType = _data["sourceReferralType"] ? SourceReferralTypeDto.fromJS(_data["sourceReferralType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bussinessName"] = this.bussinessName;
        data["texId"] = this.texId;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["businessDescription"] = this.businessDescription;
        data["taxId"] = this.taxId;
        data["socialSecurityNumber"] = this.socialSecurityNumber;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["customerType"] = this.customerType ? this.customerType.toJSON() : <any>undefined;
        data["customerTypeId"] = this.customerTypeId;
        if (Array.isArray(this.dependentId)) {
            data["dependentId"] = [];
            for (let item of this.dependentId)
                data["dependentId"].push(item);
        }
        data["comment"] = this.comment;
        data["ssn"] = this.ssn;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["jobDescription"] = this.jobDescription;
        data["drivingLicense"] = this.drivingLicense;
        data["dlIssue"] = this.dlIssue ? this.dlIssue.toISOString() : <any>undefined;
        data["dlExpiry"] = this.dlExpiry ? this.dlExpiry.toISOString() : <any>undefined;
        data["dlState"] = this.dlState;
        data["code"] = this.code;
        data["spouse"] = this.spouse ? this.spouse.toJSON() : <any>undefined;
        if (Array.isArray(this.dependent)) {
            data["dependent"] = [];
            for (let item of this.dependent)
                data["dependent"].push(item.toJSON());
        }
        data["sourceReferralType"] = this.sourceReferralType ? this.sourceReferralType.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerInfoDto {
        const json = this.toJSON();
        let result = new CustomerInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerInfoDto {
    id: number | undefined;
    bussinessName: string;
    texId: string | undefined;
    fiscalYearEnd: moment.Moment | undefined;
    name: string | undefined;
    businessDescription: string | undefined;
    taxId: string | undefined;
    socialSecurityNumber: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    customerType: CustomerTypeDto;
    customerTypeId: number | undefined;
    dependentId: number[] | undefined;
    comment: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    jobDescription: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    dlState: number | undefined;
    code: number;
    spouse: SpouseDto;
    dependent: DependentDto[] | undefined;
    sourceReferralType: SourceReferralTypeDto;
}

export class CustomerLookupDto implements ICustomerLookupDto {
    filter: string | undefined;

    constructor(data?: ICustomerLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): CustomerLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        return data;
    }

    clone(): CustomerLookupDto {
        const json = this.toJSON();
        let result = new CustomerLookupDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerLookupDto {
    filter: string | undefined;
}

export class CustomerLookupOutput implements ICustomerLookupOutput {
    id: number;
    name: string | undefined;
    companyName: string | undefined;

    constructor(data?: ICustomerLookupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): CustomerLookupOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLookupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyName"] = this.companyName;
        return data;
    }

    clone(): CustomerLookupOutput {
        const json = this.toJSON();
        let result = new CustomerLookupOutput();
        result.init(json);
        return result;
    }
}

export interface ICustomerLookupOutput {
    id: number;
    name: string | undefined;
    companyName: string | undefined;
}

export class CustomerLookupOutputListResultDto implements ICustomerLookupOutputListResultDto {
    items: CustomerLookupOutput[] | undefined;

    constructor(data?: ICustomerLookupOutputListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CustomerLookupOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerLookupOutputListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLookupOutputListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CustomerLookupOutputListResultDto {
        const json = this.toJSON();
        let result = new CustomerLookupOutputListResultDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerLookupOutputListResultDto {
    items: CustomerLookupOutput[] | undefined;
}

export class CustomerPassword implements ICustomerPassword {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    type: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    description: string | undefined;
    url: string | undefined;
    customerId: number;
    customer: Customer;

    constructor(data?: ICustomerPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerPassword {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["description"] = this.description;
        data["url"] = this.url;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerPassword {
        const json = this.toJSON();
        let result = new CustomerPassword();
        result.init(json);
        return result;
    }
}

export interface ICustomerPassword {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    type: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    description: string | undefined;
    url: string | undefined;
    customerId: number;
    customer: Customer;
}

export class CustomerTaxSelection implements ICustomerTaxSelection {
    id: number;
    customerId: number;
    taxService: TaxService;

    constructor(data?: ICustomerTaxSelection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.taxService = _data["taxService"];
        }
    }

    static fromJS(data: any): CustomerTaxSelection {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTaxSelection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["taxService"] = this.taxService;
        return data;
    }

    clone(): CustomerTaxSelection {
        const json = this.toJSON();
        let result = new CustomerTaxSelection();
        result.init(json);
        return result;
    }
}

export interface ICustomerTaxSelection {
    id: number;
    customerId: number;
    taxService: TaxService;
}

export class CustomerTransactionDto implements ICustomerTransactionDto {
    id: number;
    invoiceId: number | undefined;
    invoiceDate: moment.Moment | undefined;
    type: string | undefined;
    invoiceCode: string | undefined;
    product: string | undefined;
    description: string | undefined;
    csr: string | undefined;
    balance: number | undefined;
    total: number | undefined;
    refCustomerId: number | undefined;
    status: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    addedBy: string | undefined;
    company: string | undefined;
    orignalInvoiceNo: string | undefined;
    email: string | undefined;
    note: string | undefined;
    refrenceNo: string | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;

    constructor(data?: ICustomerTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.invoiceCode = _data["invoiceCode"];
            this.product = _data["product"];
            this.description = _data["description"];
            this.csr = _data["csr"];
            this.balance = _data["balance"];
            this.total = _data["total"];
            this.refCustomerId = _data["refCustomerId"];
            this.status = _data["status"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.addedBy = _data["addedBy"];
            this.company = _data["company"];
            this.orignalInvoiceNo = _data["orignalInvoiceNo"];
            this.email = _data["email"];
            this.note = _data["note"];
            this.refrenceNo = _data["refrenceNo"];
            this.comAddress = _data["comAddress"];
            this.comCity = _data["comCity"];
            this.comState = _data["comState"];
            this.comPostCode = _data["comPostCode"];
            this.comCountry = _data["comCountry"];
            this.comEmail = _data["comEmail"];
            this.comPhone = _data["comPhone"];
        }
    }

    static fromJS(data: any): CustomerTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["invoiceCode"] = this.invoiceCode;
        data["product"] = this.product;
        data["description"] = this.description;
        data["csr"] = this.csr;
        data["balance"] = this.balance;
        data["total"] = this.total;
        data["refCustomerId"] = this.refCustomerId;
        data["status"] = this.status;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["addedBy"] = this.addedBy;
        data["company"] = this.company;
        data["orignalInvoiceNo"] = this.orignalInvoiceNo;
        data["email"] = this.email;
        data["note"] = this.note;
        data["refrenceNo"] = this.refrenceNo;
        data["comAddress"] = this.comAddress;
        data["comCity"] = this.comCity;
        data["comState"] = this.comState;
        data["comPostCode"] = this.comPostCode;
        data["comCountry"] = this.comCountry;
        data["comEmail"] = this.comEmail;
        data["comPhone"] = this.comPhone;
        return data;
    }

    clone(): CustomerTransactionDto {
        const json = this.toJSON();
        let result = new CustomerTransactionDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerTransactionDto {
    id: number;
    invoiceId: number | undefined;
    invoiceDate: moment.Moment | undefined;
    type: string | undefined;
    invoiceCode: string | undefined;
    product: string | undefined;
    description: string | undefined;
    csr: string | undefined;
    balance: number | undefined;
    total: number | undefined;
    refCustomerId: number | undefined;
    status: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    addedBy: string | undefined;
    company: string | undefined;
    orignalInvoiceNo: string | undefined;
    email: string | undefined;
    note: string | undefined;
    refrenceNo: string | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;
}

export class CustomerType implements ICustomerType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICustomerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerType {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CustomerType {
        const json = this.toJSON();
        let result = new CustomerType();
        result.init(json);
        return result;
    }
}

export interface ICustomerType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class CustomerTypeDto implements ICustomerTypeDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: ICustomerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CustomerTypeDto {
        const json = this.toJSON();
        let result = new CustomerTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerTypeDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class DLState implements IDLState {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    stateName: string | undefined;
    stateCode: number;

    constructor(data?: IDLState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.stateName = _data["stateName"];
            this.stateCode = _data["stateCode"];
        }
    }

    static fromJS(data: any): DLState {
        data = typeof data === 'object' ? data : {};
        let result = new DLState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["stateName"] = this.stateName;
        data["stateCode"] = this.stateCode;
        return data;
    }

    clone(): DLState {
        const json = this.toJSON();
        let result = new DLState();
        result.init(json);
        return result;
    }
}

export interface IDLState {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    stateName: string | undefined;
    stateCode: number;
}

export class DailyReceiptDto implements IDailyReceiptDto {
    id: number;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    refCustomerId: number | undefined;
    company: string | undefined;
    paymentMethod: string | undefined;
    companyId: number | undefined;
    refDepositToAccountId: number | undefined;
    paymentDate: moment.Moment | undefined;
    employeeName: string | undefined;
    refPaymentMethodId: number | undefined;
    total: number | undefined;
    customerName: string | undefined;
    csr: string | undefined;
    accountDescription: string | undefined;
    openBalance: number | undefined;
    paidAmount: number | undefined;

    constructor(data?: IDailyReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceNo = _data["invoiceNo"];
            this.refCustomerId = _data["refCustomerId"];
            this.company = _data["company"];
            this.paymentMethod = _data["paymentMethod"];
            this.companyId = _data["companyId"];
            this.refDepositToAccountId = _data["refDepositToAccountId"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.employeeName = _data["employeeName"];
            this.refPaymentMethodId = _data["refPaymentMethodId"];
            this.total = _data["total"];
            this.customerName = _data["customerName"];
            this.csr = _data["csr"];
            this.accountDescription = _data["accountDescription"];
            this.openBalance = _data["openBalance"];
            this.paidAmount = _data["paidAmount"];
        }
    }

    static fromJS(data: any): DailyReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["invoiceNo"] = this.invoiceNo;
        data["refCustomerId"] = this.refCustomerId;
        data["company"] = this.company;
        data["paymentMethod"] = this.paymentMethod;
        data["companyId"] = this.companyId;
        data["refDepositToAccountId"] = this.refDepositToAccountId;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["employeeName"] = this.employeeName;
        data["refPaymentMethodId"] = this.refPaymentMethodId;
        data["total"] = this.total;
        data["customerName"] = this.customerName;
        data["csr"] = this.csr;
        data["accountDescription"] = this.accountDescription;
        data["openBalance"] = this.openBalance;
        data["paidAmount"] = this.paidAmount;
        return data;
    }

    clone(): DailyReceiptDto {
        const json = this.toJSON();
        let result = new DailyReceiptDto();
        result.init(json);
        return result;
    }
}

export interface IDailyReceiptDto {
    id: number;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    refCustomerId: number | undefined;
    company: string | undefined;
    paymentMethod: string | undefined;
    companyId: number | undefined;
    refDepositToAccountId: number | undefined;
    paymentDate: moment.Moment | undefined;
    employeeName: string | undefined;
    refPaymentMethodId: number | undefined;
    total: number | undefined;
    customerName: string | undefined;
    csr: string | undefined;
    accountDescription: string | undefined;
    openBalance: number | undefined;
    paidAmount: number | undefined;
}

export class Dependent implements IDependent {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    ssn: string | undefined;
    relation: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    customerId: number;
    customer: Customer;

    constructor(data?: IDependent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.ssn = _data["ssn"];
            this.relation = _data["relation"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Dependent {
        data = typeof data === 'object' ? data : {};
        let result = new Dependent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["ssn"] = this.ssn;
        data["relation"] = this.relation;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }

    clone(): Dependent {
        const json = this.toJSON();
        let result = new Dependent();
        result.init(json);
        return result;
    }
}

export interface IDependent {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    ssn: string | undefined;
    relation: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    customerId: number;
    customer: Customer;
}

export class DependentDto implements IDependentDto {
    id: number | undefined;
    name: string | undefined;
    relation: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;

    constructor(data?: IDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.relation = _data["relation"];
            this.ssn = _data["ssn"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["relation"] = this.relation;
        data["ssn"] = this.ssn;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data;
    }

    clone(): DependentDto {
        const json = this.toJSON();
        let result = new DependentDto();
        result.init(json);
        return result;
    }
}

export interface IDependentDto {
    id: number | undefined;
    name: string | undefined;
    relation: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
}

export class DetailDto implements IDetailDto {
    language: LanguageDto;
    ethnicity: EthnicityDto;
    salesPersonType: SalesPersonTypeDto;

    constructor(data?: IDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? LanguageDto.fromJS(_data["language"]) : <any>undefined;
            this.ethnicity = _data["ethnicity"] ? EthnicityDto.fromJS(_data["ethnicity"]) : <any>undefined;
            this.salesPersonType = _data["salesPersonType"] ? SalesPersonTypeDto.fromJS(_data["salesPersonType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["ethnicity"] = this.ethnicity ? this.ethnicity.toJSON() : <any>undefined;
        data["salesPersonType"] = this.salesPersonType ? this.salesPersonType.toJSON() : <any>undefined;
        return data;
    }

    clone(): DetailDto {
        const json = this.toJSON();
        let result = new DetailDto();
        result.init(json);
        return result;
    }
}

export interface IDetailDto {
    language: LanguageDto;
    ethnicity: EthnicityDto;
    salesPersonType: SalesPersonTypeDto;
}

export class Email implements IEmail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    typeEmail: EmailType;
    emailAddress: string | undefined;
    isPrimary: boolean;
    emailVerified: boolean;

    constructor(data?: IEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.typeEmail = _data["typeEmail"];
            this.emailAddress = _data["emailAddress"];
            this.isPrimary = _data["isPrimary"];
            this.emailVerified = _data["emailVerified"];
        }
    }

    static fromJS(data: any): Email {
        data = typeof data === 'object' ? data : {};
        let result = new Email();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["typeEmail"] = this.typeEmail;
        data["emailAddress"] = this.emailAddress;
        data["isPrimary"] = this.isPrimary;
        data["emailVerified"] = this.emailVerified;
        return data;
    }

    clone(): Email {
        const json = this.toJSON();
        let result = new Email();
        result.init(json);
        return result;
    }
}

export interface IEmail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    typeEmail: EmailType;
    emailAddress: string | undefined;
    isPrimary: boolean;
    emailVerified: boolean;
}

export class EmailDto implements IEmailDto {
    id: number;
    typeEmail: EmailType;
    emailAddress: string | undefined;
    isPrimary: boolean;
    emailVerified: boolean;

    constructor(data?: IEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeEmail = _data["typeEmail"];
            this.emailAddress = _data["emailAddress"];
            this.isPrimary = _data["isPrimary"];
            this.emailVerified = _data["emailVerified"];
        }
    }

    static fromJS(data: any): EmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeEmail"] = this.typeEmail;
        data["emailAddress"] = this.emailAddress;
        data["isPrimary"] = this.isPrimary;
        data["emailVerified"] = this.emailVerified;
        return data;
    }

    clone(): EmailDto {
        const json = this.toJSON();
        let result = new EmailDto();
        result.init(json);
        return result;
    }
}

export interface IEmailDto {
    id: number;
    typeEmail: EmailType;
    emailAddress: string | undefined;
    isPrimary: boolean;
    emailVerified: boolean;
}

export enum EmailType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class EmailsDto implements IEmailsDto {
    subject: string | undefined;
    body: string | undefined;
    toEmail: string | undefined;
    streams: StringMemoryStreamTuple[] | undefined;

    constructor(data?: IEmailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.toEmail = _data["toEmail"];
            if (Array.isArray(_data["streams"])) {
                this.streams = [] as any;
                for (let item of _data["streams"])
                    this.streams.push(StringMemoryStreamTuple.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["toEmail"] = this.toEmail;
        if (Array.isArray(this.streams)) {
            data["streams"] = [];
            for (let item of this.streams)
                data["streams"].push(item.toJSON());
        }
        return data;
    }

    clone(): EmailsDto {
        const json = this.toJSON();
        let result = new EmailsDto();
        result.init(json);
        return result;
    }
}

export interface IEmailsDto {
    subject: string | undefined;
    body: string | undefined;
    toEmail: string | undefined;
    streams: StringMemoryStreamTuple[] | undefined;
}

export class EntityDto implements IEntityDto {
    id: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number;
}

export class Ethnicity implements IEthnicity {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    descripition: string | undefined;
    companyId: number | undefined;
    company: Company;
    isActive: boolean;

    constructor(data?: IEthnicity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.descripition = _data["descripition"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): Ethnicity {
        data = typeof data === 'object' ? data : {};
        let result = new Ethnicity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["descripition"] = this.descripition;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): Ethnicity {
        const json = this.toJSON();
        let result = new Ethnicity();
        result.init(json);
        return result;
    }
}

export interface IEthnicity {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    descripition: string | undefined;
    companyId: number | undefined;
    company: Company;
    isActive: boolean;
}

export class EthnicityDto implements IEthnicityDto {
    id: number;
    name: string | undefined;
    descripition: string | undefined;
    companyId: number | undefined;
    company: Company;
    isActive: boolean | undefined;

    constructor(data?: IEthnicityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.descripition = _data["descripition"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EthnicityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EthnicityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["descripition"] = this.descripition;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): EthnicityDto {
        const json = this.toJSON();
        let result = new EthnicityDto();
        result.init(json);
        return result;
    }
}

export interface IEthnicityDto {
    id: number;
    name: string | undefined;
    descripition: string | undefined;
    companyId: number | undefined;
    company: Company;
    isActive: boolean | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FillingDetailsDto implements IFillingDetailsDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    type: number | undefined;
    corporationTaxType: number;
    fillingType: moment.Moment;

    constructor(data?: IFillingDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.type = _data["type"];
            this.corporationTaxType = _data["corporationTaxType"];
            this.fillingType = _data["fillingType"] ? moment(_data["fillingType"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FillingDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FillingDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["type"] = this.type;
        data["corporationTaxType"] = this.corporationTaxType;
        data["fillingType"] = this.fillingType ? this.fillingType.toISOString() : <any>undefined;
        return data;
    }

    clone(): FillingDetailsDto {
        const json = this.toJSON();
        let result = new FillingDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IFillingDetailsDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    type: number | undefined;
    corporationTaxType: number;
    fillingType: moment.Moment;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
    parentName: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        data["parentName"] = this.parentName;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
    parentName: string | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
    parentName: string | undefined;
    level: number;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
            this.parentName = _data["parentName"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        data["parentName"] = this.parentName;
        data["level"] = this.level;
        return data;
    }

    clone(): FlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
    parentName: string | undefined;
    level: number;
}

export class FlatPermissionWithLevelDtoListResultDto implements IFlatPermissionWithLevelDtoListResultDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IFlatPermissionWithLevelDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FlatPermissionWithLevelDtoListResultDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDtoListResultDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export enum FormEnum {
    _1021 = 1021,
    _1028 = 1028,
    _1040 = 1040,
}

export enum Gender {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class GeneralContactDetailsDto implements IGeneralContactDetailsDto {
    id: number;
    email: string | undefined;
    phoneNumber: number;
    mobileNumber: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    tenantId: number;

    constructor(data?: IGeneralContactDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): GeneralContactDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralContactDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): GeneralContactDetailsDto {
        const json = this.toJSON();
        let result = new GeneralContactDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralContactDetailsDto {
    id: number;
    email: string | undefined;
    phoneNumber: number;
    mobileNumber: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    tenantId: number;
}

export class GeneralEntityType implements IGeneralEntityType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IGeneralEntityType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GeneralEntityType {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralEntityType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): GeneralEntityType {
        const json = this.toJSON();
        let result = new GeneralEntityType();
        result.init(json);
        return result;
    }
}

export interface IGeneralEntityType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class GeneralEntityTypeDto implements IGeneralEntityTypeDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IGeneralEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GeneralEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): GeneralEntityTypeDto {
        const json = this.toJSON();
        let result = new GeneralEntityTypeDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralEntityTypeDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class GeneralLedgerChartOfAccountData implements IGeneralLedgerChartOfAccountData {
    subHeadId: number;
    subHeadName: string | undefined;
    mainHeadId: number;
    mainHeadName: string | undefined;
    amount: number;

    constructor(data?: IGeneralLedgerChartOfAccountData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subHeadId = _data["subHeadId"];
            this.subHeadName = _data["subHeadName"];
            this.mainHeadId = _data["mainHeadId"];
            this.mainHeadName = _data["mainHeadName"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): GeneralLedgerChartOfAccountData {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerChartOfAccountData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subHeadId"] = this.subHeadId;
        data["subHeadName"] = this.subHeadName;
        data["mainHeadId"] = this.mainHeadId;
        data["mainHeadName"] = this.mainHeadName;
        data["amount"] = this.amount;
        return data;
    }

    clone(): GeneralLedgerChartOfAccountData {
        const json = this.toJSON();
        let result = new GeneralLedgerChartOfAccountData();
        result.init(json);
        return result;
    }
}

export interface IGeneralLedgerChartOfAccountData {
    subHeadId: number;
    subHeadName: string | undefined;
    mainHeadId: number;
    mainHeadName: string | undefined;
    amount: number;
}

export class GeneralLedgerOutputDto implements IGeneralLedgerOutputDto {
    id: number;
    creationTime: moment.Moment;
    dateAlt: string | undefined;
    customerName: string | undefined;
    companyName: string | undefined;
    voucherId: string | undefined;
    csr: string | undefined;
    description: string | undefined;
    openingBalance: number;
    debitAmount: number;
    creditAmount: number;
    balance: number;
    type: string | undefined;
    customerId: number;
    linkedSubHeadId: number | undefined;
    chartOfAccountData: GeneralLedgerChartOfAccountData[] | undefined;

    constructor(data?: IGeneralLedgerOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.dateAlt = _data["dateAlt"];
            this.customerName = _data["customerName"];
            this.companyName = _data["companyName"];
            this.voucherId = _data["voucherId"];
            this.csr = _data["csr"];
            this.description = _data["description"];
            this.openingBalance = _data["openingBalance"];
            this.debitAmount = _data["debitAmount"];
            this.creditAmount = _data["creditAmount"];
            this.balance = _data["balance"];
            this.type = _data["type"];
            this.customerId = _data["customerId"];
            this.linkedSubHeadId = _data["linkedSubHeadId"];
            if (Array.isArray(_data["chartOfAccountData"])) {
                this.chartOfAccountData = [] as any;
                for (let item of _data["chartOfAccountData"])
                    this.chartOfAccountData.push(GeneralLedgerChartOfAccountData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeneralLedgerOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["dateAlt"] = this.dateAlt;
        data["customerName"] = this.customerName;
        data["companyName"] = this.companyName;
        data["voucherId"] = this.voucherId;
        data["csr"] = this.csr;
        data["description"] = this.description;
        data["openingBalance"] = this.openingBalance;
        data["debitAmount"] = this.debitAmount;
        data["creditAmount"] = this.creditAmount;
        data["balance"] = this.balance;
        data["type"] = this.type;
        data["customerId"] = this.customerId;
        data["linkedSubHeadId"] = this.linkedSubHeadId;
        if (Array.isArray(this.chartOfAccountData)) {
            data["chartOfAccountData"] = [];
            for (let item of this.chartOfAccountData)
                data["chartOfAccountData"].push(item.toJSON());
        }
        return data;
    }

    clone(): GeneralLedgerOutputDto {
        const json = this.toJSON();
        let result = new GeneralLedgerOutputDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralLedgerOutputDto {
    id: number;
    creationTime: moment.Moment;
    dateAlt: string | undefined;
    customerName: string | undefined;
    companyName: string | undefined;
    voucherId: string | undefined;
    csr: string | undefined;
    description: string | undefined;
    openingBalance: number;
    debitAmount: number;
    creditAmount: number;
    balance: number;
    type: string | undefined;
    customerId: number;
    linkedSubHeadId: number | undefined;
    chartOfAccountData: GeneralLedgerChartOfAccountData[] | undefined;
}

export class GeneralMerchantDto implements IGeneralMerchantDto {
    id: number;
    name: string | undefined;
    apiKey: string | undefined;
    apiSecretKey: string | undefined;
    token: string | undefined;
    ccmid: string | undefined;
    ccun: string | undefined;
    ccpwd: string | undefined;
    active: boolean;

    constructor(data?: IGeneralMerchantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.apiKey = _data["apiKey"];
            this.apiSecretKey = _data["apiSecretKey"];
            this.token = _data["token"];
            this.ccmid = _data["ccmid"];
            this.ccun = _data["ccun"];
            this.ccpwd = _data["ccpwd"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): GeneralMerchantDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralMerchantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["apiKey"] = this.apiKey;
        data["apiSecretKey"] = this.apiSecretKey;
        data["token"] = this.token;
        data["ccmid"] = this.ccmid;
        data["ccun"] = this.ccun;
        data["ccpwd"] = this.ccpwd;
        data["active"] = this.active;
        return data;
    }

    clone(): GeneralMerchantDto {
        const json = this.toJSON();
        let result = new GeneralMerchantDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralMerchantDto {
    id: number;
    name: string | undefined;
    apiKey: string | undefined;
    apiSecretKey: string | undefined;
    token: string | undefined;
    ccmid: string | undefined;
    ccun: string | undefined;
    ccpwd: string | undefined;
    active: boolean;
}

export class GeneralPaymentMethodDto implements IGeneralPaymentMethodDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IGeneralPaymentMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GeneralPaymentMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralPaymentMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): GeneralPaymentMethodDto {
        const json = this.toJSON();
        let result = new GeneralPaymentMethodDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralPaymentMethodDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class GeneralPersonalInformationDto implements IGeneralPersonalInformationDto {
    id: number;
    title: Title;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    suffix: string | undefined;
    gender: Gender;
    email: string | undefined;
    phoneNumber: number;
    mobileNumber: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    dateofBirth: moment.Moment | undefined;
    employeeCode: string | undefined;
    hireDate: moment.Moment | undefined;
    defaultSessionTimeout: number;
    tenantId: number;

    constructor(data?: IGeneralPersonalInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.suffix = _data["suffix"];
            this.gender = _data["gender"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.employeeCode = _data["employeeCode"];
            this.hireDate = _data["hireDate"] ? moment(_data["hireDate"].toString()) : <any>undefined;
            this.defaultSessionTimeout = _data["defaultSessionTimeout"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): GeneralPersonalInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralPersonalInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["suffix"] = this.suffix;
        data["gender"] = this.gender;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["employeeCode"] = this.employeeCode;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["defaultSessionTimeout"] = this.defaultSessionTimeout;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): GeneralPersonalInformationDto {
        const json = this.toJSON();
        let result = new GeneralPersonalInformationDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralPersonalInformationDto {
    id: number;
    title: Title;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    suffix: string | undefined;
    gender: Gender;
    email: string | undefined;
    phoneNumber: number;
    mobileNumber: number;
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    dateofBirth: moment.Moment | undefined;
    employeeCode: string | undefined;
    hireDate: moment.Moment | undefined;
    defaultSessionTimeout: number;
    tenantId: number;
}

export class GeneralUsersGroupDto implements IGeneralUsersGroupDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    ipRestrictionUserGroup: boolean;
    ipAddress: string | undefined;
    isActive: boolean;

    constructor(data?: IGeneralUsersGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.ipRestrictionUserGroup = _data["ipRestrictionUserGroup"];
            this.ipAddress = _data["ipAddress"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GeneralUsersGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralUsersGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["ipRestrictionUserGroup"] = this.ipRestrictionUserGroup;
        data["ipAddress"] = this.ipAddress;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): GeneralUsersGroupDto {
        const json = this.toJSON();
        let result = new GeneralUsersGroupDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralUsersGroupDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    ipRestrictionUserGroup: boolean;
    ipAddress: string | undefined;
    isActive: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class GetGeneralLedgerInputDto implements IGetGeneralLedgerInputDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    chartOfAccountId: number | undefined;
    subHeadId: number | undefined;

    constructor(data?: IGetGeneralLedgerInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.chartOfAccountId = _data["chartOfAccountId"];
            this.subHeadId = _data["subHeadId"];
        }
    }

    static fromJS(data: any): GetGeneralLedgerInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralLedgerInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["chartOfAccountId"] = this.chartOfAccountId;
        data["subHeadId"] = this.subHeadId;
        return data;
    }

    clone(): GetGeneralLedgerInputDto {
        const json = this.toJSON();
        let result = new GetGeneralLedgerInputDto();
        result.init(json);
        return result;
    }
}

export interface IGetGeneralLedgerInputDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    chartOfAccountId: number | undefined;
    subHeadId: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    newRole: RoleEditDto;
    role: RoleDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newRole = _data["newRole"] ? RoleEditDto.fromJS(_data["newRole"]) : <any>undefined;
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newRole"] = this.newRole ? this.newRole.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    newRole: RoleEditDto;
    role: RoleDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class IncomeDetails implements IIncomeDetails {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    incomeDescription: string | undefined;
    amount: number;
    federalWH: number;
    stateWH: number;
    personalTaxId: number;

    constructor(data?: IIncomeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.incomeDescription = _data["incomeDescription"];
            this.amount = _data["amount"];
            this.federalWH = _data["federalWH"];
            this.stateWH = _data["stateWH"];
            this.personalTaxId = _data["personalTaxId"];
        }
    }

    static fromJS(data: any): IncomeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["incomeDescription"] = this.incomeDescription;
        data["amount"] = this.amount;
        data["federalWH"] = this.federalWH;
        data["stateWH"] = this.stateWH;
        data["personalTaxId"] = this.personalTaxId;
        return data;
    }

    clone(): IncomeDetails {
        const json = this.toJSON();
        let result = new IncomeDetails();
        result.init(json);
        return result;
    }
}

export interface IIncomeDetails {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    incomeDescription: string | undefined;
    amount: number;
    federalWH: number;
    stateWH: number;
    personalTaxId: number;
}

export class Int32StringKeyValuePair implements IInt32StringKeyValuePair {
    key: number;
    value: string | undefined;

    constructor(data?: IInt32StringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Int32StringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new Int32StringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }

    clone(): Int32StringKeyValuePair {
        const json = this.toJSON();
        let result = new Int32StringKeyValuePair();
        result.init(json);
        return result;
    }
}

export interface IInt32StringKeyValuePair {
    key: number;
    value: string | undefined;
}

export class Int32StringKeyValuePairListResultDto implements IInt32StringKeyValuePairListResultDto {
    items: Int32StringKeyValuePair[] | undefined;

    constructor(data?: IInt32StringKeyValuePairListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(Int32StringKeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Int32StringKeyValuePairListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32StringKeyValuePairListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): Int32StringKeyValuePairListResultDto {
        const json = this.toJSON();
        let result = new Int32StringKeyValuePairListResultDto();
        result.init(json);
        return result;
    }
}

export interface IInt32StringKeyValuePairListResultDto {
    items: Int32StringKeyValuePair[] | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class Int64StringKeyValuePair implements IInt64StringKeyValuePair {
    key: number;
    value: string | undefined;

    constructor(data?: IInt64StringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Int64StringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new Int64StringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }

    clone(): Int64StringKeyValuePair {
        const json = this.toJSON();
        let result = new Int64StringKeyValuePair();
        result.init(json);
        return result;
    }
}

export interface IInt64StringKeyValuePair {
    key: number;
    value: string | undefined;
}

export class Int64StringKeyValuePairListResultDto implements IInt64StringKeyValuePairListResultDto {
    items: Int64StringKeyValuePair[] | undefined;

    constructor(data?: IInt64StringKeyValuePairListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(Int64StringKeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Int64StringKeyValuePairListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64StringKeyValuePairListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): Int64StringKeyValuePairListResultDto {
        const json = this.toJSON();
        let result = new Int64StringKeyValuePairListResultDto();
        result.init(json);
        return result;
    }
}

export interface IInt64StringKeyValuePairListResultDto {
    items: Int64StringKeyValuePair[] | undefined;
}

export class Invoice implements IInvoice {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    refCompanyId: number;
    invoiceType: InvoiceType;
    refCustomerId: number | undefined;
    refSupplierId: number | undefined;
    refTermId: number | undefined;
    refPaymentMethodId: number | undefined;
    refDepositToAccountId: number | undefined;
    refCashEquivalentsAccountId: number | undefined;
    email: string | undefined;
    isSendLater: boolean | undefined;
    invoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    estimateDate: moment.Moment | undefined;
    expirationDate: moment.Moment | undefined;
    creditNoteDate: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    saleReceiptDate: moment.Moment | undefined;
    refrenceNo: string | undefined;
    amountReceived: number | undefined;
    total: number | undefined;
    note: string | undefined;
    paidAmount: number | undefined;
    invoiceStatus: InvoiceStatus;
    isPaid: boolean | undefined;
    isActive: boolean;
    isRecurring: boolean | undefined;
    frequencyId: number | undefined;
    frequency: string | undefined;
    durationId: number | undefined;
    duration: string | undefined;
    invoiceGroupId: number | undefined;
    depositDate: moment.Moment | undefined;
    clearanceDate: moment.Moment | undefined;
    checkPrinted: boolean | undefined;
    refEmployeeId: number | undefined;
    refPaymentTypeId: number;
    refCardId: number;
    checkNo: number | undefined;
    recurringInvoiceNextCreationDate: moment.Moment | undefined;
    invoiceDetails: InvoiceDetail[] | undefined;

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.invoiceNo = _data["invoiceNo"];
            this.refCompanyId = _data["refCompanyId"];
            this.invoiceType = _data["invoiceType"];
            this.refCustomerId = _data["refCustomerId"];
            this.refSupplierId = _data["refSupplierId"];
            this.refTermId = _data["refTermId"];
            this.refPaymentMethodId = _data["refPaymentMethodId"];
            this.refDepositToAccountId = _data["refDepositToAccountId"];
            this.refCashEquivalentsAccountId = _data["refCashEquivalentsAccountId"];
            this.email = _data["email"];
            this.isSendLater = _data["isSendLater"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.estimateDate = _data["estimateDate"] ? moment(_data["estimateDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.creditNoteDate = _data["creditNoteDate"] ? moment(_data["creditNoteDate"].toString()) : <any>undefined;
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.purchaseReceiptDate = _data["purchaseReceiptDate"] ? moment(_data["purchaseReceiptDate"].toString()) : <any>undefined;
            this.saleReceiptDate = _data["saleReceiptDate"] ? moment(_data["saleReceiptDate"].toString()) : <any>undefined;
            this.refrenceNo = _data["refrenceNo"];
            this.amountReceived = _data["amountReceived"];
            this.total = _data["total"];
            this.note = _data["note"];
            this.paidAmount = _data["paidAmount"];
            this.invoiceStatus = _data["invoiceStatus"];
            this.isPaid = _data["isPaid"];
            this.isActive = _data["isActive"];
            this.isRecurring = _data["isRecurring"];
            this.frequencyId = _data["frequencyId"];
            this.frequency = _data["frequency"];
            this.durationId = _data["durationId"];
            this.duration = _data["duration"];
            this.invoiceGroupId = _data["invoiceGroupId"];
            this.depositDate = _data["depositDate"] ? moment(_data["depositDate"].toString()) : <any>undefined;
            this.clearanceDate = _data["clearanceDate"] ? moment(_data["clearanceDate"].toString()) : <any>undefined;
            this.checkPrinted = _data["checkPrinted"];
            this.refEmployeeId = _data["refEmployeeId"];
            this.refPaymentTypeId = _data["refPaymentTypeId"];
            this.refCardId = _data["refCardId"];
            this.checkNo = _data["checkNo"];
            this.recurringInvoiceNextCreationDate = _data["recurringInvoiceNextCreationDate"] ? moment(_data["recurringInvoiceNextCreationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails.push(InvoiceDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["refCompanyId"] = this.refCompanyId;
        data["invoiceType"] = this.invoiceType;
        data["refCustomerId"] = this.refCustomerId;
        data["refSupplierId"] = this.refSupplierId;
        data["refTermId"] = this.refTermId;
        data["refPaymentMethodId"] = this.refPaymentMethodId;
        data["refDepositToAccountId"] = this.refDepositToAccountId;
        data["refCashEquivalentsAccountId"] = this.refCashEquivalentsAccountId;
        data["email"] = this.email;
        data["isSendLater"] = this.isSendLater;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["estimateDate"] = this.estimateDate ? this.estimateDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["creditNoteDate"] = this.creditNoteDate ? this.creditNoteDate.toISOString() : <any>undefined;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["purchaseReceiptDate"] = this.purchaseReceiptDate ? this.purchaseReceiptDate.toISOString() : <any>undefined;
        data["saleReceiptDate"] = this.saleReceiptDate ? this.saleReceiptDate.toISOString() : <any>undefined;
        data["refrenceNo"] = this.refrenceNo;
        data["amountReceived"] = this.amountReceived;
        data["total"] = this.total;
        data["note"] = this.note;
        data["paidAmount"] = this.paidAmount;
        data["invoiceStatus"] = this.invoiceStatus;
        data["isPaid"] = this.isPaid;
        data["isActive"] = this.isActive;
        data["isRecurring"] = this.isRecurring;
        data["frequencyId"] = this.frequencyId;
        data["frequency"] = this.frequency;
        data["durationId"] = this.durationId;
        data["duration"] = this.duration;
        data["invoiceGroupId"] = this.invoiceGroupId;
        data["depositDate"] = this.depositDate ? this.depositDate.toISOString() : <any>undefined;
        data["clearanceDate"] = this.clearanceDate ? this.clearanceDate.toISOString() : <any>undefined;
        data["checkPrinted"] = this.checkPrinted;
        data["refEmployeeId"] = this.refEmployeeId;
        data["refPaymentTypeId"] = this.refPaymentTypeId;
        data["refCardId"] = this.refCardId;
        data["checkNo"] = this.checkNo;
        data["recurringInvoiceNextCreationDate"] = this.recurringInvoiceNextCreationDate ? this.recurringInvoiceNextCreationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): Invoice {
        const json = this.toJSON();
        let result = new Invoice();
        result.init(json);
        return result;
    }
}

export interface IInvoice {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    refCompanyId: number;
    invoiceType: InvoiceType;
    refCustomerId: number | undefined;
    refSupplierId: number | undefined;
    refTermId: number | undefined;
    refPaymentMethodId: number | undefined;
    refDepositToAccountId: number | undefined;
    refCashEquivalentsAccountId: number | undefined;
    email: string | undefined;
    isSendLater: boolean | undefined;
    invoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    estimateDate: moment.Moment | undefined;
    expirationDate: moment.Moment | undefined;
    creditNoteDate: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    saleReceiptDate: moment.Moment | undefined;
    refrenceNo: string | undefined;
    amountReceived: number | undefined;
    total: number | undefined;
    note: string | undefined;
    paidAmount: number | undefined;
    invoiceStatus: InvoiceStatus;
    isPaid: boolean | undefined;
    isActive: boolean;
    isRecurring: boolean | undefined;
    frequencyId: number | undefined;
    frequency: string | undefined;
    durationId: number | undefined;
    duration: string | undefined;
    invoiceGroupId: number | undefined;
    depositDate: moment.Moment | undefined;
    clearanceDate: moment.Moment | undefined;
    checkPrinted: boolean | undefined;
    refEmployeeId: number | undefined;
    refPaymentTypeId: number;
    refCardId: number;
    checkNo: number | undefined;
    recurringInvoiceNextCreationDate: moment.Moment | undefined;
    invoiceDetails: InvoiceDetail[] | undefined;
}

export class InvoiceDetail implements IInvoiceDetail {
    id: number;
    tenantId: number;
    refPaidInvoiceId: number | undefined;
    refProducId: number | undefined;
    refChartOfAccountId: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerId: number | undefined;
    invoiceId: number;

    constructor(data?: IInvoiceDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.refPaidInvoiceId = _data["refPaidInvoiceId"];
            this.refProducId = _data["refProducId"];
            this.refChartOfAccountId = _data["refChartOfAccountId"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.discount = _data["discount"];
            this.saleTax = _data["saleTax"];
            this.amount = _data["amount"];
            this.paidAmount = _data["paidAmount"];
            this.isPaid = _data["isPaid"];
            this.refCustomerId = _data["refCustomerId"];
            this.invoiceId = _data["invoiceId"];
        }
    }

    static fromJS(data: any): InvoiceDetail {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["refPaidInvoiceId"] = this.refPaidInvoiceId;
        data["refProducId"] = this.refProducId;
        data["refChartOfAccountId"] = this.refChartOfAccountId;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["discount"] = this.discount;
        data["saleTax"] = this.saleTax;
        data["amount"] = this.amount;
        data["paidAmount"] = this.paidAmount;
        data["isPaid"] = this.isPaid;
        data["refCustomerId"] = this.refCustomerId;
        data["invoiceId"] = this.invoiceId;
        return data;
    }

    clone(): InvoiceDetail {
        const json = this.toJSON();
        let result = new InvoiceDetail();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetail {
    id: number;
    tenantId: number;
    refPaidInvoiceId: number | undefined;
    refProducId: number | undefined;
    refChartOfAccountId: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerId: number | undefined;
    invoiceId: number;
}

export class InvoiceDetailDto implements IInvoiceDetailDto {
    id: number;
    invoiceDetailId: number | undefined;
    refPaidInvoiceID: number | undefined;
    invoiceID: number | undefined;
    refProducID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    discountAmount: number | undefined;

    constructor(data?: IInvoiceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceDetailId = _data["invoiceDetailId"];
            this.refPaidInvoiceID = _data["refPaidInvoiceID"];
            this.invoiceID = _data["invoiceID"];
            this.refProducID = _data["refProducID"];
            this.refChartOfAccountID = _data["refChartOfAccountID"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.discount = _data["discount"];
            this.saleTax = _data["saleTax"];
            this.amount = _data["amount"];
            this.paidAmount = _data["paidAmount"];
            this.isPaid = _data["isPaid"];
            this.refCustomerID = _data["refCustomerID"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceNo = _data["invoiceNo"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): InvoiceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceDetailId"] = this.invoiceDetailId;
        data["refPaidInvoiceID"] = this.refPaidInvoiceID;
        data["invoiceID"] = this.invoiceID;
        data["refProducID"] = this.refProducID;
        data["refChartOfAccountID"] = this.refChartOfAccountID;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["discount"] = this.discount;
        data["saleTax"] = this.saleTax;
        data["amount"] = this.amount;
        data["paidAmount"] = this.paidAmount;
        data["isPaid"] = this.isPaid;
        data["refCustomerID"] = this.refCustomerID;
        data["invoiceId"] = this.invoiceId;
        data["invoiceNo"] = this.invoiceNo;
        data["discountAmount"] = this.discountAmount;
        return data;
    }

    clone(): InvoiceDetailDto {
        const json = this.toJSON();
        let result = new InvoiceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailDto {
    id: number;
    invoiceDetailId: number | undefined;
    refPaidInvoiceID: number | undefined;
    invoiceID: number | undefined;
    refProducID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    discountAmount: number | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    refCompanyID: number | undefined;
    refInvoiceType: number | undefined;
    refCustomerID: number | undefined;
    refSupplierID: number | undefined;
    refTermID: number | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountID: number | undefined;
    refCashEquivalentsAccountID: number | undefined;
    email: string[] | undefined;
    isSendLater: boolean | undefined;
    invoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    estimateDate: moment.Moment | undefined;
    expirationDate: moment.Moment | undefined;
    creditNoteDate: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    saleReceiptDate: moment.Moment | undefined;
    refrenceNo: string | undefined;
    amountReceived: number | undefined;
    total: number | undefined;
    note: string | undefined;
    paidAmount: number | undefined;
    refInvoiceStatusID: number | undefined;
    isPaid: boolean | undefined;
    isActive: boolean;
    isRecurring: boolean | undefined;
    frequencyId: number | undefined;
    frequency: string | undefined;
    durationId: number | undefined;
    duration: string | undefined;
    invoiceGroupID: number | undefined;
    depositDate: moment.Moment | undefined;
    clearanceDate: moment.Moment | undefined;
    checkPrinted: boolean | undefined;
    refEmployeeID: number | undefined;
    refPaymentTypeID: number | undefined;
    refCardID: number | undefined;
    recurringInvoiceNextCreationDate: moment.Moment | undefined;
    invoiceDetails: InvoiceDetailDto[] | undefined;
    readonly refInvoiceStatus: number | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.invoiceNo = _data["invoiceNo"];
            this.refCompanyID = _data["refCompanyID"];
            this.refInvoiceType = _data["refInvoiceType"];
            this.refCustomerID = _data["refCustomerID"];
            this.refSupplierID = _data["refSupplierID"];
            this.refTermID = _data["refTermID"];
            this.refPaymentMethodID = _data["refPaymentMethodID"];
            this.refDepositToAccountID = _data["refDepositToAccountID"];
            this.refCashEquivalentsAccountID = _data["refCashEquivalentsAccountID"];
            if (Array.isArray(_data["email"])) {
                this.email = [] as any;
                for (let item of _data["email"])
                    this.email.push(item);
            }
            this.isSendLater = _data["isSendLater"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.estimateDate = _data["estimateDate"] ? moment(_data["estimateDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.creditNoteDate = _data["creditNoteDate"] ? moment(_data["creditNoteDate"].toString()) : <any>undefined;
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.purchaseReceiptDate = _data["purchaseReceiptDate"] ? moment(_data["purchaseReceiptDate"].toString()) : <any>undefined;
            this.saleReceiptDate = _data["saleReceiptDate"] ? moment(_data["saleReceiptDate"].toString()) : <any>undefined;
            this.refrenceNo = _data["refrenceNo"];
            this.amountReceived = _data["amountReceived"];
            this.total = _data["total"];
            this.note = _data["note"];
            this.paidAmount = _data["paidAmount"];
            this.refInvoiceStatusID = _data["refInvoiceStatusID"];
            this.isPaid = _data["isPaid"];
            this.isActive = _data["isActive"];
            this.isRecurring = _data["isRecurring"];
            this.frequencyId = _data["frequencyId"];
            this.frequency = _data["frequency"];
            this.durationId = _data["durationId"];
            this.duration = _data["duration"];
            this.invoiceGroupID = _data["invoiceGroupID"];
            this.depositDate = _data["depositDate"] ? moment(_data["depositDate"].toString()) : <any>undefined;
            this.clearanceDate = _data["clearanceDate"] ? moment(_data["clearanceDate"].toString()) : <any>undefined;
            this.checkPrinted = _data["checkPrinted"];
            this.refEmployeeID = _data["refEmployeeID"];
            this.refPaymentTypeID = _data["refPaymentTypeID"];
            this.refCardID = _data["refCardID"];
            this.recurringInvoiceNextCreationDate = _data["recurringInvoiceNextCreationDate"] ? moment(_data["recurringInvoiceNextCreationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails.push(InvoiceDetailDto.fromJS(item));
            }
            (<any>this).refInvoiceStatus = _data["refInvoiceStatus"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoiceNo"] = this.invoiceNo;
        data["refCompanyID"] = this.refCompanyID;
        data["refInvoiceType"] = this.refInvoiceType;
        data["refCustomerID"] = this.refCustomerID;
        data["refSupplierID"] = this.refSupplierID;
        data["refTermID"] = this.refTermID;
        data["refPaymentMethodID"] = this.refPaymentMethodID;
        data["refDepositToAccountID"] = this.refDepositToAccountID;
        data["refCashEquivalentsAccountID"] = this.refCashEquivalentsAccountID;
        if (Array.isArray(this.email)) {
            data["email"] = [];
            for (let item of this.email)
                data["email"].push(item);
        }
        data["isSendLater"] = this.isSendLater;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["estimateDate"] = this.estimateDate ? this.estimateDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["creditNoteDate"] = this.creditNoteDate ? this.creditNoteDate.toISOString() : <any>undefined;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["purchaseReceiptDate"] = this.purchaseReceiptDate ? this.purchaseReceiptDate.toISOString() : <any>undefined;
        data["saleReceiptDate"] = this.saleReceiptDate ? this.saleReceiptDate.toISOString() : <any>undefined;
        data["refrenceNo"] = this.refrenceNo;
        data["amountReceived"] = this.amountReceived;
        data["total"] = this.total;
        data["note"] = this.note;
        data["paidAmount"] = this.paidAmount;
        data["refInvoiceStatusID"] = this.refInvoiceStatusID;
        data["isPaid"] = this.isPaid;
        data["isActive"] = this.isActive;
        data["isRecurring"] = this.isRecurring;
        data["frequencyId"] = this.frequencyId;
        data["frequency"] = this.frequency;
        data["durationId"] = this.durationId;
        data["duration"] = this.duration;
        data["invoiceGroupID"] = this.invoiceGroupID;
        data["depositDate"] = this.depositDate ? this.depositDate.toISOString() : <any>undefined;
        data["clearanceDate"] = this.clearanceDate ? this.clearanceDate.toISOString() : <any>undefined;
        data["checkPrinted"] = this.checkPrinted;
        data["refEmployeeID"] = this.refEmployeeID;
        data["refPaymentTypeID"] = this.refPaymentTypeID;
        data["refCardID"] = this.refCardID;
        data["recurringInvoiceNextCreationDate"] = this.recurringInvoiceNextCreationDate ? this.recurringInvoiceNextCreationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        data["refInvoiceStatus"] = this.refInvoiceStatus;
        return data;
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    refCompanyID: number | undefined;
    refInvoiceType: number | undefined;
    refCustomerID: number | undefined;
    refSupplierID: number | undefined;
    refTermID: number | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountID: number | undefined;
    refCashEquivalentsAccountID: number | undefined;
    email: string[] | undefined;
    isSendLater: boolean | undefined;
    invoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    estimateDate: moment.Moment | undefined;
    expirationDate: moment.Moment | undefined;
    creditNoteDate: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    saleReceiptDate: moment.Moment | undefined;
    refrenceNo: string | undefined;
    amountReceived: number | undefined;
    total: number | undefined;
    note: string | undefined;
    paidAmount: number | undefined;
    refInvoiceStatusID: number | undefined;
    isPaid: boolean | undefined;
    isActive: boolean;
    isRecurring: boolean | undefined;
    frequencyId: number | undefined;
    frequency: string | undefined;
    durationId: number | undefined;
    duration: string | undefined;
    invoiceGroupID: number | undefined;
    depositDate: moment.Moment | undefined;
    clearanceDate: moment.Moment | undefined;
    checkPrinted: boolean | undefined;
    refEmployeeID: number | undefined;
    refPaymentTypeID: number | undefined;
    refCardID: number | undefined;
    recurringInvoiceNextCreationDate: moment.Moment | undefined;
    invoiceDetails: InvoiceDetailDto[] | undefined;
    refInvoiceStatus: number | undefined;
}

export enum InvoiceStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum InvoiceType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string | undefined;
    emailAddress: string | undefined;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    isPaidTenant: boolean;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.isPaidTenant = _data["isPaidTenant"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["isPaidTenant"] = this.isPaidTenant;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    isPaidTenant: boolean;
}

export class JobTitle implements IJobTitle {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IJobTitle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): JobTitle {
        data = typeof data === 'object' ? data : {};
        let result = new JobTitle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): JobTitle {
        const json = this.toJSON();
        let result = new JobTitle();
        result.init(json);
        return result;
    }
}

export interface IJobTitle {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class JobTitleDto implements IJobTitleDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): JobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): JobTitleDto {
        const json = this.toJSON();
        let result = new JobTitleDto();
        result.init(json);
        return result;
    }
}

export interface IJobTitleDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class Language implements ILanguage {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    description: string | undefined;
    companyId: number | undefined;
    company: Company;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): Language {
        const json = this.toJSON();
        let result = new Language();
        result.init(json);
        return result;
    }
}

export interface ILanguage {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    description: string | undefined;
    companyId: number | undefined;
    company: Company;
}

export class LanguageDto implements ILanguageDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    companyId: number | undefined;
    isActive: boolean;
    companyName: string | undefined;

    constructor(data?: ILanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
            this.isActive = _data["isActive"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        data["isActive"] = this.isActive;
        data["companyName"] = this.companyName;
        return data;
    }

    clone(): LanguageDto {
        const json = this.toJSON();
        let result = new LanguageDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    companyId: number | undefined;
    isActive: boolean;
    companyName: string | undefined;
}

export class LedgerHeaders implements ILedgerHeaders {
    id: number;
    customerId: number;
    companyId: number;
    headers: string | undefined;
    ledgerType: string | undefined;

    constructor(data?: ILedgerHeaders) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.companyId = _data["companyId"];
            this.headers = _data["headers"];
            this.ledgerType = _data["ledgerType"];
        }
    }

    static fromJS(data: any): LedgerHeaders {
        data = typeof data === 'object' ? data : {};
        let result = new LedgerHeaders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["companyId"] = this.companyId;
        data["headers"] = this.headers;
        data["ledgerType"] = this.ledgerType;
        return data;
    }

    clone(): LedgerHeaders {
        const json = this.toJSON();
        let result = new LedgerHeaders();
        result.init(json);
        return result;
    }
}

export interface ILedgerHeaders {
    id: number;
    customerId: number;
    companyId: number;
    headers: string | undefined;
    ledgerType: string | undefined;
}

export class LegalStatus implements ILegalStatus {
    id: number;
    name: string | undefined;

    constructor(data?: ILegalStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LegalStatus {
        data = typeof data === 'object' ? data : {};
        let result = new LegalStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): LegalStatus {
        const json = this.toJSON();
        let result = new LegalStatus();
        result.init(json);
        return result;
    }
}

export interface ILegalStatus {
    id: number;
    name: string | undefined;
}

export class MainHead implements IMainHead {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: number;
    accountTypeId: number | undefined;
    accountType: AccountType;

    constructor(data?: IMainHead) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.accountTypeId = _data["accountTypeId"];
            this.accountType = _data["accountType"] ? AccountType.fromJS(_data["accountType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MainHead {
        data = typeof data === 'object' ? data : {};
        let result = new MainHead();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["accountTypeId"] = this.accountTypeId;
        data["accountType"] = this.accountType ? this.accountType.toJSON() : <any>undefined;
        return data;
    }

    clone(): MainHead {
        const json = this.toJSON();
        let result = new MainHead();
        result.init(json);
        return result;
    }
}

export interface IMainHead {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: number;
    accountTypeId: number | undefined;
    accountType: AccountType;
}

export class MainHeadDto implements IMainHeadDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    accountTypeId: number | undefined;
    accountType: string | undefined;

    constructor(data?: IMainHeadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.accountTypeId = _data["accountTypeId"];
            this.accountType = _data["accountType"];
        }
    }

    static fromJS(data: any): MainHeadDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainHeadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["accountTypeId"] = this.accountTypeId;
        data["accountType"] = this.accountType;
        return data;
    }

    clone(): MainHeadDto {
        const json = this.toJSON();
        let result = new MainHeadDto();
        result.init(json);
        return result;
    }
}

export interface IMainHeadDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    accountTypeId: number | undefined;
    accountType: string | undefined;
}

export class MemoryStream implements IMemoryStream {
    readonly canTimeout: boolean;
    readTimeout: number;
    writeTimeout: number;
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    capacity: number;
    readonly length: number;
    position: number;

    constructor(data?: IMemoryStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canTimeout = _data["canTimeout"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canSeek = _data["canSeek"];
            (<any>this).canWrite = _data["canWrite"];
            this.capacity = _data["capacity"];
            (<any>this).length = _data["length"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): MemoryStream {
        data = typeof data === 'object' ? data : {};
        let result = new MemoryStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canTimeout"] = this.canTimeout;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canWrite"] = this.canWrite;
        data["capacity"] = this.capacity;
        data["length"] = this.length;
        data["position"] = this.position;
        return data;
    }

    clone(): MemoryStream {
        const json = this.toJSON();
        let result = new MemoryStream();
        result.init(json);
        return result;
    }
}

export interface IMemoryStream {
    canTimeout: boolean;
    readTimeout: number;
    writeTimeout: number;
    canRead: boolean;
    canSeek: boolean;
    canWrite: boolean;
    capacity: number;
    length: number;
    position: number;
}

export class Merchant implements IMerchant {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    apiKey: string | undefined;
    apiSecretKey: string | undefined;
    token: string | undefined;
    ccmid: string | undefined;
    ccun: string | undefined;
    ccpwd: string | undefined;
    active: boolean;

    constructor(data?: IMerchant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.apiKey = _data["apiKey"];
            this.apiSecretKey = _data["apiSecretKey"];
            this.token = _data["token"];
            this.ccmid = _data["ccmid"];
            this.ccun = _data["ccun"];
            this.ccpwd = _data["ccpwd"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): Merchant {
        data = typeof data === 'object' ? data : {};
        let result = new Merchant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["apiKey"] = this.apiKey;
        data["apiSecretKey"] = this.apiSecretKey;
        data["token"] = this.token;
        data["ccmid"] = this.ccmid;
        data["ccun"] = this.ccun;
        data["ccpwd"] = this.ccpwd;
        data["active"] = this.active;
        return data;
    }

    clone(): Merchant {
        const json = this.toJSON();
        let result = new Merchant();
        result.init(json);
        return result;
    }
}

export interface IMerchant {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    apiKey: string | undefined;
    apiSecretKey: string | undefined;
    token: string | undefined;
    ccmid: string | undefined;
    ccun: string | undefined;
    ccpwd: string | undefined;
    active: boolean;
}

export class PackageDetail implements IPackageDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    price: number;
    isActive: boolean;
    packageTypeId: number | undefined;
    packageType: PackageType;

    constructor(data?: IPackageDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.price = _data["price"];
            this.isActive = _data["isActive"];
            this.packageTypeId = _data["packageTypeId"];
            this.packageType = _data["packageType"] ? PackageType.fromJS(_data["packageType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PackageDetail {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["price"] = this.price;
        data["isActive"] = this.isActive;
        data["packageTypeId"] = this.packageTypeId;
        data["packageType"] = this.packageType ? this.packageType.toJSON() : <any>undefined;
        return data;
    }

    clone(): PackageDetail {
        const json = this.toJSON();
        let result = new PackageDetail();
        result.init(json);
        return result;
    }
}

export interface IPackageDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    price: number;
    isActive: boolean;
    packageTypeId: number | undefined;
    packageType: PackageType;
}

export class PackageType implements IPackageType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    duration: string | undefined;
    note: string | undefined;
    paymentPlanId: number | undefined;
    paymentPlan: PaymentPlan;

    constructor(data?: IPackageType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.duration = _data["duration"];
            this.note = _data["note"];
            this.paymentPlanId = _data["paymentPlanId"];
            this.paymentPlan = _data["paymentPlan"] ? PaymentPlan.fromJS(_data["paymentPlan"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PackageType {
        data = typeof data === 'object' ? data : {};
        let result = new PackageType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["duration"] = this.duration;
        data["note"] = this.note;
        data["paymentPlanId"] = this.paymentPlanId;
        data["paymentPlan"] = this.paymentPlan ? this.paymentPlan.toJSON() : <any>undefined;
        return data;
    }

    clone(): PackageType {
        const json = this.toJSON();
        let result = new PackageType();
        result.init(json);
        return result;
    }
}

export interface IPackageType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    duration: string | undefined;
    note: string | undefined;
    paymentPlanId: number | undefined;
    paymentPlan: PaymentPlan;
}

export class PayeeDto implements IPayeeDto {
    id: string | undefined;
    payeeName: string | undefined;
    payeeType: string | undefined;

    constructor(data?: IPayeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.payeeName = _data["payeeName"];
            this.payeeType = _data["payeeType"];
        }
    }

    static fromJS(data: any): PayeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payeeName"] = this.payeeName;
        data["payeeType"] = this.payeeType;
        return data;
    }

    clone(): PayeeDto {
        const json = this.toJSON();
        let result = new PayeeDto();
        result.init(json);
        return result;
    }
}

export interface IPayeeDto {
    id: string | undefined;
    payeeName: string | undefined;
    payeeType: string | undefined;
}

export enum PaymentPeriodType {
    _1 = 1,
    _7 = 7,
    _30 = 30,
    _365 = 365,
}

export class PaymentPlan implements IPaymentPlan {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    duration: string | undefined;
    note: string | undefined;

    constructor(data?: IPaymentPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): PaymentPlan {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["note"] = this.note;
        return data;
    }

    clone(): PaymentPlan {
        const json = this.toJSON();
        let result = new PaymentPlan();
        result.init(json);
        return result;
    }
}

export interface IPaymentPlan {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    duration: string | undefined;
    note: string | undefined;
}

export class PaymentTermList implements IPaymentTermList {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    days: number | undefined;

    constructor(data?: IPaymentTermList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.days = _data["days"];
        }
    }

    static fromJS(data: any): PaymentTermList {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTermList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["days"] = this.days;
        return data;
    }

    clone(): PaymentTermList {
        const json = this.toJSON();
        let result = new PaymentTermList();
        result.init(json);
        return result;
    }
}

export interface IPaymentTermList {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    days: number | undefined;
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class PersonalTaxDto implements IPersonalTaxDto {
    tenantId: number;
    financialYear: number;
    taxFillingStatus: number;
    form: number;
    tenure: number;
    filerOccupation: string | undefined;
    bankName: string | undefined;
    routingNumber: string | undefined;
    accountNumber: string | undefined;
    filersLicenseNumber: string | undefined;
    issueDate: moment.Moment;
    expiryDate: moment.Moment;
    issueState: number;
    threeDigitCode: number;
    spouseId: number;
    spouse: Spouse;
    dependentIds: number[] | undefined;
    dependents: Dependent[] | undefined;
    incomeDetailIds: number[] | undefined;
    incomeDetails: IncomeDetails[] | undefined;
    customerId: number;
    otherExpense: string | undefined;

    constructor(data?: IPersonalTaxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.financialYear = _data["financialYear"];
            this.taxFillingStatus = _data["taxFillingStatus"];
            this.form = _data["form"];
            this.tenure = _data["tenure"];
            this.filerOccupation = _data["filerOccupation"];
            this.bankName = _data["bankName"];
            this.routingNumber = _data["routingNumber"];
            this.accountNumber = _data["accountNumber"];
            this.filersLicenseNumber = _data["filersLicenseNumber"];
            this.issueDate = _data["issueDate"] ? moment(_data["issueDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.issueState = _data["issueState"];
            this.threeDigitCode = _data["threeDigitCode"];
            this.spouseId = _data["spouseId"];
            this.spouse = _data["spouse"] ? Spouse.fromJS(_data["spouse"]) : <any>undefined;
            if (Array.isArray(_data["dependentIds"])) {
                this.dependentIds = [] as any;
                for (let item of _data["dependentIds"])
                    this.dependentIds.push(item);
            }
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents.push(Dependent.fromJS(item));
            }
            if (Array.isArray(_data["incomeDetailIds"])) {
                this.incomeDetailIds = [] as any;
                for (let item of _data["incomeDetailIds"])
                    this.incomeDetailIds.push(item);
            }
            if (Array.isArray(_data["incomeDetails"])) {
                this.incomeDetails = [] as any;
                for (let item of _data["incomeDetails"])
                    this.incomeDetails.push(IncomeDetails.fromJS(item));
            }
            this.customerId = _data["customerId"];
            this.otherExpense = _data["otherExpense"];
        }
    }

    static fromJS(data: any): PersonalTaxDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalTaxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["financialYear"] = this.financialYear;
        data["taxFillingStatus"] = this.taxFillingStatus;
        data["form"] = this.form;
        data["tenure"] = this.tenure;
        data["filerOccupation"] = this.filerOccupation;
        data["bankName"] = this.bankName;
        data["routingNumber"] = this.routingNumber;
        data["accountNumber"] = this.accountNumber;
        data["filersLicenseNumber"] = this.filersLicenseNumber;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["issueState"] = this.issueState;
        data["threeDigitCode"] = this.threeDigitCode;
        data["spouseId"] = this.spouseId;
        data["spouse"] = this.spouse ? this.spouse.toJSON() : <any>undefined;
        if (Array.isArray(this.dependentIds)) {
            data["dependentIds"] = [];
            for (let item of this.dependentIds)
                data["dependentIds"].push(item);
        }
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item.toJSON());
        }
        if (Array.isArray(this.incomeDetailIds)) {
            data["incomeDetailIds"] = [];
            for (let item of this.incomeDetailIds)
                data["incomeDetailIds"].push(item);
        }
        if (Array.isArray(this.incomeDetails)) {
            data["incomeDetails"] = [];
            for (let item of this.incomeDetails)
                data["incomeDetails"].push(item.toJSON());
        }
        data["customerId"] = this.customerId;
        data["otherExpense"] = this.otherExpense;
        return data;
    }

    clone(): PersonalTaxDto {
        const json = this.toJSON();
        let result = new PersonalTaxDto();
        result.init(json);
        return result;
    }
}

export interface IPersonalTaxDto {
    tenantId: number;
    financialYear: number;
    taxFillingStatus: number;
    form: number;
    tenure: number;
    filerOccupation: string | undefined;
    bankName: string | undefined;
    routingNumber: string | undefined;
    accountNumber: string | undefined;
    filersLicenseNumber: string | undefined;
    issueDate: moment.Moment;
    expiryDate: moment.Moment;
    issueState: number;
    threeDigitCode: number;
    spouseId: number;
    spouse: Spouse;
    dependentIds: number[] | undefined;
    dependents: Dependent[] | undefined;
    incomeDetailIds: number[] | undefined;
    incomeDetails: IncomeDetails[] | undefined;
    customerId: number;
    otherExpense: string | undefined;
}

export class Phone implements IPhone {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    type: PhoneType;
    number: string | undefined;
    isPrimary: boolean;

    constructor(data?: IPhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.number = _data["number"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): Phone {
        data = typeof data === 'object' ? data : {};
        let result = new Phone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["number"] = this.number;
        data["isPrimary"] = this.isPrimary;
        return data;
    }

    clone(): Phone {
        const json = this.toJSON();
        let result = new Phone();
        result.init(json);
        return result;
    }
}

export interface IPhone {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    type: PhoneType;
    number: string | undefined;
    isPrimary: boolean;
}

export class PhoneDto implements IPhoneDto {
    id: number;
    type: PhoneType;
    number: string | undefined;
    isPrimary: boolean;

    constructor(data?: IPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.number = _data["number"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): PhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["number"] = this.number;
        data["isPrimary"] = this.isPrimary;
        return data;
    }

    clone(): PhoneDto {
        const json = this.toJSON();
        let result = new PhoneDto();
        result.init(json);
        return result;
    }
}

export interface IPhoneDto {
    id: number;
    type: PhoneType;
    number: string | undefined;
    isPrimary: boolean;
}

export enum PhoneType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class PrintDetail implements IPrintDetail {
    amount: number | undefined;
    product: string | undefined;
    invoiceId: number | undefined;
    invoiceDetailId: number | undefined;
    productId: number | undefined;
    quantity: number | undefined;
    isPaid: boolean | undefined;
    rate: number | undefined;
    saleTax: number | undefined;
    discount: number | undefined;
    invoiceNo: string | undefined;
    invoiceDueDate: moment.Moment | undefined;
    origionalAmount: number | undefined;
    openBalance: number | undefined;
    refPaymentMethodID: number | undefined;
    description: string | undefined;

    constructor(data?: IPrintDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.product = _data["product"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceDetailId = _data["invoiceDetailId"];
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.isPaid = _data["isPaid"];
            this.rate = _data["rate"];
            this.saleTax = _data["saleTax"];
            this.discount = _data["discount"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.origionalAmount = _data["origionalAmount"];
            this.openBalance = _data["openBalance"];
            this.refPaymentMethodID = _data["refPaymentMethodID"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PrintDetail {
        data = typeof data === 'object' ? data : {};
        let result = new PrintDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["product"] = this.product;
        data["invoiceId"] = this.invoiceId;
        data["invoiceDetailId"] = this.invoiceDetailId;
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["isPaid"] = this.isPaid;
        data["rate"] = this.rate;
        data["saleTax"] = this.saleTax;
        data["discount"] = this.discount;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["origionalAmount"] = this.origionalAmount;
        data["openBalance"] = this.openBalance;
        data["refPaymentMethodID"] = this.refPaymentMethodID;
        data["description"] = this.description;
        return data;
    }

    clone(): PrintDetail {
        const json = this.toJSON();
        let result = new PrintDetail();
        result.init(json);
        return result;
    }
}

export interface IPrintDetail {
    amount: number | undefined;
    product: string | undefined;
    invoiceId: number | undefined;
    invoiceDetailId: number | undefined;
    productId: number | undefined;
    quantity: number | undefined;
    isPaid: boolean | undefined;
    rate: number | undefined;
    saleTax: number | undefined;
    discount: number | undefined;
    invoiceNo: string | undefined;
    invoiceDueDate: moment.Moment | undefined;
    origionalAmount: number | undefined;
    openBalance: number | undefined;
    refPaymentMethodID: number | undefined;
    description: string | undefined;
}

export class PrintDto implements IPrintDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    invoiceDate: moment.Moment | undefined;
    orignalInvoiceNo: string | undefined;
    refrenceNo: string | undefined;
    note: string | undefined;
    csr: string | undefined;
    openBalance: string | undefined;
    companyName: string | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;
    customerEmail: string | undefined;
    customerName: string | undefined;
    customerBussinessName: string | undefined;
    customerAddress: string | undefined;
    customerPhone: string | undefined;
    customerCity: string | undefined;
    customerState: string | undefined;
    customerPostCode: string | undefined;
    customerCountry: string | undefined;
    printDetails: PrintDetail[] | undefined;

    constructor(data?: IPrintDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.orignalInvoiceNo = _data["orignalInvoiceNo"];
            this.refrenceNo = _data["refrenceNo"];
            this.note = _data["note"];
            this.csr = _data["csr"];
            this.openBalance = _data["openBalance"];
            this.companyName = _data["companyName"];
            this.comAddress = _data["comAddress"];
            this.comCity = _data["comCity"];
            this.comState = _data["comState"];
            this.comPostCode = _data["comPostCode"];
            this.comCountry = _data["comCountry"];
            this.comEmail = _data["comEmail"];
            this.comPhone = _data["comPhone"];
            this.customerEmail = _data["customerEmail"];
            this.customerName = _data["customerName"];
            this.customerBussinessName = _data["customerBussinessName"];
            this.customerAddress = _data["customerAddress"];
            this.customerPhone = _data["customerPhone"];
            this.customerCity = _data["customerCity"];
            this.customerState = _data["customerState"];
            this.customerPostCode = _data["customerPostCode"];
            this.customerCountry = _data["customerCountry"];
            if (Array.isArray(_data["printDetails"])) {
                this.printDetails = [] as any;
                for (let item of _data["printDetails"])
                    this.printDetails.push(PrintDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrintDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["orignalInvoiceNo"] = this.orignalInvoiceNo;
        data["refrenceNo"] = this.refrenceNo;
        data["note"] = this.note;
        data["csr"] = this.csr;
        data["openBalance"] = this.openBalance;
        data["companyName"] = this.companyName;
        data["comAddress"] = this.comAddress;
        data["comCity"] = this.comCity;
        data["comState"] = this.comState;
        data["comPostCode"] = this.comPostCode;
        data["comCountry"] = this.comCountry;
        data["comEmail"] = this.comEmail;
        data["comPhone"] = this.comPhone;
        data["customerEmail"] = this.customerEmail;
        data["customerName"] = this.customerName;
        data["customerBussinessName"] = this.customerBussinessName;
        data["customerAddress"] = this.customerAddress;
        data["customerPhone"] = this.customerPhone;
        data["customerCity"] = this.customerCity;
        data["customerState"] = this.customerState;
        data["customerPostCode"] = this.customerPostCode;
        data["customerCountry"] = this.customerCountry;
        if (Array.isArray(this.printDetails)) {
            data["printDetails"] = [];
            for (let item of this.printDetails)
                data["printDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): PrintDto {
        const json = this.toJSON();
        let result = new PrintDto();
        result.init(json);
        return result;
    }
}

export interface IPrintDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    invoiceDate: moment.Moment | undefined;
    orignalInvoiceNo: string | undefined;
    refrenceNo: string | undefined;
    note: string | undefined;
    csr: string | undefined;
    openBalance: string | undefined;
    companyName: string | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;
    customerEmail: string | undefined;
    customerName: string | undefined;
    customerBussinessName: string | undefined;
    customerAddress: string | undefined;
    customerPhone: string | undefined;
    customerCity: string | undefined;
    customerState: string | undefined;
    customerPostCode: string | undefined;
    customerCountry: string | undefined;
    printDetails: PrintDetail[] | undefined;
}

export class ProductCategory implements IProductCategory {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    nature: string | undefined;
    isActive: boolean;
    productCategoryEnum: ProductCategoryEnum;
    companyId: number | undefined;
    company: Company;

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.nature = _data["nature"];
            this.isActive = _data["isActive"];
            this.productCategoryEnum = _data["productCategoryEnum"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["nature"] = this.nature;
        data["isActive"] = this.isActive;
        data["productCategoryEnum"] = this.productCategoryEnum;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductCategory {
        const json = this.toJSON();
        let result = new ProductCategory();
        result.init(json);
        return result;
    }
}

export interface IProductCategory {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    nature: string | undefined;
    isActive: boolean;
    productCategoryEnum: ProductCategoryEnum;
    companyId: number | undefined;
    company: Company;
}

export class ProductCategoryDto implements IProductCategoryDto {
    id: number;
    name: string | undefined;
    nature: string | undefined;
    productCategoryEnum: ProductCategoryEnum;
    isActive: boolean;
    companyId: number | undefined;
    company: Company;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nature = _data["nature"];
            this.productCategoryEnum = _data["productCategoryEnum"];
            this.isActive = _data["isActive"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nature"] = this.nature;
        data["productCategoryEnum"] = this.productCategoryEnum;
        data["isActive"] = this.isActive;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductCategoryDto {
        const json = this.toJSON();
        let result = new ProductCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IProductCategoryDto {
    id: number;
    name: string | undefined;
    nature: string | undefined;
    productCategoryEnum: ProductCategoryEnum;
    isActive: boolean;
    companyId: number | undefined;
    company: Company;
}

export enum ProductCategoryEnum {
    _0 = 0,
    _1 = 1,
}

export class ProductService implements IProductService {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    typeId: number | undefined;
    salePrice: number;
    saleTax: string | undefined;
    expenseSaleTax: string | undefined;
    fromSalePrice: moment.Moment | undefined;
    toSalePrice: moment.Moment | undefined;
    fromCostPrice: moment.Moment | undefined;
    toCostPrice: moment.Moment | undefined;
    incomeAccountId: number | undefined;
    expenseAccountId: number | undefined;
    costPrice: number;
    saleInformation: string | undefined;
    automaticExpense: boolean | undefined;
    sku: string | undefined;
    isActive: boolean;
    advanceSaleTaxAccountId: number | undefined;
    liabilityAccountId: number | undefined;
    vendorId: number | undefined;
    vendor: Vendor;
    productCategoryId: number | undefined;
    productCategory: ProductCategory;

    constructor(data?: IProductService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.salePrice = _data["salePrice"];
            this.saleTax = _data["saleTax"];
            this.expenseSaleTax = _data["expenseSaleTax"];
            this.fromSalePrice = _data["fromSalePrice"] ? moment(_data["fromSalePrice"].toString()) : <any>undefined;
            this.toSalePrice = _data["toSalePrice"] ? moment(_data["toSalePrice"].toString()) : <any>undefined;
            this.fromCostPrice = _data["fromCostPrice"] ? moment(_data["fromCostPrice"].toString()) : <any>undefined;
            this.toCostPrice = _data["toCostPrice"] ? moment(_data["toCostPrice"].toString()) : <any>undefined;
            this.incomeAccountId = _data["incomeAccountId"];
            this.expenseAccountId = _data["expenseAccountId"];
            this.costPrice = _data["costPrice"];
            this.saleInformation = _data["saleInformation"];
            this.automaticExpense = _data["automaticExpense"];
            this.sku = _data["sku"];
            this.isActive = _data["isActive"];
            this.advanceSaleTaxAccountId = _data["advanceSaleTaxAccountId"];
            this.liabilityAccountId = _data["liabilityAccountId"];
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? Vendor.fromJS(_data["vendor"]) : <any>undefined;
            this.productCategoryId = _data["productCategoryId"];
            this.productCategory = _data["productCategory"] ? ProductCategory.fromJS(_data["productCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductService {
        data = typeof data === 'object' ? data : {};
        let result = new ProductService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["salePrice"] = this.salePrice;
        data["saleTax"] = this.saleTax;
        data["expenseSaleTax"] = this.expenseSaleTax;
        data["fromSalePrice"] = this.fromSalePrice ? this.fromSalePrice.toISOString() : <any>undefined;
        data["toSalePrice"] = this.toSalePrice ? this.toSalePrice.toISOString() : <any>undefined;
        data["fromCostPrice"] = this.fromCostPrice ? this.fromCostPrice.toISOString() : <any>undefined;
        data["toCostPrice"] = this.toCostPrice ? this.toCostPrice.toISOString() : <any>undefined;
        data["incomeAccountId"] = this.incomeAccountId;
        data["expenseAccountId"] = this.expenseAccountId;
        data["costPrice"] = this.costPrice;
        data["saleInformation"] = this.saleInformation;
        data["automaticExpense"] = this.automaticExpense;
        data["sku"] = this.sku;
        data["isActive"] = this.isActive;
        data["advanceSaleTaxAccountId"] = this.advanceSaleTaxAccountId;
        data["liabilityAccountId"] = this.liabilityAccountId;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["productCategoryId"] = this.productCategoryId;
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProductService {
        const json = this.toJSON();
        let result = new ProductService();
        result.init(json);
        return result;
    }
}

export interface IProductService {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    typeId: number | undefined;
    salePrice: number;
    saleTax: string | undefined;
    expenseSaleTax: string | undefined;
    fromSalePrice: moment.Moment | undefined;
    toSalePrice: moment.Moment | undefined;
    fromCostPrice: moment.Moment | undefined;
    toCostPrice: moment.Moment | undefined;
    incomeAccountId: number | undefined;
    expenseAccountId: number | undefined;
    costPrice: number;
    saleInformation: string | undefined;
    automaticExpense: boolean | undefined;
    sku: string | undefined;
    isActive: boolean;
    advanceSaleTaxAccountId: number | undefined;
    liabilityAccountId: number | undefined;
    vendorId: number | undefined;
    vendor: Vendor;
    productCategoryId: number | undefined;
    productCategory: ProductCategory;
}

export class ProductServiceDto implements IProductServiceDto {
    id: number;
    name: string | undefined;
    incomeAccountId: number | undefined;
    fromSalePrice: moment.Moment | undefined;
    toSalePrice: moment.Moment | undefined;
    fromCostPrice: moment.Moment | undefined;
    toCostPrice: moment.Moment | undefined;
    expenseAccountId: number | undefined;
    typeId: number | undefined;
    salePrice: number;
    saleTax: string | undefined;
    expenseSaleTax: string | undefined;
    costPrice: number;
    saleInformation: string | undefined;
    automaticExpense: boolean | undefined;
    sku: string | undefined;
    venderName: string | undefined;
    productCaterogyName: string | undefined;
    isActive: boolean;
    vendorId: number | undefined;
    advanceSaleTaxAccountId: number | undefined;
    liabilityAccountId: number | undefined;
    productCategoryId: number | undefined;

    constructor(data?: IProductServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.incomeAccountId = _data["incomeAccountId"];
            this.fromSalePrice = _data["fromSalePrice"] ? moment(_data["fromSalePrice"].toString()) : <any>undefined;
            this.toSalePrice = _data["toSalePrice"] ? moment(_data["toSalePrice"].toString()) : <any>undefined;
            this.fromCostPrice = _data["fromCostPrice"] ? moment(_data["fromCostPrice"].toString()) : <any>undefined;
            this.toCostPrice = _data["toCostPrice"] ? moment(_data["toCostPrice"].toString()) : <any>undefined;
            this.expenseAccountId = _data["expenseAccountId"];
            this.typeId = _data["typeId"];
            this.salePrice = _data["salePrice"];
            this.saleTax = _data["saleTax"];
            this.expenseSaleTax = _data["expenseSaleTax"];
            this.costPrice = _data["costPrice"];
            this.saleInformation = _data["saleInformation"];
            this.automaticExpense = _data["automaticExpense"];
            this.sku = _data["sku"];
            this.venderName = _data["venderName"];
            this.productCaterogyName = _data["productCaterogyName"];
            this.isActive = _data["isActive"];
            this.vendorId = _data["vendorId"];
            this.advanceSaleTaxAccountId = _data["advanceSaleTaxAccountId"];
            this.liabilityAccountId = _data["liabilityAccountId"];
            this.productCategoryId = _data["productCategoryId"];
        }
    }

    static fromJS(data: any): ProductServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["incomeAccountId"] = this.incomeAccountId;
        data["fromSalePrice"] = this.fromSalePrice ? this.fromSalePrice.toISOString() : <any>undefined;
        data["toSalePrice"] = this.toSalePrice ? this.toSalePrice.toISOString() : <any>undefined;
        data["fromCostPrice"] = this.fromCostPrice ? this.fromCostPrice.toISOString() : <any>undefined;
        data["toCostPrice"] = this.toCostPrice ? this.toCostPrice.toISOString() : <any>undefined;
        data["expenseAccountId"] = this.expenseAccountId;
        data["typeId"] = this.typeId;
        data["salePrice"] = this.salePrice;
        data["saleTax"] = this.saleTax;
        data["expenseSaleTax"] = this.expenseSaleTax;
        data["costPrice"] = this.costPrice;
        data["saleInformation"] = this.saleInformation;
        data["automaticExpense"] = this.automaticExpense;
        data["sku"] = this.sku;
        data["venderName"] = this.venderName;
        data["productCaterogyName"] = this.productCaterogyName;
        data["isActive"] = this.isActive;
        data["vendorId"] = this.vendorId;
        data["advanceSaleTaxAccountId"] = this.advanceSaleTaxAccountId;
        data["liabilityAccountId"] = this.liabilityAccountId;
        data["productCategoryId"] = this.productCategoryId;
        return data;
    }

    clone(): ProductServiceDto {
        const json = this.toJSON();
        let result = new ProductServiceDto();
        result.init(json);
        return result;
    }
}

export interface IProductServiceDto {
    id: number;
    name: string | undefined;
    incomeAccountId: number | undefined;
    fromSalePrice: moment.Moment | undefined;
    toSalePrice: moment.Moment | undefined;
    fromCostPrice: moment.Moment | undefined;
    toCostPrice: moment.Moment | undefined;
    expenseAccountId: number | undefined;
    typeId: number | undefined;
    salePrice: number;
    saleTax: string | undefined;
    expenseSaleTax: string | undefined;
    costPrice: number;
    saleInformation: string | undefined;
    automaticExpense: boolean | undefined;
    sku: string | undefined;
    venderName: string | undefined;
    productCaterogyName: string | undefined;
    isActive: boolean;
    vendorId: number | undefined;
    advanceSaleTaxAccountId: number | undefined;
    liabilityAccountId: number | undefined;
    productCategoryId: number | undefined;
}

export class PurchaseInvoiceAccountDto implements IPurchaseInvoiceAccountDto {
    invoiceDetailID: number;
    refInvoiceID: number | undefined;
    refPaidInvoiceID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;

    constructor(data?: IPurchaseInvoiceAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceDetailID = _data["invoiceDetailID"];
            this.refInvoiceID = _data["refInvoiceID"];
            this.refPaidInvoiceID = _data["refPaidInvoiceID"];
            this.refChartOfAccountID = _data["refChartOfAccountID"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.paidAmount = _data["paidAmount"];
            this.isPaid = _data["isPaid"];
            this.refCustomerID = _data["refCustomerID"];
        }
    }

    static fromJS(data: any): PurchaseInvoiceAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseInvoiceAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceDetailID"] = this.invoiceDetailID;
        data["refInvoiceID"] = this.refInvoiceID;
        data["refPaidInvoiceID"] = this.refPaidInvoiceID;
        data["refChartOfAccountID"] = this.refChartOfAccountID;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["paidAmount"] = this.paidAmount;
        data["isPaid"] = this.isPaid;
        data["refCustomerID"] = this.refCustomerID;
        return data;
    }

    clone(): PurchaseInvoiceAccountDto {
        const json = this.toJSON();
        let result = new PurchaseInvoiceAccountDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseInvoiceAccountDto {
    invoiceDetailID: number;
    refInvoiceID: number | undefined;
    refPaidInvoiceID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;
}

export class PurchaseInvoiceDto implements IPurchaseInvoiceDto {
    invoiceDetailID: number;
    refInvoiceID: number | undefined;
    refPaidInvoiceID: number | undefined;
    refProducID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;

    constructor(data?: IPurchaseInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceDetailID = _data["invoiceDetailID"];
            this.refInvoiceID = _data["refInvoiceID"];
            this.refPaidInvoiceID = _data["refPaidInvoiceID"];
            this.refProducID = _data["refProducID"];
            this.refChartOfAccountID = _data["refChartOfAccountID"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.discount = _data["discount"];
            this.saleTax = _data["saleTax"];
            this.amount = _data["amount"];
            this.paidAmount = _data["paidAmount"];
            this.isPaid = _data["isPaid"];
            this.refCustomerID = _data["refCustomerID"];
        }
    }

    static fromJS(data: any): PurchaseInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceDetailID"] = this.invoiceDetailID;
        data["refInvoiceID"] = this.refInvoiceID;
        data["refPaidInvoiceID"] = this.refPaidInvoiceID;
        data["refProducID"] = this.refProducID;
        data["refChartOfAccountID"] = this.refChartOfAccountID;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["discount"] = this.discount;
        data["saleTax"] = this.saleTax;
        data["amount"] = this.amount;
        data["paidAmount"] = this.paidAmount;
        data["isPaid"] = this.isPaid;
        data["refCustomerID"] = this.refCustomerID;
        return data;
    }

    clone(): PurchaseInvoiceDto {
        const json = this.toJSON();
        let result = new PurchaseInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseInvoiceDto {
    invoiceDetailID: number;
    refInvoiceID: number | undefined;
    refPaidInvoiceID: number | undefined;
    refProducID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;
}

export class ReceviedPayment implements IReceviedPayment {
    invoiceID: number | undefined;
    splitInvoiceID: number | undefined;
    invoiceNo: string | undefined;
    isCheck: boolean | undefined;
    invoiceDueDate: moment.Moment | undefined;
    origionalAmount: number | undefined;
    openBalance: number | undefined;
    paymentDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refrenceNo: string | undefined;
    email: string | undefined;
    isSendLater: boolean | undefined;
    isPaid: boolean | undefined;
    customerEmail: string | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refCompanyID: number | undefined;
    companyName: string | undefined;
    refSupplierID: number | undefined;
    refPaidInvoiceID: number | undefined;
    refDepositToAccountID: number | undefined;
    total: number | undefined;
    note: string | undefined;
    product: string | undefined;
    producIDs: string | undefined;
    description: string | undefined;
    refProducID: number | undefined;
    invoiceDetailId: number | undefined;
    refPaidInvoiceId: number | undefined;
    rP_Invoice: string | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;
    customerName: string | undefined;

    constructor(data?: IReceviedPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceID = _data["invoiceID"];
            this.splitInvoiceID = _data["splitInvoiceID"];
            this.invoiceNo = _data["invoiceNo"];
            this.isCheck = _data["isCheck"];
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.origionalAmount = _data["origionalAmount"];
            this.openBalance = _data["openBalance"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.refPaymentMethodID = _data["refPaymentMethodID"];
            this.refrenceNo = _data["refrenceNo"];
            this.email = _data["email"];
            this.isSendLater = _data["isSendLater"];
            this.isPaid = _data["isPaid"];
            this.customerEmail = _data["customerEmail"];
            this.paidAmount = _data["paidAmount"];
            this.refCustomerID = _data["refCustomerID"];
            this.refCompanyID = _data["refCompanyID"];
            this.companyName = _data["companyName"];
            this.refSupplierID = _data["refSupplierID"];
            this.refPaidInvoiceID = _data["refPaidInvoiceID"];
            this.refDepositToAccountID = _data["refDepositToAccountID"];
            this.total = _data["total"];
            this.note = _data["note"];
            this.product = _data["product"];
            this.producIDs = _data["producIDs"];
            this.description = _data["description"];
            this.refProducID = _data["refProducID"];
            this.invoiceDetailId = _data["invoiceDetailId"];
            this.refPaidInvoiceId = _data["refPaidInvoiceId"];
            this.rP_Invoice = _data["rP_Invoice"];
            this.comAddress = _data["comAddress"];
            this.comCity = _data["comCity"];
            this.comState = _data["comState"];
            this.comPostCode = _data["comPostCode"];
            this.comCountry = _data["comCountry"];
            this.comEmail = _data["comEmail"];
            this.comPhone = _data["comPhone"];
            this.customerName = _data["customerName"];
        }
    }

    static fromJS(data: any): ReceviedPayment {
        data = typeof data === 'object' ? data : {};
        let result = new ReceviedPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceID"] = this.invoiceID;
        data["splitInvoiceID"] = this.splitInvoiceID;
        data["invoiceNo"] = this.invoiceNo;
        data["isCheck"] = this.isCheck;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["origionalAmount"] = this.origionalAmount;
        data["openBalance"] = this.openBalance;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["refPaymentMethodID"] = this.refPaymentMethodID;
        data["refrenceNo"] = this.refrenceNo;
        data["email"] = this.email;
        data["isSendLater"] = this.isSendLater;
        data["isPaid"] = this.isPaid;
        data["customerEmail"] = this.customerEmail;
        data["paidAmount"] = this.paidAmount;
        data["refCustomerID"] = this.refCustomerID;
        data["refCompanyID"] = this.refCompanyID;
        data["companyName"] = this.companyName;
        data["refSupplierID"] = this.refSupplierID;
        data["refPaidInvoiceID"] = this.refPaidInvoiceID;
        data["refDepositToAccountID"] = this.refDepositToAccountID;
        data["total"] = this.total;
        data["note"] = this.note;
        data["product"] = this.product;
        data["producIDs"] = this.producIDs;
        data["description"] = this.description;
        data["refProducID"] = this.refProducID;
        data["invoiceDetailId"] = this.invoiceDetailId;
        data["refPaidInvoiceId"] = this.refPaidInvoiceId;
        data["rP_Invoice"] = this.rP_Invoice;
        data["comAddress"] = this.comAddress;
        data["comCity"] = this.comCity;
        data["comState"] = this.comState;
        data["comPostCode"] = this.comPostCode;
        data["comCountry"] = this.comCountry;
        data["comEmail"] = this.comEmail;
        data["comPhone"] = this.comPhone;
        data["customerName"] = this.customerName;
        return data;
    }

    clone(): ReceviedPayment {
        const json = this.toJSON();
        let result = new ReceviedPayment();
        result.init(json);
        return result;
    }
}

export interface IReceviedPayment {
    invoiceID: number | undefined;
    splitInvoiceID: number | undefined;
    invoiceNo: string | undefined;
    isCheck: boolean | undefined;
    invoiceDueDate: moment.Moment | undefined;
    origionalAmount: number | undefined;
    openBalance: number | undefined;
    paymentDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refrenceNo: string | undefined;
    email: string | undefined;
    isSendLater: boolean | undefined;
    isPaid: boolean | undefined;
    customerEmail: string | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refCompanyID: number | undefined;
    companyName: string | undefined;
    refSupplierID: number | undefined;
    refPaidInvoiceID: number | undefined;
    refDepositToAccountID: number | undefined;
    total: number | undefined;
    note: string | undefined;
    product: string | undefined;
    producIDs: string | undefined;
    description: string | undefined;
    refProducID: number | undefined;
    invoiceDetailId: number | undefined;
    refPaidInvoiceId: number | undefined;
    rP_Invoice: string | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;
    customerName: string | undefined;
}

export class RecurringInvoice implements IRecurringInvoice {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    customerId: number;
    durationId: number;
    frequencyId: number;
    durationDateTill: moment.Moment | undefined;
    durationAmount: number | undefined;
    executedAmount: number | undefined;
    frequencyCustomDate: moment.Moment | undefined;
    frequencyEveryDayCount: number | undefined;
    frequencyWeek: number | undefined;
    frequencyMonth: number | undefined;
    frequencyAnnualDate: moment.Moment | undefined;
    invoiceData: string | undefined;
    tenantId: number;
    lastExecution: moment.Moment;
    sendMail: boolean;
    customerCardId: number;

    constructor(data?: IRecurringInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.durationId = _data["durationId"];
            this.frequencyId = _data["frequencyId"];
            this.durationDateTill = _data["durationDateTill"] ? moment(_data["durationDateTill"].toString()) : <any>undefined;
            this.durationAmount = _data["durationAmount"];
            this.executedAmount = _data["executedAmount"];
            this.frequencyCustomDate = _data["frequencyCustomDate"] ? moment(_data["frequencyCustomDate"].toString()) : <any>undefined;
            this.frequencyEveryDayCount = _data["frequencyEveryDayCount"];
            this.frequencyWeek = _data["frequencyWeek"];
            this.frequencyMonth = _data["frequencyMonth"];
            this.frequencyAnnualDate = _data["frequencyAnnualDate"] ? moment(_data["frequencyAnnualDate"].toString()) : <any>undefined;
            this.invoiceData = _data["invoiceData"];
            this.tenantId = _data["tenantId"];
            this.lastExecution = _data["lastExecution"] ? moment(_data["lastExecution"].toString()) : <any>undefined;
            this.sendMail = _data["sendMail"];
            this.customerCardId = _data["customerCardId"];
        }
    }

    static fromJS(data: any): RecurringInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new RecurringInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["durationId"] = this.durationId;
        data["frequencyId"] = this.frequencyId;
        data["durationDateTill"] = this.durationDateTill ? this.durationDateTill.toISOString() : <any>undefined;
        data["durationAmount"] = this.durationAmount;
        data["executedAmount"] = this.executedAmount;
        data["frequencyCustomDate"] = this.frequencyCustomDate ? this.frequencyCustomDate.toISOString() : <any>undefined;
        data["frequencyEveryDayCount"] = this.frequencyEveryDayCount;
        data["frequencyWeek"] = this.frequencyWeek;
        data["frequencyMonth"] = this.frequencyMonth;
        data["frequencyAnnualDate"] = this.frequencyAnnualDate ? this.frequencyAnnualDate.toISOString() : <any>undefined;
        data["invoiceData"] = this.invoiceData;
        data["tenantId"] = this.tenantId;
        data["lastExecution"] = this.lastExecution ? this.lastExecution.toISOString() : <any>undefined;
        data["sendMail"] = this.sendMail;
        data["customerCardId"] = this.customerCardId;
        return data;
    }

    clone(): RecurringInvoice {
        const json = this.toJSON();
        let result = new RecurringInvoice();
        result.init(json);
        return result;
    }
}

export interface IRecurringInvoice {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    customerId: number;
    durationId: number;
    frequencyId: number;
    durationDateTill: moment.Moment | undefined;
    durationAmount: number | undefined;
    executedAmount: number | undefined;
    frequencyCustomDate: moment.Moment | undefined;
    frequencyEveryDayCount: number | undefined;
    frequencyWeek: number | undefined;
    frequencyMonth: number | undefined;
    frequencyAnnualDate: moment.Moment | undefined;
    invoiceData: string | undefined;
    tenantId: number;
    lastExecution: moment.Moment;
    sendMail: boolean;
    customerCardId: number;
}

export class RecurringInvoiceDetailDto implements IRecurringInvoiceDetailDto {
    id: number;
    refPaidInvoiceID: number | undefined;
    refProducID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;
    invoiceId: number | undefined;
    discountAmount: number | undefined;

    constructor(data?: IRecurringInvoiceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.refPaidInvoiceID = _data["refPaidInvoiceID"];
            this.refProducID = _data["refProducID"];
            this.refChartOfAccountID = _data["refChartOfAccountID"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.rate = _data["rate"];
            this.discount = _data["discount"];
            this.saleTax = _data["saleTax"];
            this.amount = _data["amount"];
            this.paidAmount = _data["paidAmount"];
            this.isPaid = _data["isPaid"];
            this.refCustomerID = _data["refCustomerID"];
            this.invoiceId = _data["invoiceId"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): RecurringInvoiceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecurringInvoiceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["refPaidInvoiceID"] = this.refPaidInvoiceID;
        data["refProducID"] = this.refProducID;
        data["refChartOfAccountID"] = this.refChartOfAccountID;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["discount"] = this.discount;
        data["saleTax"] = this.saleTax;
        data["amount"] = this.amount;
        data["paidAmount"] = this.paidAmount;
        data["isPaid"] = this.isPaid;
        data["refCustomerID"] = this.refCustomerID;
        data["invoiceId"] = this.invoiceId;
        data["discountAmount"] = this.discountAmount;
        return data;
    }

    clone(): RecurringInvoiceDetailDto {
        const json = this.toJSON();
        let result = new RecurringInvoiceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IRecurringInvoiceDetailDto {
    id: number;
    refPaidInvoiceID: number | undefined;
    refProducID: number | undefined;
    refChartOfAccountID: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    discount: number | undefined;
    saleTax: number | undefined;
    amount: number | undefined;
    paidAmount: number | undefined;
    isPaid: boolean | undefined;
    refCustomerID: number | undefined;
    invoiceId: number | undefined;
    discountAmount: number | undefined;
}

export class RecurringInvoiceDto implements IRecurringInvoiceDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    customerId: number;
    durationId: number;
    frequencyId: number;
    durationDateTill: moment.Moment | undefined;
    durationAmount: number | undefined;
    executedAmount: number | undefined;
    frequencyCustomDate: moment.Moment | undefined;
    frequencyEveryDayCount: number | undefined;
    frequencyWeek: number | undefined;
    frequencyMonth: number | undefined;
    frequencyAnnualDate: moment.Moment | undefined;
    invoiceData: string | undefined;
    tenantId: number;
    lastExecution: moment.Moment;
    sendMail: boolean;
    customerCardId: number;

    constructor(data?: IRecurringInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.durationId = _data["durationId"];
            this.frequencyId = _data["frequencyId"];
            this.durationDateTill = _data["durationDateTill"] ? moment(_data["durationDateTill"].toString()) : <any>undefined;
            this.durationAmount = _data["durationAmount"];
            this.executedAmount = _data["executedAmount"];
            this.frequencyCustomDate = _data["frequencyCustomDate"] ? moment(_data["frequencyCustomDate"].toString()) : <any>undefined;
            this.frequencyEveryDayCount = _data["frequencyEveryDayCount"];
            this.frequencyWeek = _data["frequencyWeek"];
            this.frequencyMonth = _data["frequencyMonth"];
            this.frequencyAnnualDate = _data["frequencyAnnualDate"] ? moment(_data["frequencyAnnualDate"].toString()) : <any>undefined;
            this.invoiceData = _data["invoiceData"];
            this.tenantId = _data["tenantId"];
            this.lastExecution = _data["lastExecution"] ? moment(_data["lastExecution"].toString()) : <any>undefined;
            this.sendMail = _data["sendMail"];
            this.customerCardId = _data["customerCardId"];
        }
    }

    static fromJS(data: any): RecurringInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecurringInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["durationId"] = this.durationId;
        data["frequencyId"] = this.frequencyId;
        data["durationDateTill"] = this.durationDateTill ? this.durationDateTill.toISOString() : <any>undefined;
        data["durationAmount"] = this.durationAmount;
        data["executedAmount"] = this.executedAmount;
        data["frequencyCustomDate"] = this.frequencyCustomDate ? this.frequencyCustomDate.toISOString() : <any>undefined;
        data["frequencyEveryDayCount"] = this.frequencyEveryDayCount;
        data["frequencyWeek"] = this.frequencyWeek;
        data["frequencyMonth"] = this.frequencyMonth;
        data["frequencyAnnualDate"] = this.frequencyAnnualDate ? this.frequencyAnnualDate.toISOString() : <any>undefined;
        data["invoiceData"] = this.invoiceData;
        data["tenantId"] = this.tenantId;
        data["lastExecution"] = this.lastExecution ? this.lastExecution.toISOString() : <any>undefined;
        data["sendMail"] = this.sendMail;
        data["customerCardId"] = this.customerCardId;
        return data;
    }

    clone(): RecurringInvoiceDto {
        const json = this.toJSON();
        let result = new RecurringInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IRecurringInvoiceDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    customerId: number;
    durationId: number;
    frequencyId: number;
    durationDateTill: moment.Moment | undefined;
    durationAmount: number | undefined;
    executedAmount: number | undefined;
    frequencyCustomDate: moment.Moment | undefined;
    frequencyEveryDayCount: number | undefined;
    frequencyWeek: number | undefined;
    frequencyMonth: number | undefined;
    frequencyAnnualDate: moment.Moment | undefined;
    invoiceData: string | undefined;
    tenantId: number;
    lastExecution: moment.Moment;
    sendMail: boolean;
    customerCardId: number;
}

export class RegisterInput implements IRegisterInput {
    name: string | undefined;
    companyName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: number;
    noofusers: string | undefined;
    isAccept: boolean;
    storagelim: string | undefined;
    fiscalYearStart: moment.Moment;
    fiscalYearEnd: moment.Moment;
    twowayauthentication: boolean;
    surname: string | undefined;
    address: string | undefined;
    zip_code: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.companyName = _data["companyName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.noofusers = _data["noofusers"];
            this.isAccept = _data["isAccept"];
            this.storagelim = _data["storagelim"];
            this.fiscalYearStart = _data["fiscalYearStart"] ? moment(_data["fiscalYearStart"].toString()) : <any>undefined;
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? moment(_data["fiscalYearEnd"].toString()) : <any>undefined;
            this.twowayauthentication = _data["twowayauthentication"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.zip_code = _data["zip_code"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["companyName"] = this.companyName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["noofusers"] = this.noofusers;
        data["isAccept"] = this.isAccept;
        data["storagelim"] = this.storagelim;
        data["fiscalYearStart"] = this.fiscalYearStart ? this.fiscalYearStart.toISOString() : <any>undefined;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toISOString() : <any>undefined;
        data["twowayauthentication"] = this.twowayauthentication;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["zip_code"] = this.zip_code;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string | undefined;
    companyName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: number;
    noofusers: string | undefined;
    isAccept: boolean;
    storagelim: string | undefined;
    fiscalYearStart: moment.Moment;
    fiscalYearEnd: moment.Moment;
    twowayauthentication: boolean;
    surname: string | undefined;
    address: string | undefined;
    zip_code: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class RegisterTenantInputDto implements IRegisterTenantInputDto {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    suffix: string | undefined;
    adminPhoneNumber: string | undefined;
    phoneNo: string | undefined;
    noOfUsers: number;
    storagelimit: number;
    fiscalYearStart: moment.Moment;
    fiscalYearEnd: moment.Moment;
    address: string | undefined;
    isAccept: boolean;
    zip_code: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
    isCustomEdition: boolean;
    paymentPeriodType: PaymentPeriodType;
    isTwoFactorEnabled: boolean;
    varifiedPhoneNo: string | undefined;

    constructor(data?: IRegisterTenantInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.suffix = _data["suffix"];
            this.adminPhoneNumber = _data["adminPhoneNumber"];
            this.phoneNo = _data["phoneNo"];
            this.noOfUsers = _data["noOfUsers"];
            this.storagelimit = _data["storagelimit"];
            this.fiscalYearStart = _data["fiscalYearStart"] ? moment(_data["fiscalYearStart"].toString()) : <any>undefined;
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? moment(_data["fiscalYearEnd"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.isAccept = _data["isAccept"];
            this.zip_code = _data["zip_code"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.adminPassword = _data["adminPassword"];
            this.captchaResponse = _data["captchaResponse"];
            this.subscriptionStartType = _data["subscriptionStartType"];
            this.editionId = _data["editionId"];
            this.isCustomEdition = _data["isCustomEdition"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.varifiedPhoneNo = _data["varifiedPhoneNo"];
        }
    }

    static fromJS(data: any): RegisterTenantInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["suffix"] = this.suffix;
        data["adminPhoneNumber"] = this.adminPhoneNumber;
        data["phoneNo"] = this.phoneNo;
        data["noOfUsers"] = this.noOfUsers;
        data["storagelimit"] = this.storagelimit;
        data["fiscalYearStart"] = this.fiscalYearStart ? this.fiscalYearStart.toISOString() : <any>undefined;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["isAccept"] = this.isAccept;
        data["zip_code"] = this.zip_code;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        data["isCustomEdition"] = this.isCustomEdition;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["varifiedPhoneNo"] = this.varifiedPhoneNo;
        return data;
    }

    clone(): RegisterTenantInputDto {
        const json = this.toJSON();
        let result = new RegisterTenantInputDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantInputDto {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    suffix: string | undefined;
    adminPhoneNumber: string | undefined;
    phoneNo: string | undefined;
    noOfUsers: number;
    storagelimit: number;
    fiscalYearStart: moment.Moment;
    fiscalYearEnd: moment.Moment;
    address: string | undefined;
    isAccept: boolean;
    zip_code: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
    isCustomEdition: boolean;
    paymentPeriodType: PaymentPeriodType;
    isTwoFactorEnabled: boolean;
    varifiedPhoneNo: string | undefined;
}

export class RegisterTenantoutputDto implements IRegisterTenantoutputDto {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;

    constructor(data?: IRegisterTenantoutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isTenantActive = _data["isTenantActive"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantoutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantoutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data;
    }

    clone(): RegisterTenantoutputDto {
        const json = this.toJSON();
        let result = new RegisterTenantoutputDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantoutputDto {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data;
    }

    clone(): ResolveTenantIdInput {
        const json = this.toJSON();
        let result = new ResolveTenantIdInput();
        result.init(json);
        return result;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    grantedPermissions: string[] | undefined;
    ipRestriction: boolean;
    ipAddress: string | undefined;
    isActive: boolean;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.ipRestriction = _data["ipRestriction"];
            this.ipAddress = _data["ipAddress"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["ipRestriction"] = this.ipRestriction;
        data["ipAddress"] = this.ipAddress;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    grantedPermissions: string[] | undefined;
    ipRestriction: boolean;
    ipAddress: string | undefined;
    isActive: boolean;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    ipRestriction: boolean;
    ipAddress: string[] | undefined;
    isActive: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.ipRestriction = _data["ipRestriction"];
            if (Array.isArray(_data["ipAddress"])) {
                this.ipAddress = [] as any;
                for (let item of _data["ipAddress"])
                    this.ipAddress.push(item);
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["ipRestriction"] = this.ipRestriction;
        if (Array.isArray(this.ipAddress)) {
            data["ipAddress"] = [];
            for (let item of this.ipAddress)
                data["ipAddress"].push(item);
        }
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    ipRestriction: boolean;
    ipAddress: string[] | undefined;
    isActive: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class SalesPersonType implements ISalesPersonType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;
    phoneId: number;
    phone: Phone;
    companyId: number | undefined;
    company: Company;

    constructor(data?: ISalesPersonType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.completeAddress = _data["completeAddress"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postCode = _data["postCode"];
            this.fax = _data["fax"];
            this.type = _data["type"];
            this.isPrimary = _data["isPrimary"];
            this.phoneId = _data["phoneId"];
            this.phone = _data["phone"] ? Phone.fromJS(_data["phone"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SalesPersonType {
        data = typeof data === 'object' ? data : {};
        let result = new SalesPersonType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["completeAddress"] = this.completeAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postCode"] = this.postCode;
        data["fax"] = this.fax;
        data["type"] = this.type;
        data["isPrimary"] = this.isPrimary;
        data["phoneId"] = this.phoneId;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): SalesPersonType {
        const json = this.toJSON();
        let result = new SalesPersonType();
        result.init(json);
        return result;
    }
}

export interface ISalesPersonType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    completeAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postCode: string | undefined;
    fax: string | undefined;
    type: string | undefined;
    isPrimary: boolean;
    phoneId: number;
    phone: Phone;
    companyId: number | undefined;
    company: Company;
}

export class SalesPersonTypeDto implements ISalesPersonTypeDto {
    id: number;
    name: string | undefined;
    email: string | undefined;
    code: string | undefined;
    isActive: boolean;
    phoneId: number;
    addressId: number;
    compeleteAddress: string | undefined;
    companyId: number | undefined;
    phoneNumber: string | undefined;
    phone: Phone;
    address: Address;

    constructor(data?: ISalesPersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.phoneId = _data["phoneId"];
            this.addressId = _data["addressId"];
            this.compeleteAddress = _data["compeleteAddress"];
            this.companyId = _data["companyId"];
            this.phoneNumber = _data["phoneNumber"];
            this.phone = _data["phone"] ? Phone.fromJS(_data["phone"]) : <any>undefined;
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SalesPersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesPersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["phoneId"] = this.phoneId;
        data["addressId"] = this.addressId;
        data["compeleteAddress"] = this.compeleteAddress;
        data["companyId"] = this.companyId;
        data["phoneNumber"] = this.phoneNumber;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): SalesPersonTypeDto {
        const json = this.toJSON();
        let result = new SalesPersonTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISalesPersonTypeDto {
    id: number;
    name: string | undefined;
    email: string | undefined;
    code: string | undefined;
    isActive: boolean;
    phoneId: number;
    addressId: number;
    compeleteAddress: string | undefined;
    companyId: number | undefined;
    phoneNumber: string | undefined;
    phone: Phone;
    address: Address;
}

export class SalesReceiptDto implements ISalesReceiptDto {
    id: number | undefined;
    invoiceNo: string | undefined;
    tenantId: number;
    invoiceId: number | undefined;
    refCompanyID: number | undefined;
    refInvoiceType: number | undefined;
    refCustomerID: number | undefined;
    refSupplierID: number | undefined;
    refTermID: number | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountID: number | undefined;
    refCashEquivalentsAccountID: number | undefined;
    email: string[] | undefined;
    isSendLater: boolean | undefined;
    invoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    estimateDate: moment.Moment | undefined;
    expirationDate: moment.Moment | undefined;
    creditNoteDate: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    saleReceiptDate: moment.Moment | undefined;
    refrenceNo: string | undefined;
    amountReceived: number | undefined;
    total: number | undefined;
    note: string | undefined;
    paidAmount: number | undefined;
    refInvoiceStatusID: number | undefined;
    isPaid: boolean | undefined;
    isActive: boolean;
    isRecurring: boolean | undefined;
    frequencyId: number | undefined;
    frequency: string | undefined;
    durationId: number | undefined;
    duration: string | undefined;
    invoiceGroupID: number | undefined;
    depositDate: moment.Moment | undefined;
    clearanceDate: moment.Moment | undefined;
    checkPrinted: boolean | undefined;
    refEmployeeID: number | undefined;
    refPaymentTypeID: number | undefined;
    refCardID: number | undefined;
    recurringInvoiceNextCreationDate: moment.Moment | undefined;
    chargeCard: ChargeCardDto;
    invoiceDetails: InvoiceDetailDto[] | undefined;

    constructor(data?: ISalesReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceNo = _data["invoiceNo"];
            this.tenantId = _data["tenantId"];
            this.invoiceId = _data["invoiceId"];
            this.refCompanyID = _data["refCompanyID"];
            this.refInvoiceType = _data["refInvoiceType"];
            this.refCustomerID = _data["refCustomerID"];
            this.refSupplierID = _data["refSupplierID"];
            this.refTermID = _data["refTermID"];
            this.refPaymentMethodID = _data["refPaymentMethodID"];
            this.refDepositToAccountID = _data["refDepositToAccountID"];
            this.refCashEquivalentsAccountID = _data["refCashEquivalentsAccountID"];
            if (Array.isArray(_data["email"])) {
                this.email = [] as any;
                for (let item of _data["email"])
                    this.email.push(item);
            }
            this.isSendLater = _data["isSendLater"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.estimateDate = _data["estimateDate"] ? moment(_data["estimateDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.creditNoteDate = _data["creditNoteDate"] ? moment(_data["creditNoteDate"].toString()) : <any>undefined;
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.purchaseReceiptDate = _data["purchaseReceiptDate"] ? moment(_data["purchaseReceiptDate"].toString()) : <any>undefined;
            this.saleReceiptDate = _data["saleReceiptDate"] ? moment(_data["saleReceiptDate"].toString()) : <any>undefined;
            this.refrenceNo = _data["refrenceNo"];
            this.amountReceived = _data["amountReceived"];
            this.total = _data["total"];
            this.note = _data["note"];
            this.paidAmount = _data["paidAmount"];
            this.refInvoiceStatusID = _data["refInvoiceStatusID"];
            this.isPaid = _data["isPaid"];
            this.isActive = _data["isActive"];
            this.isRecurring = _data["isRecurring"];
            this.frequencyId = _data["frequencyId"];
            this.frequency = _data["frequency"];
            this.durationId = _data["durationId"];
            this.duration = _data["duration"];
            this.invoiceGroupID = _data["invoiceGroupID"];
            this.depositDate = _data["depositDate"] ? moment(_data["depositDate"].toString()) : <any>undefined;
            this.clearanceDate = _data["clearanceDate"] ? moment(_data["clearanceDate"].toString()) : <any>undefined;
            this.checkPrinted = _data["checkPrinted"];
            this.refEmployeeID = _data["refEmployeeID"];
            this.refPaymentTypeID = _data["refPaymentTypeID"];
            this.refCardID = _data["refCardID"];
            this.recurringInvoiceNextCreationDate = _data["recurringInvoiceNextCreationDate"] ? moment(_data["recurringInvoiceNextCreationDate"].toString()) : <any>undefined;
            this.chargeCard = _data["chargeCard"] ? ChargeCardDto.fromJS(_data["chargeCard"]) : <any>undefined;
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails.push(InvoiceDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceNo"] = this.invoiceNo;
        data["tenantId"] = this.tenantId;
        data["invoiceId"] = this.invoiceId;
        data["refCompanyID"] = this.refCompanyID;
        data["refInvoiceType"] = this.refInvoiceType;
        data["refCustomerID"] = this.refCustomerID;
        data["refSupplierID"] = this.refSupplierID;
        data["refTermID"] = this.refTermID;
        data["refPaymentMethodID"] = this.refPaymentMethodID;
        data["refDepositToAccountID"] = this.refDepositToAccountID;
        data["refCashEquivalentsAccountID"] = this.refCashEquivalentsAccountID;
        if (Array.isArray(this.email)) {
            data["email"] = [];
            for (let item of this.email)
                data["email"].push(item);
        }
        data["isSendLater"] = this.isSendLater;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["estimateDate"] = this.estimateDate ? this.estimateDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["creditNoteDate"] = this.creditNoteDate ? this.creditNoteDate.toISOString() : <any>undefined;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["purchaseReceiptDate"] = this.purchaseReceiptDate ? this.purchaseReceiptDate.toISOString() : <any>undefined;
        data["saleReceiptDate"] = this.saleReceiptDate ? this.saleReceiptDate.toISOString() : <any>undefined;
        data["refrenceNo"] = this.refrenceNo;
        data["amountReceived"] = this.amountReceived;
        data["total"] = this.total;
        data["note"] = this.note;
        data["paidAmount"] = this.paidAmount;
        data["refInvoiceStatusID"] = this.refInvoiceStatusID;
        data["isPaid"] = this.isPaid;
        data["isActive"] = this.isActive;
        data["isRecurring"] = this.isRecurring;
        data["frequencyId"] = this.frequencyId;
        data["frequency"] = this.frequency;
        data["durationId"] = this.durationId;
        data["duration"] = this.duration;
        data["invoiceGroupID"] = this.invoiceGroupID;
        data["depositDate"] = this.depositDate ? this.depositDate.toISOString() : <any>undefined;
        data["clearanceDate"] = this.clearanceDate ? this.clearanceDate.toISOString() : <any>undefined;
        data["checkPrinted"] = this.checkPrinted;
        data["refEmployeeID"] = this.refEmployeeID;
        data["refPaymentTypeID"] = this.refPaymentTypeID;
        data["refCardID"] = this.refCardID;
        data["recurringInvoiceNextCreationDate"] = this.recurringInvoiceNextCreationDate ? this.recurringInvoiceNextCreationDate.toISOString() : <any>undefined;
        data["chargeCard"] = this.chargeCard ? this.chargeCard.toJSON() : <any>undefined;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): SalesReceiptDto {
        const json = this.toJSON();
        let result = new SalesReceiptDto();
        result.init(json);
        return result;
    }
}

export interface ISalesReceiptDto {
    id: number | undefined;
    invoiceNo: string | undefined;
    tenantId: number;
    invoiceId: number | undefined;
    refCompanyID: number | undefined;
    refInvoiceType: number | undefined;
    refCustomerID: number | undefined;
    refSupplierID: number | undefined;
    refTermID: number | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountID: number | undefined;
    refCashEquivalentsAccountID: number | undefined;
    email: string[] | undefined;
    isSendLater: boolean | undefined;
    invoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    estimateDate: moment.Moment | undefined;
    expirationDate: moment.Moment | undefined;
    creditNoteDate: moment.Moment | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    saleReceiptDate: moment.Moment | undefined;
    refrenceNo: string | undefined;
    amountReceived: number | undefined;
    total: number | undefined;
    note: string | undefined;
    paidAmount: number | undefined;
    refInvoiceStatusID: number | undefined;
    isPaid: boolean | undefined;
    isActive: boolean;
    isRecurring: boolean | undefined;
    frequencyId: number | undefined;
    frequency: string | undefined;
    durationId: number | undefined;
    duration: string | undefined;
    invoiceGroupID: number | undefined;
    depositDate: moment.Moment | undefined;
    clearanceDate: moment.Moment | undefined;
    checkPrinted: boolean | undefined;
    refEmployeeID: number | undefined;
    refPaymentTypeID: number | undefined;
    refCardID: number | undefined;
    recurringInvoiceNextCreationDate: moment.Moment | undefined;
    chargeCard: ChargeCardDto;
    invoiceDetails: InvoiceDetailDto[] | undefined;
}

export class SalesTaxDto implements ISalesTaxDto {
    id: number;
    tenantId: number;
    financialYear: string | undefined;
    legalStatus: number | undefined;
    tenureForm: number;
    totalMonthlyAmount: number;
    nonTaxableAmount: number;
    taxableSales: number;
    salesTaxAmount: number;
    salesRatePercentage: number;
    taxDataMonthly: string | undefined;
    customerId: number;

    constructor(data?: ISalesTaxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.financialYear = _data["financialYear"];
            this.legalStatus = _data["legalStatus"];
            this.tenureForm = _data["tenureForm"];
            this.totalMonthlyAmount = _data["totalMonthlyAmount"];
            this.nonTaxableAmount = _data["nonTaxableAmount"];
            this.taxableSales = _data["taxableSales"];
            this.salesTaxAmount = _data["salesTaxAmount"];
            this.salesRatePercentage = _data["salesRatePercentage"];
            this.taxDataMonthly = _data["taxDataMonthly"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): SalesTaxDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesTaxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["financialYear"] = this.financialYear;
        data["legalStatus"] = this.legalStatus;
        data["tenureForm"] = this.tenureForm;
        data["totalMonthlyAmount"] = this.totalMonthlyAmount;
        data["nonTaxableAmount"] = this.nonTaxableAmount;
        data["taxableSales"] = this.taxableSales;
        data["salesTaxAmount"] = this.salesTaxAmount;
        data["salesRatePercentage"] = this.salesRatePercentage;
        data["taxDataMonthly"] = this.taxDataMonthly;
        data["customerId"] = this.customerId;
        return data;
    }

    clone(): SalesTaxDto {
        const json = this.toJSON();
        let result = new SalesTaxDto();
        result.init(json);
        return result;
    }
}

export interface ISalesTaxDto {
    id: number;
    tenantId: number;
    financialYear: string | undefined;
    legalStatus: number | undefined;
    tenureForm: number;
    totalMonthlyAmount: number;
    nonTaxableAmount: number;
    taxableSales: number;
    salesTaxAmount: number;
    salesRatePercentage: number;
    taxDataMonthly: string | undefined;
    customerId: number;
}

export class SaveCreditNoteDto implements ISaveCreditNoteDto {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceID: number | undefined;
    invoiceNo: string | undefined;
    paymentDate: moment.Moment | undefined;
    isSendLater: boolean | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountId: number | undefined;
    refInvoiceType: number | undefined;
    refInvoiceStatus: number | undefined;
    creditNoteDate: moment.Moment | undefined;
    refCashEquivalentsAccountId: number | undefined;
    refSupplierId: number | undefined;
    refVendorId: number | undefined;
    referenceNo: string | undefined;
    emails: string[] | undefined;
    total: number | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refCompanyID: number | undefined;
    refPaymentTypeId: number | undefined;
    ve: number | undefined;
    note: string | undefined;
    creditNoteDto: RecurringInvoiceDetailDto[] | undefined;
    chargeCard: ChargeCardDto;

    constructor(data?: ISaveCreditNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.invoiceID = _data["invoiceID"];
            this.invoiceNo = _data["invoiceNo"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.isSendLater = _data["isSendLater"];
            this.purchaseReceiptDate = _data["purchaseReceiptDate"] ? moment(_data["purchaseReceiptDate"].toString()) : <any>undefined;
            this.refPaymentMethodID = _data["refPaymentMethodID"];
            this.refDepositToAccountId = _data["refDepositToAccountId"];
            this.refInvoiceType = _data["refInvoiceType"];
            this.refInvoiceStatus = _data["refInvoiceStatus"];
            this.creditNoteDate = _data["creditNoteDate"] ? moment(_data["creditNoteDate"].toString()) : <any>undefined;
            this.refCashEquivalentsAccountId = _data["refCashEquivalentsAccountId"];
            this.refSupplierId = _data["refSupplierId"];
            this.refVendorId = _data["refVendorId"];
            this.referenceNo = _data["referenceNo"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails.push(item);
            }
            this.total = _data["total"];
            this.paidAmount = _data["paidAmount"];
            this.refCustomerID = _data["refCustomerID"];
            this.refCompanyID = _data["refCompanyID"];
            this.refPaymentTypeId = _data["refPaymentTypeId"];
            this.ve = _data["ve"];
            this.note = _data["note"];
            if (Array.isArray(_data["creditNoteDto"])) {
                this.creditNoteDto = [] as any;
                for (let item of _data["creditNoteDto"])
                    this.creditNoteDto.push(RecurringInvoiceDetailDto.fromJS(item));
            }
            this.chargeCard = _data["chargeCard"] ? ChargeCardDto.fromJS(_data["chargeCard"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaveCreditNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveCreditNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["invoiceID"] = this.invoiceID;
        data["invoiceNo"] = this.invoiceNo;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["isSendLater"] = this.isSendLater;
        data["purchaseReceiptDate"] = this.purchaseReceiptDate ? this.purchaseReceiptDate.toISOString() : <any>undefined;
        data["refPaymentMethodID"] = this.refPaymentMethodID;
        data["refDepositToAccountId"] = this.refDepositToAccountId;
        data["refInvoiceType"] = this.refInvoiceType;
        data["refInvoiceStatus"] = this.refInvoiceStatus;
        data["creditNoteDate"] = this.creditNoteDate ? this.creditNoteDate.toISOString() : <any>undefined;
        data["refCashEquivalentsAccountId"] = this.refCashEquivalentsAccountId;
        data["refSupplierId"] = this.refSupplierId;
        data["refVendorId"] = this.refVendorId;
        data["referenceNo"] = this.referenceNo;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        data["total"] = this.total;
        data["paidAmount"] = this.paidAmount;
        data["refCustomerID"] = this.refCustomerID;
        data["refCompanyID"] = this.refCompanyID;
        data["refPaymentTypeId"] = this.refPaymentTypeId;
        data["ve"] = this.ve;
        data["note"] = this.note;
        if (Array.isArray(this.creditNoteDto)) {
            data["creditNoteDto"] = [];
            for (let item of this.creditNoteDto)
                data["creditNoteDto"].push(item.toJSON());
        }
        data["chargeCard"] = this.chargeCard ? this.chargeCard.toJSON() : <any>undefined;
        return data;
    }

    clone(): SaveCreditNoteDto {
        const json = this.toJSON();
        let result = new SaveCreditNoteDto();
        result.init(json);
        return result;
    }
}

export interface ISaveCreditNoteDto {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceID: number | undefined;
    invoiceNo: string | undefined;
    paymentDate: moment.Moment | undefined;
    isSendLater: boolean | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountId: number | undefined;
    refInvoiceType: number | undefined;
    refInvoiceStatus: number | undefined;
    creditNoteDate: moment.Moment | undefined;
    refCashEquivalentsAccountId: number | undefined;
    refSupplierId: number | undefined;
    refVendorId: number | undefined;
    referenceNo: string | undefined;
    emails: string[] | undefined;
    total: number | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refCompanyID: number | undefined;
    refPaymentTypeId: number | undefined;
    ve: number | undefined;
    note: string | undefined;
    creditNoteDto: RecurringInvoiceDetailDto[] | undefined;
    chargeCard: ChargeCardDto;
}

export class SaveJournalVouchers implements ISaveJournalVouchers {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceDate: moment.Moment | undefined;
    refInvoiceType: string | undefined;
    note: string | undefined;
    voucherDetails: VoucherDetailDto[] | undefined;

    constructor(data?: ISaveJournalVouchers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.refInvoiceType = _data["refInvoiceType"];
            this.note = _data["note"];
            if (Array.isArray(_data["voucherDetails"])) {
                this.voucherDetails = [] as any;
                for (let item of _data["voucherDetails"])
                    this.voucherDetails.push(VoucherDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveJournalVouchers {
        data = typeof data === 'object' ? data : {};
        let result = new SaveJournalVouchers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["refInvoiceType"] = this.refInvoiceType;
        data["note"] = this.note;
        if (Array.isArray(this.voucherDetails)) {
            data["voucherDetails"] = [];
            for (let item of this.voucherDetails)
                data["voucherDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): SaveJournalVouchers {
        const json = this.toJSON();
        let result = new SaveJournalVouchers();
        result.init(json);
        return result;
    }
}

export interface ISaveJournalVouchers {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceDate: moment.Moment | undefined;
    refInvoiceType: string | undefined;
    note: string | undefined;
    voucherDetails: VoucherDetailDto[] | undefined;
}

export class SavePurchaseInvoice implements ISavePurchaseInvoice {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceId: number | undefined;
    vendorId: number | undefined;
    refNo: string | undefined;
    refTermID: number | undefined;
    note: string | undefined;
    total: number | undefined;
    purchaseInvoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    purchaseInvoice: PurchaseInvoiceDto[] | undefined;
    purchaseInvoiceAccount: PurchaseInvoiceAccountDto[] | undefined;
    invoiceNo: string | undefined;

    constructor(data?: ISavePurchaseInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.vendorId = _data["vendorId"];
            this.refNo = _data["refNo"];
            this.refTermID = _data["refTermID"];
            this.note = _data["note"];
            this.total = _data["total"];
            this.purchaseInvoiceDate = _data["purchaseInvoiceDate"] ? moment(_data["purchaseInvoiceDate"].toString()) : <any>undefined;
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["purchaseInvoice"])) {
                this.purchaseInvoice = [] as any;
                for (let item of _data["purchaseInvoice"])
                    this.purchaseInvoice.push(PurchaseInvoiceDto.fromJS(item));
            }
            if (Array.isArray(_data["purchaseInvoiceAccount"])) {
                this.purchaseInvoiceAccount = [] as any;
                for (let item of _data["purchaseInvoiceAccount"])
                    this.purchaseInvoiceAccount.push(PurchaseInvoiceAccountDto.fromJS(item));
            }
            this.invoiceNo = _data["invoiceNo"];
        }
    }

    static fromJS(data: any): SavePurchaseInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new SavePurchaseInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["vendorId"] = this.vendorId;
        data["refNo"] = this.refNo;
        data["refTermID"] = this.refTermID;
        data["note"] = this.note;
        data["total"] = this.total;
        data["purchaseInvoiceDate"] = this.purchaseInvoiceDate ? this.purchaseInvoiceDate.toISOString() : <any>undefined;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        if (Array.isArray(this.purchaseInvoice)) {
            data["purchaseInvoice"] = [];
            for (let item of this.purchaseInvoice)
                data["purchaseInvoice"].push(item.toJSON());
        }
        if (Array.isArray(this.purchaseInvoiceAccount)) {
            data["purchaseInvoiceAccount"] = [];
            for (let item of this.purchaseInvoiceAccount)
                data["purchaseInvoiceAccount"].push(item.toJSON());
        }
        data["invoiceNo"] = this.invoiceNo;
        return data;
    }

    clone(): SavePurchaseInvoice {
        const json = this.toJSON();
        let result = new SavePurchaseInvoice();
        result.init(json);
        return result;
    }
}

export interface ISavePurchaseInvoice {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceId: number | undefined;
    vendorId: number | undefined;
    refNo: string | undefined;
    refTermID: number | undefined;
    note: string | undefined;
    total: number | undefined;
    purchaseInvoiceDate: moment.Moment | undefined;
    invoiceDueDate: moment.Moment | undefined;
    purchaseInvoice: PurchaseInvoiceDto[] | undefined;
    purchaseInvoiceAccount: PurchaseInvoiceAccountDto[] | undefined;
    invoiceNo: string | undefined;
}

export class SavePurchaseReceiptDto implements ISavePurchaseReceiptDto {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceID: number | undefined;
    invoiceNo: string | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountId: number | undefined;
    refInvoiceType: number | undefined;
    refInvoiceStatus: number | undefined;
    refCashEquivalentsAccountId: number | undefined;
    refSupplierId: number | undefined;
    refVendorId: number | undefined;
    referenceNo: string | undefined;
    emails: string[] | undefined;
    total: number | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refCompanyID: number | undefined;
    refPaymentTypeId: number | undefined;
    checkNo: number | undefined;
    note: string | undefined;
    puchaseReceiptDto: RecurringInvoiceDetailDto[] | undefined;
    chargeCard: ChargeCardDto;

    constructor(data?: ISavePurchaseReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.invoiceID = _data["invoiceID"];
            this.invoiceNo = _data["invoiceNo"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.purchaseReceiptDate = _data["purchaseReceiptDate"] ? moment(_data["purchaseReceiptDate"].toString()) : <any>undefined;
            this.refPaymentMethodID = _data["refPaymentMethodID"];
            this.refDepositToAccountId = _data["refDepositToAccountId"];
            this.refInvoiceType = _data["refInvoiceType"];
            this.refInvoiceStatus = _data["refInvoiceStatus"];
            this.refCashEquivalentsAccountId = _data["refCashEquivalentsAccountId"];
            this.refSupplierId = _data["refSupplierId"];
            this.refVendorId = _data["refVendorId"];
            this.referenceNo = _data["referenceNo"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails.push(item);
            }
            this.total = _data["total"];
            this.paidAmount = _data["paidAmount"];
            this.refCustomerID = _data["refCustomerID"];
            this.refCompanyID = _data["refCompanyID"];
            this.refPaymentTypeId = _data["refPaymentTypeId"];
            this.checkNo = _data["checkNo"];
            this.note = _data["note"];
            if (Array.isArray(_data["puchaseReceiptDto"])) {
                this.puchaseReceiptDto = [] as any;
                for (let item of _data["puchaseReceiptDto"])
                    this.puchaseReceiptDto.push(RecurringInvoiceDetailDto.fromJS(item));
            }
            this.chargeCard = _data["chargeCard"] ? ChargeCardDto.fromJS(_data["chargeCard"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SavePurchaseReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new SavePurchaseReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["invoiceID"] = this.invoiceID;
        data["invoiceNo"] = this.invoiceNo;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["purchaseReceiptDate"] = this.purchaseReceiptDate ? this.purchaseReceiptDate.toISOString() : <any>undefined;
        data["refPaymentMethodID"] = this.refPaymentMethodID;
        data["refDepositToAccountId"] = this.refDepositToAccountId;
        data["refInvoiceType"] = this.refInvoiceType;
        data["refInvoiceStatus"] = this.refInvoiceStatus;
        data["refCashEquivalentsAccountId"] = this.refCashEquivalentsAccountId;
        data["refSupplierId"] = this.refSupplierId;
        data["refVendorId"] = this.refVendorId;
        data["referenceNo"] = this.referenceNo;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        data["total"] = this.total;
        data["paidAmount"] = this.paidAmount;
        data["refCustomerID"] = this.refCustomerID;
        data["refCompanyID"] = this.refCompanyID;
        data["refPaymentTypeId"] = this.refPaymentTypeId;
        data["checkNo"] = this.checkNo;
        data["note"] = this.note;
        if (Array.isArray(this.puchaseReceiptDto)) {
            data["puchaseReceiptDto"] = [];
            for (let item of this.puchaseReceiptDto)
                data["puchaseReceiptDto"].push(item.toJSON());
        }
        data["chargeCard"] = this.chargeCard ? this.chargeCard.toJSON() : <any>undefined;
        return data;
    }

    clone(): SavePurchaseReceiptDto {
        const json = this.toJSON();
        let result = new SavePurchaseReceiptDto();
        result.init(json);
        return result;
    }
}

export interface ISavePurchaseReceiptDto {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceID: number | undefined;
    invoiceNo: string | undefined;
    paymentDate: moment.Moment | undefined;
    purchaseReceiptDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountId: number | undefined;
    refInvoiceType: number | undefined;
    refInvoiceStatus: number | undefined;
    refCashEquivalentsAccountId: number | undefined;
    refSupplierId: number | undefined;
    refVendorId: number | undefined;
    referenceNo: string | undefined;
    emails: string[] | undefined;
    total: number | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refCompanyID: number | undefined;
    refPaymentTypeId: number | undefined;
    checkNo: number | undefined;
    note: string | undefined;
    puchaseReceiptDto: RecurringInvoiceDetailDto[] | undefined;
    chargeCard: ChargeCardDto;
}

export class SaveReceivedPayment implements ISaveReceivedPayment {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceID: number | undefined;
    isSendLater: boolean | undefined;
    invoiceNo: string | undefined;
    paymentDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountId: number | undefined;
    refInvoiceType: number | undefined;
    refInvoiceStatus: number | undefined;
    referenceNo: string | undefined;
    emails: string[] | undefined;
    total: number | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refSupplierID: number | undefined;
    refCompanyID: number | undefined;
    refPaymentTypeId: number | undefined;
    note: string | undefined;
    receivedPayments: ReceviedPayment[] | undefined;
    chargeCard: ChargeCardDto;

    constructor(data?: ISaveReceivedPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.invoiceID = _data["invoiceID"];
            this.isSendLater = _data["isSendLater"];
            this.invoiceNo = _data["invoiceNo"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.refPaymentMethodID = _data["refPaymentMethodID"];
            this.refDepositToAccountId = _data["refDepositToAccountId"];
            this.refInvoiceType = _data["refInvoiceType"];
            this.refInvoiceStatus = _data["refInvoiceStatus"];
            this.referenceNo = _data["referenceNo"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails.push(item);
            }
            this.total = _data["total"];
            this.paidAmount = _data["paidAmount"];
            this.refCustomerID = _data["refCustomerID"];
            this.refSupplierID = _data["refSupplierID"];
            this.refCompanyID = _data["refCompanyID"];
            this.refPaymentTypeId = _data["refPaymentTypeId"];
            this.note = _data["note"];
            if (Array.isArray(_data["receivedPayments"])) {
                this.receivedPayments = [] as any;
                for (let item of _data["receivedPayments"])
                    this.receivedPayments.push(ReceviedPayment.fromJS(item));
            }
            this.chargeCard = _data["chargeCard"] ? ChargeCardDto.fromJS(_data["chargeCard"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaveReceivedPayment {
        data = typeof data === 'object' ? data : {};
        let result = new SaveReceivedPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["invoiceID"] = this.invoiceID;
        data["isSendLater"] = this.isSendLater;
        data["invoiceNo"] = this.invoiceNo;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["refPaymentMethodID"] = this.refPaymentMethodID;
        data["refDepositToAccountId"] = this.refDepositToAccountId;
        data["refInvoiceType"] = this.refInvoiceType;
        data["refInvoiceStatus"] = this.refInvoiceStatus;
        data["referenceNo"] = this.referenceNo;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        data["total"] = this.total;
        data["paidAmount"] = this.paidAmount;
        data["refCustomerID"] = this.refCustomerID;
        data["refSupplierID"] = this.refSupplierID;
        data["refCompanyID"] = this.refCompanyID;
        data["refPaymentTypeId"] = this.refPaymentTypeId;
        data["note"] = this.note;
        if (Array.isArray(this.receivedPayments)) {
            data["receivedPayments"] = [];
            for (let item of this.receivedPayments)
                data["receivedPayments"].push(item.toJSON());
        }
        data["chargeCard"] = this.chargeCard ? this.chargeCard.toJSON() : <any>undefined;
        return data;
    }

    clone(): SaveReceivedPayment {
        const json = this.toJSON();
        let result = new SaveReceivedPayment();
        result.init(json);
        return result;
    }
}

export interface ISaveReceivedPayment {
    id: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    invoiceID: number | undefined;
    isSendLater: boolean | undefined;
    invoiceNo: string | undefined;
    paymentDate: moment.Moment | undefined;
    refPaymentMethodID: number | undefined;
    refDepositToAccountId: number | undefined;
    refInvoiceType: number | undefined;
    refInvoiceStatus: number | undefined;
    referenceNo: string | undefined;
    emails: string[] | undefined;
    total: number | undefined;
    paidAmount: number | undefined;
    refCustomerID: number | undefined;
    refSupplierID: number | undefined;
    refCompanyID: number | undefined;
    refPaymentTypeId: number | undefined;
    note: string | undefined;
    receivedPayments: ReceviedPayment[] | undefined;
    chargeCard: ChargeCardDto;
}

export class Setting implements ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
}

export class SourceReferalDto implements ISourceReferalDto {
    id: number;
    appLog: string | undefined;
    logDate: moment.Moment | undefined;
    operation: string | undefined;
    employeeName: string | undefined;
    customerName: string | undefined;
    company: string | undefined;
    customerNo: number | undefined;
    companyName: string | undefined;
    userName: string | undefined;
    userId: number;
    sourceReferalNAme: string | undefined;
    creditAmount: number;
    transactionDate: moment.Moment | undefined;

    constructor(data?: ISourceReferalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appLog = _data["appLog"];
            this.logDate = _data["logDate"] ? moment(_data["logDate"].toString()) : <any>undefined;
            this.operation = _data["operation"];
            this.employeeName = _data["employeeName"];
            this.customerName = _data["customerName"];
            this.company = _data["company"];
            this.customerNo = _data["customerNo"];
            this.companyName = _data["companyName"];
            this.userName = _data["userName"];
            this.userId = _data["userId"];
            this.sourceReferalNAme = _data["sourceReferalNAme"];
            this.creditAmount = _data["creditAmount"];
            this.transactionDate = _data["transactionDate"] ? moment(_data["transactionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SourceReferalDto {
        data = typeof data === 'object' ? data : {};
        let result = new SourceReferalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appLog"] = this.appLog;
        data["logDate"] = this.logDate ? this.logDate.toISOString() : <any>undefined;
        data["operation"] = this.operation;
        data["employeeName"] = this.employeeName;
        data["customerName"] = this.customerName;
        data["company"] = this.company;
        data["customerNo"] = this.customerNo;
        data["companyName"] = this.companyName;
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        data["sourceReferalNAme"] = this.sourceReferalNAme;
        data["creditAmount"] = this.creditAmount;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): SourceReferalDto {
        const json = this.toJSON();
        let result = new SourceReferalDto();
        result.init(json);
        return result;
    }
}

export interface ISourceReferalDto {
    id: number;
    appLog: string | undefined;
    logDate: moment.Moment | undefined;
    operation: string | undefined;
    employeeName: string | undefined;
    customerName: string | undefined;
    company: string | undefined;
    customerNo: number | undefined;
    companyName: string | undefined;
    userName: string | undefined;
    userId: number;
    sourceReferalNAme: string | undefined;
    creditAmount: number;
    transactionDate: moment.Moment | undefined;
}

export class SourceReferralType implements ISourceReferralType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    emailId: number;
    email: Email;
    phoneId: number;
    phone: Phone;
    addressId: number;
    address: Address;
    companyId: number | undefined;
    company: Company;

    constructor(data?: ISourceReferralType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.emailId = _data["emailId"];
            this.email = _data["email"] ? Email.fromJS(_data["email"]) : <any>undefined;
            this.phoneId = _data["phoneId"];
            this.phone = _data["phone"] ? Phone.fromJS(_data["phone"]) : <any>undefined;
            this.addressId = _data["addressId"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SourceReferralType {
        data = typeof data === 'object' ? data : {};
        let result = new SourceReferralType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["emailId"] = this.emailId;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["phoneId"] = this.phoneId;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): SourceReferralType {
        const json = this.toJSON();
        let result = new SourceReferralType();
        result.init(json);
        return result;
    }
}

export interface ISourceReferralType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    emailId: number;
    email: Email;
    phoneId: number;
    phone: Phone;
    addressId: number;
    address: Address;
    companyId: number | undefined;
    company: Company;
}

export class SourceReferralTypeDto implements ISourceReferralTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    emailId: number;
    phoneId: number;
    addressId: number;
    companyId: number | undefined;
    addressData: string | undefined;
    phoneData: string | undefined;
    emailAddress: string | undefined;
    company: string | undefined;
    email: CreateOrEditEmailInputDto;
    phone: CreateOrEditPhoneDto;
    address: CreateOrEditAddressDto;

    constructor(data?: ISourceReferralTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.emailId = _data["emailId"];
            this.phoneId = _data["phoneId"];
            this.addressId = _data["addressId"];
            this.companyId = _data["companyId"];
            this.addressData = _data["addressData"];
            this.phoneData = _data["phoneData"];
            this.emailAddress = _data["emailAddress"];
            this.company = _data["company"];
            this.email = _data["email"] ? CreateOrEditEmailInputDto.fromJS(_data["email"]) : <any>undefined;
            this.phone = _data["phone"] ? CreateOrEditPhoneDto.fromJS(_data["phone"]) : <any>undefined;
            this.address = _data["address"] ? CreateOrEditAddressDto.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SourceReferralTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SourceReferralTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["emailId"] = this.emailId;
        data["phoneId"] = this.phoneId;
        data["addressId"] = this.addressId;
        data["companyId"] = this.companyId;
        data["addressData"] = this.addressData;
        data["phoneData"] = this.phoneData;
        data["emailAddress"] = this.emailAddress;
        data["company"] = this.company;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): SourceReferralTypeDto {
        const json = this.toJSON();
        let result = new SourceReferralTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISourceReferralTypeDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
    emailId: number;
    phoneId: number;
    addressId: number;
    companyId: number | undefined;
    addressData: string | undefined;
    phoneData: string | undefined;
    emailAddress: string | undefined;
    company: string | undefined;
    email: CreateOrEditEmailInputDto;
    phone: CreateOrEditPhoneDto;
    address: CreateOrEditAddressDto;
}

export class Spouse implements ISpouse {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    spouseJobDescription: string | undefined;
    occupation: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    dlState: number | undefined;
    code: number | undefined;
    spouseSuffix: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    isActive: boolean;
    jobTitleId: number | undefined;
    jobTitle: JobTitle;
    companyId: number | undefined;
    company: Company;
    ethnicityId: number | undefined;
    ethnicity: Ethnicity;
    languageId: number | undefined;
    language: Language;

    constructor(data?: ISpouse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.ssn = _data["ssn"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.spouseJobDescription = _data["spouseJobDescription"];
            this.occupation = _data["occupation"];
            this.drivingLicense = _data["drivingLicense"];
            this.dlIssue = _data["dlIssue"] ? moment(_data["dlIssue"].toString()) : <any>undefined;
            this.dlExpiry = _data["dlExpiry"] ? moment(_data["dlExpiry"].toString()) : <any>undefined;
            this.dlState = _data["dlState"];
            this.code = _data["code"];
            this.spouseSuffix = _data["spouseSuffix"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.isActive = _data["isActive"];
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? JobTitle.fromJS(_data["jobTitle"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.ethnicityId = _data["ethnicityId"];
            this.ethnicity = _data["ethnicity"] ? Ethnicity.fromJS(_data["ethnicity"]) : <any>undefined;
            this.languageId = _data["languageId"];
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Spouse {
        data = typeof data === 'object' ? data : {};
        let result = new Spouse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["ssn"] = this.ssn;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["spouseJobDescription"] = this.spouseJobDescription;
        data["occupation"] = this.occupation;
        data["drivingLicense"] = this.drivingLicense;
        data["dlIssue"] = this.dlIssue ? this.dlIssue.toISOString() : <any>undefined;
        data["dlExpiry"] = this.dlExpiry ? this.dlExpiry.toISOString() : <any>undefined;
        data["dlState"] = this.dlState;
        data["code"] = this.code;
        data["spouseSuffix"] = this.spouseSuffix;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["ethnicityId"] = this.ethnicityId;
        data["ethnicity"] = this.ethnicity ? this.ethnicity.toJSON() : <any>undefined;
        data["languageId"] = this.languageId;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }

    clone(): Spouse {
        const json = this.toJSON();
        let result = new Spouse();
        result.init(json);
        return result;
    }
}

export interface ISpouse {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    spouseJobDescription: string | undefined;
    occupation: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    dlState: number | undefined;
    code: number | undefined;
    spouseSuffix: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    isActive: boolean;
    jobTitleId: number | undefined;
    jobTitle: JobTitle;
    companyId: number | undefined;
    company: Company;
    ethnicityId: number | undefined;
    ethnicity: Ethnicity;
    languageId: number | undefined;
    language: Language;
}

export class SpouseDto implements ISpouseDto {
    id: number;
    name: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    spouseJobDescription: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    dlState: number | undefined;
    code: number;
    customerId: number;
    isActive: boolean | undefined;
    jobTitleId: number | undefined;
    spouseSuffix: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    companyId: number | undefined;
    ethnicityId: number | undefined;
    languageId: number | undefined;

    constructor(data?: ISpouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.ssn = _data["ssn"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.spouseJobDescription = _data["spouseJobDescription"];
            this.drivingLicense = _data["drivingLicense"];
            this.dlIssue = _data["dlIssue"] ? moment(_data["dlIssue"].toString()) : <any>undefined;
            this.dlExpiry = _data["dlExpiry"] ? moment(_data["dlExpiry"].toString()) : <any>undefined;
            this.dlState = _data["dlState"];
            this.code = _data["code"];
            this.customerId = _data["customerId"];
            this.isActive = _data["isActive"];
            this.jobTitleId = _data["jobTitleId"];
            this.spouseSuffix = _data["spouseSuffix"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.companyId = _data["companyId"];
            this.ethnicityId = _data["ethnicityId"];
            this.languageId = _data["languageId"];
        }
    }

    static fromJS(data: any): SpouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["ssn"] = this.ssn;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["spouseJobDescription"] = this.spouseJobDescription;
        data["drivingLicense"] = this.drivingLicense;
        data["dlIssue"] = this.dlIssue ? this.dlIssue.toISOString() : <any>undefined;
        data["dlExpiry"] = this.dlExpiry ? this.dlExpiry.toISOString() : <any>undefined;
        data["dlState"] = this.dlState;
        data["code"] = this.code;
        data["customerId"] = this.customerId;
        data["isActive"] = this.isActive;
        data["jobTitleId"] = this.jobTitleId;
        data["spouseSuffix"] = this.spouseSuffix;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["companyId"] = this.companyId;
        data["ethnicityId"] = this.ethnicityId;
        data["languageId"] = this.languageId;
        return data;
    }

    clone(): SpouseDto {
        const json = this.toJSON();
        let result = new SpouseDto();
        result.init(json);
        return result;
    }
}

export interface ISpouseDto {
    id: number;
    name: string | undefined;
    ssn: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    spouseJobDescription: string | undefined;
    drivingLicense: string | undefined;
    dlIssue: moment.Moment | undefined;
    dlExpiry: moment.Moment | undefined;
    dlState: number | undefined;
    code: number;
    customerId: number;
    isActive: boolean | undefined;
    jobTitleId: number | undefined;
    spouseSuffix: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    companyId: number | undefined;
    ethnicityId: number | undefined;
    languageId: number | undefined;
}

export class StringCommonLookupInput implements IStringCommonLookupInput {
    item: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IStringCommonLookupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item = _data["item"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): StringCommonLookupInput {
        data = typeof data === 'object' ? data : {};
        let result = new StringCommonLookupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item"] = this.item;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }

    clone(): StringCommonLookupInput {
        const json = this.toJSON();
        let result = new StringCommonLookupInput();
        result.init(json);
        return result;
    }
}

export interface IStringCommonLookupInput {
    item: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class StringMemoryStreamTuple implements IStringMemoryStreamTuple {
    item1: string | undefined;
    item2: MemoryStream;

    constructor(data?: IStringMemoryStreamTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"] ? MemoryStream.fromJS(_data["item2"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StringMemoryStreamTuple {
        data = typeof data === 'object' ? data : {};
        let result = new StringMemoryStreamTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2 ? this.item2.toJSON() : <any>undefined;
        return data;
    }

    clone(): StringMemoryStreamTuple {
        const json = this.toJSON();
        let result = new StringMemoryStreamTuple();
        result.init(json);
        return result;
    }
}

export interface IStringMemoryStreamTuple {
    item1: string | undefined;
    item2: MemoryStream;
}

export enum SubscriptionStartType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TaxFillingStatusDto implements ITaxFillingStatusDto {
    value: number;
    name: string | undefined;

    constructor(data?: ITaxFillingStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TaxFillingStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxFillingStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }

    clone(): TaxFillingStatusDto {
        const json = this.toJSON();
        let result = new TaxFillingStatusDto();
        result.init(json);
        return result;
    }
}

export interface ITaxFillingStatusDto {
    value: number;
    name: string | undefined;
}

export enum TaxService {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TenureDto implements ITenureDto {
    value: number;
    name: string | undefined;

    constructor(data?: ITenureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenureDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }

    clone(): TenureDto {
        const json = this.toJSON();
        let result = new TenureDto();
        result.init(json);
        return result;
    }
}

export interface ITenureDto {
    value: number;
    name: string | undefined;
}

export class TenureForm implements ITenureForm {
    id: number;
    name: string | undefined;

    constructor(data?: ITenureForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenureForm {
        data = typeof data === 'object' ? data : {};
        let result = new TenureForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): TenureForm {
        const json = this.toJSON();
        let result = new TenureForm();
        result.init(json);
        return result;
    }
}

export interface ITenureForm {
    id: number;
    name: string | undefined;
}

export enum Title {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class TrialBalanceDto implements ITrialBalanceDto {
    id: number;
    mainHeadId: number;
    mainHeadName: string | undefined;
    subHeadId: number;
    subHeadName: string | undefined;
    creditAmount: number;
    debitAmount: number;
    openingBalance: number;
    balance: number;
    type: string | undefined;
    totalDebitAmount: number | undefined;
    totalCreditAmount: number | undefined;
    creationDate: moment.Moment;

    constructor(data?: ITrialBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mainHeadId = _data["mainHeadId"];
            this.mainHeadName = _data["mainHeadName"];
            this.subHeadId = _data["subHeadId"];
            this.subHeadName = _data["subHeadName"];
            this.creditAmount = _data["creditAmount"];
            this.debitAmount = _data["debitAmount"];
            this.openingBalance = _data["openingBalance"];
            this.balance = _data["balance"];
            this.type = _data["type"];
            this.totalDebitAmount = _data["totalDebitAmount"];
            this.totalCreditAmount = _data["totalCreditAmount"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrialBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrialBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mainHeadId"] = this.mainHeadId;
        data["mainHeadName"] = this.mainHeadName;
        data["subHeadId"] = this.subHeadId;
        data["subHeadName"] = this.subHeadName;
        data["creditAmount"] = this.creditAmount;
        data["debitAmount"] = this.debitAmount;
        data["openingBalance"] = this.openingBalance;
        data["balance"] = this.balance;
        data["type"] = this.type;
        data["totalDebitAmount"] = this.totalDebitAmount;
        data["totalCreditAmount"] = this.totalCreditAmount;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): TrialBalanceDto {
        const json = this.toJSON();
        let result = new TrialBalanceDto();
        result.init(json);
        return result;
    }
}

export interface ITrialBalanceDto {
    id: number;
    mainHeadId: number;
    mainHeadName: string | undefined;
    subHeadId: number;
    subHeadName: string | undefined;
    creditAmount: number;
    debitAmount: number;
    openingBalance: number;
    balance: number;
    type: string | undefined;
    totalDebitAmount: number | undefined;
    totalCreditAmount: number | undefined;
    creationDate: moment.Moment;
}

export class TrialBalanceInputDto implements ITrialBalanceInputDto {
    startDate: moment.Moment;
    endDate: moment.Moment;

    constructor(data?: ITrialBalanceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrialBalanceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrialBalanceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): TrialBalanceInputDto {
        const json = this.toJSON();
        let result = new TrialBalanceInputDto();
        result.init(json);
        return result;
    }
}

export interface ITrialBalanceInputDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
}

export class User implements IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    isAdmin: boolean;
    companyId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    employeeId: number | undefined;
    tokenExpiaryTime: moment.Moment | undefined;
    isActive: boolean;
    lastOnlineTime: moment.Moment | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isAdmin = _data["isAdmin"];
            this.companyId = _data["companyId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.employeeId = _data["employeeId"];
            this.tokenExpiaryTime = _data["tokenExpiaryTime"] ? moment(_data["tokenExpiaryTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.lastOnlineTime = _data["lastOnlineTime"] ? moment(_data["lastOnlineTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isAdmin"] = this.isAdmin;
        data["companyId"] = this.companyId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["employeeId"] = this.employeeId;
        data["tokenExpiaryTime"] = this.tokenExpiaryTime ? this.tokenExpiaryTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["lastOnlineTime"] = this.lastOnlineTime ? this.lastOnlineTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    isAdmin: boolean;
    companyId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    employeeId: number | undefined;
    tokenExpiaryTime: moment.Moment | undefined;
    isActive: boolean;
    lastOnlineTime: moment.Moment | undefined;
}

export class UserClaim implements IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLogin implements IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data;
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
}

export class UserNamePasswordDto implements IUserNamePasswordDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    type: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    url: string | undefined;
    description: string | undefined;

    constructor(data?: IUserNamePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.type = _data["type"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.url = _data["url"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UserNamePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNamePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["type"] = this.type;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["url"] = this.url;
        data["description"] = this.description;
        return data;
    }

    clone(): UserNamePasswordDto {
        const json = this.toJSON();
        let result = new UserNamePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IUserNamePasswordDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    type: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    url: string | undefined;
    description: string | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;
}

export class UserRole implements IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;
}

export class UserToken implements IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
}

export class VenderType implements IVenderType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IVenderType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): VenderType {
        data = typeof data === 'object' ? data : {};
        let result = new VenderType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): VenderType {
        const json = this.toJSON();
        let result = new VenderType();
        result.init(json);
        return result;
    }
}

export interface IVenderType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class VenderTypeDto implements IVenderTypeDto {
    id: number;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IVenderTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): VenderTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new VenderTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): VenderTypeDto {
        const json = this.toJSON();
        let result = new VenderTypeDto();
        result.init(json);
        return result;
    }
}

export interface IVenderTypeDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export class Vendor implements IVendor {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    businessName: string | undefined;
    dateOfBirth: moment.Moment;
    taxId: number;
    isActive: boolean;
    description: string | undefined;
    ssn: string | undefined;
    vendorName: string | undefined;
    venderTypeId: number | undefined;
    venderType: VenderType;
    companyId: number;

    constructor(data?: IVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.businessName = _data["businessName"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.taxId = _data["taxId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.ssn = _data["ssn"];
            this.vendorName = _data["vendorName"];
            this.venderTypeId = _data["venderTypeId"];
            this.venderType = _data["venderType"] ? VenderType.fromJS(_data["venderType"]) : <any>undefined;
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): Vendor {
        data = typeof data === 'object' ? data : {};
        let result = new Vendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["businessName"] = this.businessName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["taxId"] = this.taxId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["ssn"] = this.ssn;
        data["vendorName"] = this.vendorName;
        data["venderTypeId"] = this.venderTypeId;
        data["venderType"] = this.venderType ? this.venderType.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): Vendor {
        const json = this.toJSON();
        let result = new Vendor();
        result.init(json);
        return result;
    }
}

export interface IVendor {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    businessName: string | undefined;
    dateOfBirth: moment.Moment;
    taxId: number;
    isActive: boolean;
    description: string | undefined;
    ssn: string | undefined;
    vendorName: string | undefined;
    venderTypeId: number | undefined;
    venderType: VenderType;
    companyId: number;
}

export class VendorContactInfoDto implements IVendorContactInfoDto {
    id: number;
    contactPersonName: string | undefined;
    contactTypeName: string | undefined;
    fax: string | undefined;
    emailTypeId: number | undefined;
    eFax: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    webSite: string | undefined;
    primary: boolean;
    contactPersonTypeId: number | undefined;
    contactTypeId: number | undefined;
    vendorId: number | undefined;
    contactPersonType: ContactPersonType;
    contactTypeEnum: ContactTypeEnum;

    constructor(data?: IVendorContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactPersonName = _data["contactPersonName"];
            this.contactTypeName = _data["contactTypeName"];
            this.fax = _data["fax"];
            this.emailTypeId = _data["emailTypeId"];
            this.eFax = _data["eFax"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.webSite = _data["webSite"];
            this.primary = _data["primary"];
            this.contactPersonTypeId = _data["contactPersonTypeId"];
            this.contactTypeId = _data["contactTypeId"];
            this.vendorId = _data["vendorId"];
            this.contactPersonType = _data["contactPersonType"] ? ContactPersonType.fromJS(_data["contactPersonType"]) : <any>undefined;
            this.contactTypeEnum = _data["contactTypeEnum"];
        }
    }

    static fromJS(data: any): VendorContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactPersonName"] = this.contactPersonName;
        data["contactTypeName"] = this.contactTypeName;
        data["fax"] = this.fax;
        data["emailTypeId"] = this.emailTypeId;
        data["eFax"] = this.eFax;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["webSite"] = this.webSite;
        data["primary"] = this.primary;
        data["contactPersonTypeId"] = this.contactPersonTypeId;
        data["contactTypeId"] = this.contactTypeId;
        data["vendorId"] = this.vendorId;
        data["contactPersonType"] = this.contactPersonType ? this.contactPersonType.toJSON() : <any>undefined;
        data["contactTypeEnum"] = this.contactTypeEnum;
        return data;
    }

    clone(): VendorContactInfoDto {
        const json = this.toJSON();
        let result = new VendorContactInfoDto();
        result.init(json);
        return result;
    }
}

export interface IVendorContactInfoDto {
    id: number;
    contactPersonName: string | undefined;
    contactTypeName: string | undefined;
    fax: string | undefined;
    emailTypeId: number | undefined;
    eFax: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    webSite: string | undefined;
    primary: boolean;
    contactPersonTypeId: number | undefined;
    contactTypeId: number | undefined;
    vendorId: number | undefined;
    contactPersonType: ContactPersonType;
    contactTypeEnum: ContactTypeEnum;
}

export class VendorDto implements IVendorDto {
    id: number;
    businessName: string | undefined;
    taxId: number;
    isActive: boolean;
    description: string | undefined;
    ssn: string | undefined;
    vendorName: string | undefined;
    companyName: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    dateOfBirth: moment.Moment;
    venderTypeId: number | undefined;
    vender: VenderType;

    constructor(data?: IVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessName = _data["businessName"];
            this.taxId = _data["taxId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.ssn = _data["ssn"];
            this.vendorName = _data["vendorName"];
            this.companyName = _data["companyName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.venderTypeId = _data["venderTypeId"];
            this.vender = _data["vender"] ? VenderType.fromJS(_data["vender"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessName"] = this.businessName;
        data["taxId"] = this.taxId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["ssn"] = this.ssn;
        data["vendorName"] = this.vendorName;
        data["companyName"] = this.companyName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["venderTypeId"] = this.venderTypeId;
        data["vender"] = this.vender ? this.vender.toJSON() : <any>undefined;
        return data;
    }

    clone(): VendorDto {
        const json = this.toJSON();
        let result = new VendorDto();
        result.init(json);
        return result;
    }
}

export interface IVendorDto {
    id: number;
    businessName: string | undefined;
    taxId: number;
    isActive: boolean;
    description: string | undefined;
    ssn: string | undefined;
    vendorName: string | undefined;
    companyName: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    dateOfBirth: moment.Moment;
    venderTypeId: number | undefined;
    vender: VenderType;
}

export class Voucher implements IVoucher {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    locationId: number | undefined;
    voucherNo: string | undefined;
    voucherTypeCode: string | undefined;
    transactionTypeId: number | undefined;
    addDate: moment.Moment | undefined;
    transactionDate: moment.Moment | undefined;
    paymentType: number | undefined;
    paymentMode: number | undefined;
    chequeNo: number | undefined;
    invoiceId: number | undefined;
    tenantId: number;
    voucherDetails: VoucherDetail[] | undefined;

    constructor(data?: IVoucher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.locationId = _data["locationId"];
            this.voucherNo = _data["voucherNo"];
            this.voucherTypeCode = _data["voucherTypeCode"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.addDate = _data["addDate"] ? moment(_data["addDate"].toString()) : <any>undefined;
            this.transactionDate = _data["transactionDate"] ? moment(_data["transactionDate"].toString()) : <any>undefined;
            this.paymentType = _data["paymentType"];
            this.paymentMode = _data["paymentMode"];
            this.chequeNo = _data["chequeNo"];
            this.invoiceId = _data["invoiceId"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["voucherDetails"])) {
                this.voucherDetails = [] as any;
                for (let item of _data["voucherDetails"])
                    this.voucherDetails.push(VoucherDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Voucher {
        data = typeof data === 'object' ? data : {};
        let result = new Voucher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["locationId"] = this.locationId;
        data["voucherNo"] = this.voucherNo;
        data["voucherTypeCode"] = this.voucherTypeCode;
        data["transactionTypeId"] = this.transactionTypeId;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["paymentType"] = this.paymentType;
        data["paymentMode"] = this.paymentMode;
        data["chequeNo"] = this.chequeNo;
        data["invoiceId"] = this.invoiceId;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.voucherDetails)) {
            data["voucherDetails"] = [];
            for (let item of this.voucherDetails)
                data["voucherDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): Voucher {
        const json = this.toJSON();
        let result = new Voucher();
        result.init(json);
        return result;
    }
}

export interface IVoucher {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    locationId: number | undefined;
    voucherNo: string | undefined;
    voucherTypeCode: string | undefined;
    transactionTypeId: number | undefined;
    addDate: moment.Moment | undefined;
    transactionDate: moment.Moment | undefined;
    paymentType: number | undefined;
    paymentMode: number | undefined;
    chequeNo: number | undefined;
    invoiceId: number | undefined;
    tenantId: number;
    voucherDetails: VoucherDetail[] | undefined;
}

export class VoucherDetail implements IVoucherDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    refCompanyId: number | undefined;
    srNo: number | undefined;
    refChartOfAccountId: number | undefined;
    refCustomerId: number | undefined;
    note: string | undefined;
    dr_Amount: number | undefined;
    cr_Amount: number | undefined;
    partnerId: number | undefined;
    addDate: moment.Moment | undefined;
    transactionDate: moment.Moment | undefined;
    invoiceId: number | undefined;
    accountName: string | undefined;
    bankId: number | undefined;
    voucherId: number;
    voucherFk: Voucher;

    constructor(data?: IVoucherDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.refCompanyId = _data["refCompanyId"];
            this.srNo = _data["srNo"];
            this.refChartOfAccountId = _data["refChartOfAccountId"];
            this.refCustomerId = _data["refCustomerId"];
            this.note = _data["note"];
            this.dr_Amount = _data["dr_Amount"];
            this.cr_Amount = _data["cr_Amount"];
            this.partnerId = _data["partnerId"];
            this.addDate = _data["addDate"] ? moment(_data["addDate"].toString()) : <any>undefined;
            this.transactionDate = _data["transactionDate"] ? moment(_data["transactionDate"].toString()) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.accountName = _data["accountName"];
            this.bankId = _data["bankId"];
            this.voucherId = _data["voucherId"];
            this.voucherFk = _data["voucherFk"] ? Voucher.fromJS(_data["voucherFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VoucherDetail {
        data = typeof data === 'object' ? data : {};
        let result = new VoucherDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["refCompanyId"] = this.refCompanyId;
        data["srNo"] = this.srNo;
        data["refChartOfAccountId"] = this.refChartOfAccountId;
        data["refCustomerId"] = this.refCustomerId;
        data["note"] = this.note;
        data["dr_Amount"] = this.dr_Amount;
        data["cr_Amount"] = this.cr_Amount;
        data["partnerId"] = this.partnerId;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["accountName"] = this.accountName;
        data["bankId"] = this.bankId;
        data["voucherId"] = this.voucherId;
        data["voucherFk"] = this.voucherFk ? this.voucherFk.toJSON() : <any>undefined;
        return data;
    }

    clone(): VoucherDetail {
        const json = this.toJSON();
        let result = new VoucherDetail();
        result.init(json);
        return result;
    }
}

export interface IVoucherDetail {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    refCompanyId: number | undefined;
    srNo: number | undefined;
    refChartOfAccountId: number | undefined;
    refCustomerId: number | undefined;
    note: string | undefined;
    dr_Amount: number | undefined;
    cr_Amount: number | undefined;
    partnerId: number | undefined;
    addDate: moment.Moment | undefined;
    transactionDate: moment.Moment | undefined;
    invoiceId: number | undefined;
    accountName: string | undefined;
    bankId: number | undefined;
    voucherId: number;
    voucherFk: Voucher;
}

export class VoucherDetailDto implements IVoucherDetailDto {
    dAmount: number;
    cAmount: number;
    description: string | undefined;
    refCustomerId: number | undefined;
    customerName: string | undefined;
    name: string | undefined;
    chartOfAccountID: number;

    constructor(data?: IVoucherDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dAmount = _data["dAmount"];
            this.cAmount = _data["cAmount"];
            this.description = _data["description"];
            this.refCustomerId = _data["refCustomerId"];
            this.customerName = _data["customerName"];
            this.name = _data["name"];
            this.chartOfAccountID = _data["chartOfAccountID"];
        }
    }

    static fromJS(data: any): VoucherDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoucherDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dAmount"] = this.dAmount;
        data["cAmount"] = this.cAmount;
        data["description"] = this.description;
        data["refCustomerId"] = this.refCustomerId;
        data["customerName"] = this.customerName;
        data["name"] = this.name;
        data["chartOfAccountID"] = this.chartOfAccountID;
        return data;
    }

    clone(): VoucherDetailDto {
        const json = this.toJSON();
        let result = new VoucherDetailDto();
        result.init(json);
        return result;
    }
}

export interface IVoucherDetailDto {
    dAmount: number;
    cAmount: number;
    description: string | undefined;
    refCustomerId: number | undefined;
    customerName: string | undefined;
    name: string | undefined;
    chartOfAccountID: number;
}

export class VoucherList implements IVoucherList {
    id: number;
    creationTime: any | undefined;
    creatorUserId: number | undefined;
    lastModificationTime: any | undefined;
    lastModifierUserId: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    date: moment.Moment | undefined;
    voucherNo: string | undefined;
    voucherTypeCode: string | undefined;
    invoiceId: number | undefined;
    company: string | undefined;
    srNo: string | undefined;
    cr_Amount: number | undefined;
    dr_Amount: number | undefined;
    accountName: string | undefined;
    addedBy: string | undefined;

    constructor(data?: IVoucherList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"];
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.voucherNo = _data["voucherNo"];
            this.voucherTypeCode = _data["voucherTypeCode"];
            this.invoiceId = _data["invoiceId"];
            this.company = _data["company"];
            this.srNo = _data["srNo"];
            this.cr_Amount = _data["cr_Amount"];
            this.dr_Amount = _data["dr_Amount"];
            this.accountName = _data["accountName"];
            this.addedBy = _data["addedBy"];
        }
    }

    static fromJS(data: any): VoucherList {
        data = typeof data === 'object' ? data : {};
        let result = new VoucherList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["voucherTypeCode"] = this.voucherTypeCode;
        data["invoiceId"] = this.invoiceId;
        data["company"] = this.company;
        data["srNo"] = this.srNo;
        data["cr_Amount"] = this.cr_Amount;
        data["dr_Amount"] = this.dr_Amount;
        data["accountName"] = this.accountName;
        data["addedBy"] = this.addedBy;
        return data;
    }

    clone(): VoucherList {
        const json = this.toJSON();
        let result = new VoucherList();
        result.init(json);
        return result;
    }
}

export interface IVoucherList {
    id: number;
    creationTime: any | undefined;
    creatorUserId: number | undefined;
    lastModificationTime: any | undefined;
    lastModifierUserId: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    date: moment.Moment | undefined;
    voucherNo: string | undefined;
    voucherTypeCode: string | undefined;
    invoiceId: number | undefined;
    company: string | undefined;
    srNo: string | undefined;
    cr_Amount: number | undefined;
    dr_Amount: number | undefined;
    accountName: string | undefined;
    addedBy: string | undefined;
}

export class InvoiceDetails implements IInvoiceDetails {
    invoiceId: number | undefined;
    invoiceDetailId: number | undefined;
    productId: number | undefined;
    quantity: number | undefined;
    amount: number | undefined;
    isPaid: boolean | undefined;
    rate: number | undefined;
    saleTax: number | undefined;
    discount: number | undefined;
    customerId: number | undefined;
    invoiceNo: string | undefined;
    note: string | undefined;
    isSendLater: boolean | undefined;
    invoiceDueDate: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    email: string | undefined;
    customerEmail: string | undefined;
    refTermId: number | undefined;
    invoiceDate: moment.Moment | undefined;
    product: string | undefined;
    description: string | undefined;
    customerName: string | undefined;
    refChartOfAccountId: number | undefined;
    refCustomerId: number | undefined;
    paidAmount: number | undefined;
    vendorId: number | undefined;
    creditNoteDate: moment.Moment | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;
    companyName: string | undefined;
    csr: string | undefined;

    constructor(data?: IInvoiceDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.invoiceDetailId = _data["invoiceDetailId"];
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.amount = _data["amount"];
            this.isPaid = _data["isPaid"];
            this.rate = _data["rate"];
            this.saleTax = _data["saleTax"];
            this.discount = _data["discount"];
            this.customerId = _data["customerId"];
            this.invoiceNo = _data["invoiceNo"];
            this.note = _data["note"];
            this.isSendLater = _data["isSendLater"];
            this.invoiceDueDate = _data["invoiceDueDate"] ? moment(_data["invoiceDueDate"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.customerEmail = _data["customerEmail"];
            this.refTermId = _data["refTermId"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.product = _data["product"];
            this.description = _data["description"];
            this.customerName = _data["customerName"];
            this.refChartOfAccountId = _data["refChartOfAccountId"];
            this.refCustomerId = _data["refCustomerId"];
            this.paidAmount = _data["paidAmount"];
            this.vendorId = _data["vendorId"];
            this.creditNoteDate = _data["creditNoteDate"] ? moment(_data["creditNoteDate"].toString()) : <any>undefined;
            this.comAddress = _data["comAddress"];
            this.comCity = _data["comCity"];
            this.comState = _data["comState"];
            this.comPostCode = _data["comPostCode"];
            this.comCountry = _data["comCountry"];
            this.comEmail = _data["comEmail"];
            this.comPhone = _data["comPhone"];
            this.companyName = _data["companyName"];
            this.csr = _data["csr"];
        }
    }

    static fromJS(data: any): InvoiceDetails {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceDetailId"] = this.invoiceDetailId;
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["isPaid"] = this.isPaid;
        data["rate"] = this.rate;
        data["saleTax"] = this.saleTax;
        data["discount"] = this.discount;
        data["customerId"] = this.customerId;
        data["invoiceNo"] = this.invoiceNo;
        data["note"] = this.note;
        data["isSendLater"] = this.isSendLater;
        data["invoiceDueDate"] = this.invoiceDueDate ? this.invoiceDueDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["customerEmail"] = this.customerEmail;
        data["refTermId"] = this.refTermId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["product"] = this.product;
        data["description"] = this.description;
        data["customerName"] = this.customerName;
        data["refChartOfAccountId"] = this.refChartOfAccountId;
        data["refCustomerId"] = this.refCustomerId;
        data["paidAmount"] = this.paidAmount;
        data["vendorId"] = this.vendorId;
        data["creditNoteDate"] = this.creditNoteDate ? this.creditNoteDate.toISOString() : <any>undefined;
        data["comAddress"] = this.comAddress;
        data["comCity"] = this.comCity;
        data["comState"] = this.comState;
        data["comPostCode"] = this.comPostCode;
        data["comCountry"] = this.comCountry;
        data["comEmail"] = this.comEmail;
        data["comPhone"] = this.comPhone;
        data["companyName"] = this.companyName;
        data["csr"] = this.csr;
        return data;
    }

    clone(): InvoiceDetails {
        const json = this.toJSON();
        let result = new InvoiceDetails();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetails {
    invoiceId: number | undefined;
    invoiceDetailId: number | undefined;
    productId: number | undefined;
    quantity: number | undefined;
    amount: number | undefined;
    isPaid: boolean | undefined;
    rate: number | undefined;
    saleTax: number | undefined;
    discount: number | undefined;
    customerId: number | undefined;
    invoiceNo: string | undefined;
    note: string | undefined;
    isSendLater: boolean | undefined;
    invoiceDueDate: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    email: string | undefined;
    customerEmail: string | undefined;
    refTermId: number | undefined;
    invoiceDate: moment.Moment | undefined;
    product: string | undefined;
    description: string | undefined;
    customerName: string | undefined;
    refChartOfAccountId: number | undefined;
    refCustomerId: number | undefined;
    paidAmount: number | undefined;
    vendorId: number | undefined;
    creditNoteDate: moment.Moment | undefined;
    comAddress: string | undefined;
    comCity: string | undefined;
    comState: string | undefined;
    comPostCode: string | undefined;
    comCountry: string | undefined;
    comEmail: string | undefined;
    comPhone: string | undefined;
    companyName: string | undefined;
    csr: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}